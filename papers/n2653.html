<!doctype html public "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">

<head>

<title>char8_t: A type for UTF-8 characters and strings (Revision 1)</title>

<style type="text/css">
pre {
    display: inline;
}

table#header th,
table#header td
{
    text-align: left;
}
table#references th,
table#references td
{
    vertical-align: top;
}

ins, ins * { text-decoration:none; font-weight:bold; background-color:#A0FFA0 }
del, del * { text-decoration:line-through; background-color:#FFA0A0 }
#hidedel:checked ~ * del, #hidedel:checked ~ * del * { display:none; visibility:hidden }

blockquote
{
    color: #000000;
    background-color: #F1F1F1;
    border: 1px solid #D1D1D1;
    padding-left: 0.5em;
    padding-right: 0.5em;
}
blockquote.stdins
{
    text-decoration: underline;
    color: #000000;
    background-color: #C8FFC8;
    border: 1px solid #B3EBB3;
    padding: 0.5em;
}
blockquote.stddel
{
    text-decoration: line-through;
    color: #000000;
    background-color: #FFEBFF;
    border: 1px solid #ECD7EC;
    padding-left: 0.5empadding-right: 0.5em;
}

div.compare {
  padding-left: 40px;
  display: table; /* undo float:left effect */
}
div.compare_item {
  float: left;
  margin: 2px;
}

</style>

</head>


<body>

<table id="header">
  <tr>
    <th>Proposal for C2x</th>
  </tr>
  <tr>
    <th>WG14 N2653 <em>Draft</em></th>
  </tr>
  <tr>
    <th/>
  </tr>
  <tr>
    <th>Title:</th>
    <td>char8_t: A type for UTF-8 characters and strings (Revision 1)</td>
  </tr>
  <tr>
    <th>Revises:</th>
    <td><a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2231.htm">N2231</a></td>
  </tr>
  <tr>
    <th>Author:</th>
    <td>Tom Honermann &lt;tom@honermann.net&gt;</td>
  </tr>
  <tr>
    <th>Date:</th>
    <td>2021-02-13</td>
  </tr>
  <tr>
    <th>Proposal category:</th>
    <td>New features, change to existing features</td>
  </tr>
  <tr>
    <th>Target audience:</th>
    <td>Developers working on combined C and C++ code bases</td>
  </tr>
</table>


<p>
<strong>Abstract:</strong> C++20, through the adoption of
<a title="[P0482R6]: char8_t: A type for UTF-8 characters and strings (Revision 6)"
   href="https://wg21.link/p0482r6">
P0482R6</a>
<sup><a title="[P0482R6]: char8_t: A type for UTF-8 characters and strings (Revision 6)"
        href="#ref_p0482r6">
[P0482R6]</a></sup>,
added a new <tt>char8_t</tt> fundamental type, changed the character
type of <tt>u8</tt> character and string literals from <tt>char</tt> to
<tt>char8_t</tt>, and added the <tt>c8rtomb()</tt> and <tt>mbrtoc8()</tt>
functions for conversion between multibyte characters and UTF-8.
This paper proposes corresponding changes for C to add a <tt>char8_t</tt>
typedef of <tt>unsigned char</tt>, to change the array element type of
<tt>u8</tt> string literals from <tt>char</tt> to <tt>unsigned char</tt>
(<tt>u8</tt> character literals already have type <tt>unsigned char</tt>),
and to add the <tt>c8rtomb()</tt> and <tt>mbrtoc8()</tt> functions.
These changes are intended to improve support for UTF-8 and source code
compatibility between the C and C++ languages.
</p>


<ul>
  <li><a href="#changes_since_n2231">
      Changes since N2231</a></li>
  <li><a href="#introduction">
      Introduction</a></li>
  <li><a href="#motivation">
      Motivation</a></li>
  <li><a href="#proposal">
      Proposal</a></li>
  <li><a href="#backward_compat">
      Backward Compatibility</a></li>
  <li><a href="#implementation_exp">
      Implementation Experience</a></li>
  <li><a href="#wording">
      Formal Wording</a></li>
  <li><a href="#acknowledgements">
      Acknowledgements</a></li>
  <li><a href="#references">
      References</a></li>
</ul>


<h1 id="changes_since_n2231">Changes since <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2231.htm">N2231</a></h1>

<ul>
  <li>Proposal changes:
    <ul>
      <li>Rebased the proposed wording on
          <a title="[WG14 N2596]: C2x Working Draft"
             href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2596.pdf">
          WG14 N2596</a>
          <sup><a title="[WG14 N2596]: C2x Working Draft"
                  href="#ref_wg14_n2596">
          [WG14 N2596]</a></sup></li>
      <li>Updated wording to address <tt>u8</tt> character literals and removed
          references to
          <a title="[WG14 N2198]: Adding the u8 character prefix"
             href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2198.pdf">
          WG14 N2198</a>
          since it has been incorporated in the working draft.</li>
      <li>Removed drafting notes regarding
          <a title="[WG14 DR 488]: c16rtomb() on wide characters encoded as multiple char16_t"
             href="http://www.open-std.org/jtc1/sc22/WG14/www/docs/summary.htm#dr_488">
          WG14 DR 488</a>
          since its resolution has now been incorporated in the working draft.</li>
      <li>Removed the previously proposed <tt>__STDC_UTF_8__</tt> macro since the
          UTF-8 character and string literals and <tt>char8_t</tt> type are intended
          only for use with UTF-8.</li>
    </ul>
  </li>
  <li>Other changes:
    <ul>
      <li>Rewrote the abstract to reflect that
          <a title="[P0482R6]: char8_t: A type for UTF-8 characters and strings (Revision 6)"
             href="https://wg21.link/p0482r6">
          P0482R6</a>
          <sup><a title="[P0482R6]: char8_t: A type for UTF-8 characters and strings (Revision 6)"
                  href="#ref_p0482r6">
          [P0482R6]</a></sup>
          was adopted for C++20.</li>
      <li>Updated the UTF-8 statistics quoted from W3Techs from 2017 to 2021.</li>
      <li>Removed the previous example from the
          <a href="#motivation">Motivation</a> section illustrating incorrect
          use of "ANSI" Win32 APIs.</li>
      <li>Updated the <a href="#implementation_exp">Implementation Experience</a>
          section with links to completed implementations in gcc and glibc.</li>
      <li>Added missing items to the <a href="#backward_compat">Backward Compatibility</a> section.</li>
      <li>Replaced use of "execution character encoding" with the more standard
          "execution character set" terminology.</li>
      <li>Additional minor prose and miscellaneous updates.</li>
      <li>Removed use of highlight.js for code highlighting purposes.</li>
    </ul>
  </li>
</ul>


<h1 id="introduction">Introduction</h1>

<p>C11 introduced support for UTF-8, 16-bit, and 32-bit encoded string
literals.  New <tt>char16_t</tt> and <tt>char32_t</tt> typedefs were added to
hold values of code units for the 16-bit and 32-bit variants, but a new type
was not added for the UTF-8 variant.  Instead, UTF-8 string literals were
defined in terms of the <tt>char</tt> type used for the code unit type of
ordinary string literals.  UTF-8 is the only text encoding mandated to be
supported by the C standard for which there is no distinctly named code unit
type.
</p>

<p>Whether <tt>char</tt> is a signed or unsigned type is implementation
defined and implementations that use an 8-bit signed char are at a
disadvantage with respect to working with UTF-8 encoded text due to the
necessity of having to rely on conversions to unsigned types in order to
correctly process leading and continuation code units of multi-byte encoded
code points.
</p>

<p>The lack of a distinct type and the use of a code unit type with a range
that does not portably include the full unsigned range of UTF-8 code units
presents challenges for working with UTF-8 encoded text that are not present
when working with UTF-16 or UTF-32 encoded text.  Enclosed is a proposal for
a new <tt>char8_t</tt> typedef and related library enhancements intended to
remove barriers to working with UTF-8 encoded text and to enable working with
all five of the standard mandated text encodings in a consistent manner.
</p>


<h1 id="motivation">Motivation</h1>

<p>As of February 2021,
<a title="Usage of UTF-8 for websites"
   href="https://w3techs.com/technologies/details/en-utf8/all/all">
UTF-8 is now used by more than 96% of all websites</a>
<sup><a title="Usage of UTF-8 for websites"
        href="#ref_w3techs">
[W3Techs]</a></sup>.
While UTF-8 now dominates websites, it has not attained similar usage success
as the execution character set of C and C++ compilers.  Important
compilers, such as Microsoft's Visual C++, do not support use of UTF-8 as
the execution character set<sup>[*]</sup>.  Programs that must consume
and produce text in the execution character set and manipulate UTF-8
text must choose one of two approaches to managing text in these distinct
encodings:
<ol>
  <li>Use <tt>char</tt> for both encodings while being careful to transcode
      between the encodings when necessary.</li>
  <li>Use <tt>char</tt> for the execution character set, and another
      type, generally <tt>unsigned char</tt>, for UTF-8.</li>
</ol>
</p>

<p>The challenge with the first approach is ensuring that text is
appropriately transcoded and is in the correct encoding when passed to
other functions.  Since the same type, <tt>char</tt>, is used as the code unit
type for both encodings, the programmer is unable to rely on the type system
to help identify mistakes.
</p>

<p>The challenge with the second approach is that UTF-8 string literals have
type array of <tt>char</tt>.  Direct comparisons with UTF-8 string literals
are subject to sign mismatch (depending on the sign of <tt>char</tt>), and
attempts to assign pointers to the desired code unit type directly to UTF-8
string literals results in assignment from incompatible pointer types
(regardless of the sign of <tt>char</tt>).
</p>

<p>Difficulty in managing multiple encodings with the same code unit type is
not the only challenge posed by use of <tt>char</tt> as the UTF-8 code unit
type.  The following code exhibits implementation defined behavior.
<blockquote><pre>
_Bool is_utf8_multibyte_code_unit(char c) {
  return c &gt;= 0x80;
}
</pre></blockquote>
</p>

<p>UTF-8 leading and continuation code units have values in the range 128
(0x80) to 255 (0xFF).  In the common case where <tt>char</tt> is implemented
as a signed 8-bit type with a two's complement representation and a range of
-128 (-0x80) to 127 (0x7F), these values exceed the unsigned range of the
<tt>char</tt> type.  Such implementations typically encode such code units as
unsigned values which are then reinterpreted as signed values when read.  In
the code above, integral promotion rules result in <tt>c</tt> being promoted to
type <tt>int</tt> for comparison to the <tt>0x80</tt> operand.  if <tt>c</tt>
holds a value corresponding to a leading or continuation code unit value, then
its value will be interpreted as negative and the promoted value of type
<tt>int</tt> will likewise be negative.  The result is that the comparison
is always false for these implementations.</p>

<p>To correct the code above, explicit conversions are required.  For example:
<blockquote><pre>
_Bool is_utf8_multibyte_code_unit(char c) {
  return ((unsigned char)c) &gt;= 0x80;
}
</pre></blockquote>
</p>

<p>Finally, no facilities are currently provided for transcoding between the
execution character set and UTF-8.
</p>

<p>The issues described above present significant challenges to working with
UTF-8 encoded text.  As the use of UTF-8 continues to rise, the ability to
work well with UTF-8 text will only grow more important.  The changes proposed
in this paper are intended to address the above issues while retaining the
ability to write source code that is compatible across C and C++.
</p>

<p><em>[*]: Microsoft Visual C++ 2015 added the <tt>/utf-8</tt> and
<tt>/execution-charset:utf-8</tt> options to enable use of UTF-8 as the
execution character set.  However, in practice, these options are of limited
use since the Windows platform SDK does not, in general, support UTF-8.</em>
<font color="red">
<br/>
<em>FIXME</em>: The Windows 10 April 2018 update added beta support for
using UTF-8 as the system code page either by updating regional settings
(affects all programs) or by compiling with an appropriately configured
manifest (affects only the program being build).
</font>
</p>


<h1 id="proposal">Proposal</h1>

<p>The proposed changes include:

<ul>
  <li>A new typedef of <tt>unsigned char</tt> named <tt>char8_t</tt> defined
      in the <tt>&lt;uchar.h&gt;</tt> header.</li>
  <li>The type of UTF-8 string literals is changed from array of
      <tt>const char</tt> to array of <tt>const char8_t</tt>.</li>
  <li>The type of UTF-8 character literals is changed from
      <tt>unsigned char</tt> to <tt>char8_t</tt>.</li>
  <li>New <tt>mbrtoc8()</tt> and <tt>c8rtomb()</tt> functions declared in
      <tt>&lt;uchar.h&gt;</tt> enable conversions between multibyte characters
      and UTF-8.</li>
  <li>New <tt>char8_t</tt> related atomic macros and types.</li>
</ul>
</p>

<p>The addition of the <tt>char8_t</tt> typedef is intended to support source
code compatibility between C and C++20 such that the following code would be
well-formed with the same semantics for both languages while providing
additional type safety and protection from implementation defined sign issues.
<blockquote><pre>
#include &lt;uchar.h&gt;

void use_utf8(const char8_t *p) {
  if (p[0] &gt;= 0x80) {
    /* Handle UTF-8 lead or continuation code unit... */
  }
}

int main() {
  use_utf8(u8"text");
}
</pre></blockquote>
</p>


<h1 id="backward_compat">Backward Compatibility</h1>

<p>The changes proposed in this paper impact backward compatibility as a
result of changing the type of UTF-8 string literals.  There are four primary
consequences:
<ol>
  <li>Code that directly accesses the code unit values of UTF-8 string literals
      without an intervening cast to an unsigned type may experience silent
      behavioral changes for implementations with a signed 8-bit <tt>char</tt>
      type.  In general, such accesses are likely indicative of latent defects
      in the code, and are defects likely fixed by the proposed changes.</li>
  <li>Initialization or assignment of <tt>const char</tt> pointers (including
      parameters) from UTF-8 string literals will now result in incompatible
      pointer conversions.  This is an intentional change intended to allow
      the use of compiler diagnostics to identify cases where incorrectly
      encoded text is used.</li>
  <li>Initialization of arrays of type <tt>char</tt> with a UTF-8 string
      literal will now be ill-formed.  This is an intentional change intended
      to allow the use of compiler diagnostics to identify cases where
      incorrectly encoded text is used.</li>
  <li>Code that makes use of <tt>_Generic</tt> or type deduction extensions
      such as gcc's <tt>__typeof__</tt> type specifier may become ill-formed
      or behave differently.</li>
</ol>
</p>

<p>These changes are a primary objective of this proposal.  Implementations
are encouraged to add options to disable <tt>char8_t</tt> support entirely
when necessary to preserve compatibility with prior C language standards.
</p>


<h1 id="implementation_exp">Implementation Experience</h1>

<p>The proposed changes have been implemented in forks of gcc and glibc and
are available in the <tt>char8_t-for-c</tt> and <tt>char8_t</tt> branches
respectively of the following repositories:
<ul>
  <li>gcc: <a href="https://github.com/tahonermann/gcc/tree/char8_t-for-c">
      https://github.com/tahonermann/gcc/tree/char8_t-for-c</a></li>
  <li>glibc: <a href="https://github.com/tahonermann/glibc/tree/char8_t">
      https://github.com/tahonermann/glibc/tree/char8_t</a></li>
</ul>
</p>

<p>
The changes to glibc provide declarations for the <tt>char8_t</tt> typedef
and the <tt>c8rtomb()</tt> and <tt>mbrtoc8()</tt> functions.  When compiling
for C, these declarations are only present when the <tt>_CHAR8_T_SOURCE</tt>
feature test macro is defined.
</p>

<p>
The changes to gcc provide the <tt>atomic_char8_t</tt> typedef, the
<tt>ATOMIC_CHAR8_T_LOCK_FREE</tt> macro, and the change of type for UTF-8
literals from array of <tt>const char</tt> to array of
<tt>const unsigned char</tt>.  The existing <tt>-fchar8_t</tt> and
<tt>-fno-char8_t</tt> compiler options are extended to C code to allow
opting-in or opting-out of these changes.  When <tt>-fchar8_t</tt> is
enabled, the <tt>_CHAR8_T_SOURCE</tt> macro is defined to inform the
C library that the <tt>char8_t</tt> typedef and the <tt>c8rtomb()</tt>
and <tt>mbrtoc8()</tt> declarations should be provided by the <tt>uchar.h</tt>
header..
</p>


<h1 id="wording">Formal Wording</h1>

<input type="checkbox" id="hidedel">Hide deleted text</input>

<p>These changes are relative to
<a title="[WG14 N2596]: C2x Working Draft"
   href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2596.pdf">
WG14 N2596</a>
<sup><a title="[WG14 N2596]: C2x Working Draft"
        href="#ref_wg14_n2596">
[WG14 N2596]</a></sup>
</p>

<p>Change in 6.4.4 (Character constants) paragraph 9:
<blockquote>
The value of an octal or hexadecimal escape sequence shall be in the range of
representable values for the corresponding type:
<div style="margin-left: 1em;">
<table style="border-collapse: collapse;">
  <tr style="border-bottom: 1px solid black;">
    <td style="border-right: 1px solid black;">Prefix</td>
    <td>Corresponding type</td>
  </tr>
  <tr>
    <td style="border-right: 1px solid black;">none</td>
    <td><tt>unsigned char</tt></td>
  </tr>
  <tr>
    <td style="border-right: 1px solid black;"><tt>u8</tt></td>
    <td><tt><del>unsigned char</del><ins>char8_t</ins></tt></td>
  </tr>
  <tr>
    <td style="border-right: 1px solid black;"><tt>L</tt></td>
    <td>the unsigned type corresponding to <tt>wchar_t</tt></td>
  </tr>
  <tr>
    <td style="border-right: 1px solid black;"><tt>u</tt></td>
    <td><tt>char16_t</tt></td>
  </tr>
  <tr>
    <td style="border-right: 1px solid black;"><tt>U</tt></td>
    <td><tt>char32_t</tt></td>
  </tr>
</table>
</div>
</blockquote>
</p>

<p>Change in 6.4.4 (Character constants) paragraph 12:
<blockquote>
A UTF-8 character constant has type
<tt><del>unsigned char</del><ins>char8_t</ins></tt>.
The value of a UTF-8 character constant is equal to its ISO/IEC 10646 code
point value, provided that the code point value can be encoded as a
single UTF-8 code unit.
</blockquote>
</p>

<p>Change in 6.4.5 (String Literals) paragraph 6:
<blockquote>
[&hellip;] For UTF-8 string literals, the array elements have type
<del><tt>char</tt></del><ins><tt>char8_t</tt></ins>, and are initialized with
the characters of the multibyte character sequence, as encoded in UTF–8.
[&hellip;]
</blockquote>
</p>

<p>Change in 6.7.9 (Initialization) paragraph 14:
<blockquote>
An array of character type may be initialized by a character string
literal<del> or UTF-8 string literal</del>, optionally enclosed in braces. Successive
bytes of the string literal (including the terminating null character if there
is room or if the array is of unknown size) initialize the elements of the
array.
</blockquote>
</p>

<p><em>Drafting note: The changes to 6.7.9p14 affect backward compatibility
by removing the ability to initialize an array of character type with a UTF-8
string literal.  This is an intentional change made to align with C++20.
</em></p>

<p>Insert a new paragraph after 6.7.9 (Initialization) paragraph 14:
<blockquote class=stdins>
An array with element type compatible with a qualified or unqualified version
of <tt>char8_t</tt> may be initialized by a UTF-8 string literal, optionally
enclosed in braces.  Successive bytes of the string literal (including the
terminating null character if there is room or if the array is of unknown size)
initialize the elements of the array.
</blockquote>
</p>

<p>Change in 7.17.1 (Introduction) paragraph 3:
<blockquote>
The macros defined are the <em>atomic lock-free macros</em>
<blockquote>
ATOMIC_BOOL_LOCK_FREE<br/>
ATOMIC_CHAR_LOCK_FREE<br/>
<ins>ATOMIC_CHAR8_T_LOCK_FREE</ins><br/>
ATOMIC_CHAR16_T_LOCK_FREE<br/>
ATOMIC_CHAR32_T_LOCK_FREE<br/>
ATOMIC_WCHAR_T_LOCK_FREE<br/>
ATOMIC_SHORT_LOCK_FREE<br/>
ATOMIC_INT_LOCK_FREE<br/>
ATOMIC_LONG_LOCK_FREE<br/>
ATOMIC_LLONG_LOCK_FREE<br/>
ATOMIC_POINTER_LOCK_FREE<br/>
</blockquote>
[&hellip;]<br/>
</blockquote>
</p>

<p>Change in 7.17.6 (Atomic integer types) paragraph 1:
<blockquote>
For each line in the following
table,<sup><em>[Footnote: See "future library directions" (7.31.10).]</em></sup>
the atomic type name is declared as a type that has the same representation
and alignment requirements as the corresponding direct
type.<sup><em>[Footnote: The same representation and alignment requirements are
meant to imply interchangeability as arguments to functions, return values
from functions, and members of unions.]</em></sup>
<div style="margin-left: 1em;">
<table style="border-collapse: collapse;">
  <tr style="border-bottom: 1px solid black;">
    <td>Atomic type name</td>
    <td>Direct type</td>
  </tr>
  <tr>
    <td>[&hellip;]</td>
    <td>[&hellip;]</td>
  </tr>
  <tr>
    <td><tt>atomic_ullong</tt></td>
    <td><tt>_Atomic unsigned long long</tt></td>
  </tr>
  <tr>
    <td><tt><ins>atomic_char8_t</ins></tt></td>
    <td><tt><ins>_Atomic char8_t</ins></tt></td>
  </tr>
  <tr>
    <td><tt>atomic_char16_t</tt></td>
    <td><tt>_Atomic char16_t</tt></td>
  </tr>
  <tr>
    <td><tt>atomic_char32_t</tt></td>
    <td><tt>_Atomic char32_t</tt></td>
  </tr>
  <tr>
    <td><tt>atomic_wchar_t</tt></td>
    <td><tt>_Atomic wchar_t</tt></td>
  </tr>
  <tr>
    <td>[&hellip;]</td>
    <td>[&hellip;]</td>
  </tr>
</table>
</div>
</blockquote>
</p>

<p>Change in 7.28 (Unicode utilities &lt;uchar.h&gt;) paragraph 2:
<blockquote>
The types declared are <tt>mbstate_t</tt> (described in 7.29.1) and
<tt>size_t</tt> (described in 7.19);
<ins>
<blockquote>
<tt>char8_t</tt>
</blockquote>
which is an unsigned integer type used for UTF-8 characters and is the
same type as <tt>unsigned char</tt>; and</ins>
</ins>
<blockquote>
<tt>char16_t</tt>
</blockquote>
which is an unsigned integer type used for 16-bit characters and is the same
type as <tt>uint_least16_t</tt> (described in 7.20.1.12); and</ins>
<blockquote>
<tt>char32_t</tt>
</blockquote>
which is an unsigned integer type used for 32-bit characters and is the same
type as <tt>uint_least32_t</tt> (described in 7.20.1.12).</ins>
</blockquote>
</p>

<p>Insert a new subclause before 7.28.1.1 (The mbrtoc16 function):
<blockquote class="stdins">
7.28.1.1  <strong>The mbrtoc8 function</strong>
</blockquote>
</p>

<p>Add a new paragraph 1:
<blockquote class="stdins">
<strong>Synopsis</strong><br/>
<blockquote>
<div style="margin-left: 1em;">
<tt>#include</tt> &lt;uchar.h&gt;<br/>
<tt>size_t</tt> mbrtoc8(<tt>char8_t</tt> * <tt>restrict</tt> pc8,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>const</tt> <tt>char</tt> * <tt>restrict</tt> s, <tt>size_t</tt> n,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>mbstate_t</tt> * <tt>restrict</tt> ps);
</div>
</blockquote>
</blockquote>
</p>

<p>Add a new paragraph 2:
<blockquote class="stdins">
<strong>Description</strong><br/>
If <tt>s</tt> is a null pointer, the <tt>mbrtoc8</tt> function is equivalent
to the call:
<blockquote>
<div style="margin-left: 2em;">
mbrtoc8(NULL, "", 1, ps)
</div>
</blockquote>
In this case, the values of the parameters <tt>pc8</tt> and <tt>n</tt> are
ignored.
</blockquote>
</p>

<p>Add a new paragraph 3:
<blockquote class="stdins">
If <tt>s</tt> is not a null pointer, the <tt>mbrtoc8</tt> function inspects at
most <tt>n</tt> bytes beginning with the byte pointed to by <tt>s</tt> to
determine the number of bytes needed to complete the next multibyte character
(including any shift sequences). If the function determines that the next
multibyte character is complete and valid, it determines the values of the
corresponding characters and then, if <tt>pc8</tt> is not a null pointer,
stores the value of the first (or only) such character in the object pointed to
by <tt>pc8</tt>. Subsequent calls will store successive characters without
consuming any additional input until all the characters have been stored. If
the corresponding character is the null character, the resulting
state described is the initial conversion state.
</blockquote>
</p>

<p>Add a new paragraph 4:
<blockquote class="stdins">
<strong>Returns</strong><br/>
The <tt>mbrtoc8</tt> function returns the first of the following that applies
(given the current conversion state):
<table>
  <tr>
    <td>0</td>
    <td>if the next <tt>n</tt> or fewer bytes complete the multibyte character
        that corresponds to the null character (which is the value stored).
    </td>
  </tr>
  <tr>
    <td><em>between 1 and <tt>n</tt> inclusive</em></td>
    <td>if the next <tt>n</tt> or fewer bytes complete a valid multibyte
        character (which is the value stored); the value returned is the number
        of bytes that complete the multibyte character.
    </td>
  </tr>
  <tr>
    <td><tt>(size_t)</tt> (−3)</td>
    <td>if the next character resulting from a previous call has been stored
        (no bytes from the input have been consumed by this call).
    </td>
  </tr>
  <tr>
    <td><tt>(size_t)</tt> (−2)</td>
    <td>if the next <tt>n</tt> bytes contribute to an incomplete (but
        potentially valid) multibyte character, and all <tt>n</tt> bytes have
        been processed (no value is
        stored).<sup><em>[Footnote: When <tt>n</tt> has at least the value of
        the <tt>MB_CUR_MAX</tt> macro, this case can only occur if <tt>s</tt>
        points at a sequence of redundant shift sequences (for implementations
        with state-dependent encodings).]</em></sup>
    </td>
  </tr>
  <tr>
    <td><tt>(size_t)</tt> (−1)</td>
    <td>if an encoding error occurs, in which case the next <tt>n</tt> or
        fewer bytes do not contribute to a complete and valid multibyte
        character (no value is stored); the value of the macro <tt>EILSEQ</tt>
        is stored in <tt>errno</tt>, and the conversion state is unspecified.
    </td>
  </tr>
</table>
</blockquote>
</p>

<p>Insert another new subclause before 7.28.1.1 (The mbrtoc16 function):
<blockquote class="stdins">
7.28.1.2  <strong>The c8rtomb function</strong>
</blockquote>
</p>

<p>Add a new paragraph 1:
<blockquote class="stdins">
<strong>Synopsis</strong><br/>
<blockquote>
<div style="margin-left: 1em;">
<tt>#include</tt> &lt;uchar.h&gt;<br/>
<tt>size_t</tt> c8rtomb(<tt>char</tt> * <tt>restrict</tt> s, <tt>char8_t</tt> c8,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>mbstate_t</tt> * <tt>restrict</tt> ps);
</div>
</blockquote>
</blockquote>
</p>

<p>Add a new paragraph 2:
<blockquote class="stdins">
<strong>Description</strong><br/>
If <tt>s</tt> is a null pointer, the c8rtomb function is equivalent to the call
<blockquote>
<div style="margin-left: 2em;">
c8rtomb(buf, u8'\0', ps)
</div>
</blockquote>
where <tt>buf</tt> is an internal buffer.
</blockquote>
</p>

<p>Add a new paragraph 3:
<blockquote class="stdins">
If <tt>s</tt> is not a null pointer, the <tt>c8rtomb</tt> function determines
the number of bytes needed to represent the multibyte character that corresponds
to the character given or completed by <tt>c8</tt> (including any shift
sequences), and stores the multibyte character representation in the array whose
first element is pointed to by <tt>s</tt>, or stores nothing if <tt>c8</tt> does
not represent a complete character.  At most <tt>MB_CUR_MAX</tt> bytes are
stored. If <tt>c8</tt> is a null character, a null byte is stored, preceded
by any shift sequence needed to restore the initial shift state; the resulting
state described is the initial conversion state.
</blockquote>
</p>

<p>Add a new paragraph 4:
<blockquote class="stdins">
<strong>Returns</strong><br/>
The <tt>c8rtomb</tt> function returns the number of bytes stored in the array
object (including any shift sequences). When <tt>c8</tt> is not a valid
character, an encoding error occurs: the function stores the value of the macro
<tt>EILSEQ</tt> in <tt>errno</tt> and returns <tt>(size_t)</tt> (−1); the
conversion state is unspecified.
</blockquote>
</p>

<p>Change in B.16 (Atomics &lt;stdatomic.h&gt;)
<blockquote>
[&hellip;]<br/>
<tt>ATOMIC_CHAR_LOCK_FREE</tt><br/>
<ins><tt>ATOMIC_CHAR8_T_LOCK_FREE</tt></ins><br/>
<tt>ATOMIC_CHAR16_T_LOCK_FREE</tt><br/>
<tt>ATOMIC_CHAR32_T_LOCK_FREE</tt><br/>
<tt>ATOMIC_WCHAR_T_LOCK_FREE</tt><br/>
[&hellip;]<br/>
<tt>atomic_ullong</tt><br/>
<ins><tt>atomic_char8_t</tt></ins><br/>
<tt>atomic_char16_t</tt><br/>
<tt>atomic_char32_t</tt><br/>
<tt>atomic_wchar_t</tt><br/>
[&hellip;]<br/>
</blockquote>
</p>

<p>Change in B.27 (Unicode utilities &lt;uchar.h&gt;)
<blockquote>
<table>
  <tr>
    <td><tt>mbstate_t</tt></td>
    <td><tt>size_t</tt></td>
    <td><tt><ins>char8_t</ins></tt></td>
    <td><tt>char16_t</tt></td>
    <td><tt>char32_t</tt></td>
  </tr>
</table>
<blockquote>
<div style="margin-left: 1em;">
<ins>
<tt>size_t</tt> mbrtoc8(<tt>char8_t</tt> * <tt>restrict</tt> pc8,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>const</tt> <tt>char</tt> * <tt>restrict</tt> s, <tt>size_t</tt> n,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>mbstate_t</tt> * <tt>restrict</tt> ps);<br/>
<tt>size_t</tt> c8rtomb(<tt>char</tt> * <tt>restrict</tt> s, <tt>char8_t</tt> c8,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>mbstate_t</tt> * <tt>restrict</tt> ps);<br/>
</ins>
<tt>size_t</tt> mbrtoc16(<tt>char16_t</tt> * <tt>restrict</tt> pc16,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>const</tt> <tt>char</tt> * <tt>restrict</tt> s, <tt>size_t</tt> n,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>mbstate_t</tt> * <tt>restrict</tt> ps);<br/>
<tt>size_t</tt> c16rtomb(<tt>char</tt> * <tt>restrict</tt> s, <tt>char16_t</tt> c16,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>mbstate_t</tt> * <tt>restrict</tt> ps);<br/>
<tt>size_t</tt> mbrtoc32(<tt>char32_t</tt> * <tt>restrict</tt> pc32,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>const</tt> <tt>char</tt> * <tt>restrict</tt> s, <tt>size_t</tt> n,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>mbstate_t</tt> * <tt>restrict</tt> ps);<br/>
<tt>size_t</tt> c32rtomb(<tt>char</tt> * <tt>restrict</tt> s, <tt>char32_t</tt> c32,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>mbstate_t</tt> * <tt>restrict</tt> ps);
</div>
</blockquote>
</blockquote>
</p>

<p>Change in J.6.1 (Rule based identifiers) paragraph 2:
<blockquote>
The following
<strong><em style="background-color: yellow">** count **</em></strong>
 identifiers or keywords match these patterns and have
particular semantics provided by this document.<br/>
<br/>
[&hellip;]<br/>
<tt>atomic_char</tt><br/>
<ins><tt>atomic_char8_t</tt></ins><br/>
<ins><tt>ATOMIC_CHAR8_T_LOCK_FREE</tt></ins><br/>
<tt>atomic_char16_t</tt><br/>
<tt>ATOMIC_CHAR16_T_LOCK_FREE</tt><br/>
[&hellip;]<br/>
</blockquote>
</p>

<p>Change in J.6.2 (Particular identifiers or keywords) paragraph 1:
<blockquote>
The following
<strong><em style="background-color: yellow">** count **</em></strong>
identifiers or keywords are not covered by the above and
have particular semantics provided by this document.<br/>
<br/>
[&hellip;]<br/>
<tt>char</tt><br/>
<ins><tt>char8_t</tt></ins><br/>
<tt>char16_t</tt><br/>
<tt>char32_t</tt><br/>
[&hellip;]<br/>
<tt>BUFSIZ</tt><br/>
<ins><tt>c8rtomb</tt></ins><br/>
<tt>c16rtomb</tt><br/>
<tt>c32rtomb</tt><br/>
[&hellip;]<br/>
<tt>mbrlen</tt><br/>
<ins><tt>mbrtoc8</tt></ins><br/>
<tt>mbrtoc16</tt><br/>
<tt>mbrtoc32</tt><br/>
[&hellip;]<br/>
</blockquote>
</p>

<h1 id="acknowledgements">Acknowledgements</h1>

<p>Thank you to Aaron Ballman for his kind assistance facilitating interaction
with WG14.</p>


<h1 id="references">References</h1>

<table id="references">
  <tr>
    <td id="ref_w3techs"><sup>[W3Techs]</sup></td>
    <td>
      "Usage of UTF-8 for websites", W3Techs, 2021.<br/>
      <a href="https://w3techs.com/technologies/details/en-utf8/all/all">
      https://w3techs.com/technologies/details/en-utf8/all/all</a></td>
  </tr>
  <tr>
    <td id="ref_p0482r6"><sup>[P0482R6]</sup></td>
    <td>
      Tom Honermann,
      "char8_t: A type for UTF-8 characters and strings (Revision 6)", P0482R6, 2018.<br/>
      <a href="https://wg21.link/p0482r6">
      https://wg21.link/p0482r6</a></td>
  </tr>
  <tr>
    <td id="ref_wg14_n2596"><sup>[WG14 N2596]</sup></td>
    <td>
      JeanHeyd Meneide, Freek Wiedijk, et al.,
      "C2x Working Draft", N2596, 2020.<br/>
      <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2596.pdf">
      http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2596.pdf</a></td>
  </tr>
</table>

</body>
