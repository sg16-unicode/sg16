<!doctype html public "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">

<head>
<title>SG16: Unicode meeting summaries 2020-12-09 through 2020-12-09</title>
</head>

<style type="text/css">

table#header th,
table#header td
{
    text-align: left;
}

tt {
    font-family: monospace;
}

/* Thanks to Elias Kosunen for the following CSS suggestions! */

* {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
    line-height: 125%;
}

html, body {
    background-color: #eee;
}

h1, h2, h3, h4, h5, p, span, li, dt, dd {
    color: #333;
}

p, li {
    line-height: 140%;
}

body {
    padding: 1em;
    max-width: 1600px;
}

p, li {
    -moz-osx-font-smoothing: grayscale;
    -webkit-font-smoothing: antialiased !important;
    -moz-font-smoothing: antialiased !important;
    text-rendering: optimizelegibility !important;
    letter-spacing: .01em;
}

h1, h2, h3 {
    margin-bottom: 1em;
    letter-spacing: .03em;
}

blockquote.quote
{
    margin-left: 0em;
    border-style: solid;
    background-color: lemonchiffon;
    color: #000000;
    border: 1px solid black;
}

</style>

<body>

<table id="header">
  <tr>
    <th>Document Number:</th>
    <td>DXXXXR0 <em>Draft</em></td>
  </tr>
  <tr>
    <th>Date:</th>
    <td>2020-01-05</td>
  </tr>
  <tr>
    <th>Audience:</th>
    <td>SG16</td>
  </tr>
  <tr>
    <th>Reply-to:</th>
    <td>Tom Honermann &lt;tom@honermann.net&gt;</td>
  </tr>
</table>


<h1>SG16: Unicode meeting summaries 2020-12-09 through 2020-12-09</h1>

<p>
Summaries of SG16 meetings are maintained at
<a href="https://github.com/sg16-unicode/sg16-meetings">
https://github.com/sg16-unicode/sg16-meetings</a>.  This paper contains a
snapshot of select meeting summaries from that repository.
</p>

<ul>
  <li><a href="#2020_12_09">
      December 9th, 2020</a></li>
</ul>

<p>
Previously published SG16 meeting summary papers:
<ul>
  <li><a href="https://wg21.link/p1080">P1080: SG16: Unicode meeting summaries 2018/03/28 - 2018/04/25</a></li>
  <li><a href="https://wg21.link/p1137">P1137: SG16: Unicode meeting summaries 2018/05/16 - 2018/06/20</a></li>
  <li><a href="https://wg21.link/p1237">P1237: SG16: Unicode meeting summaries 2018/07/11 - 2018/10/03</a></li>
  <li><a href="https://wg21.link/p1422">P1422: SG16: Unicode meeting summaries 2018/10/17 - 2019/01/09</a></li>
  <li><a href="https://wg21.link/p1666">P1666: SG16: Unicode meeting summaries 2019/01/23 - 2019/05/22</a></li>
  <li><a href="https://wg21.link/p1896">P1896: SG16: Unicode meeting summaries 2019/06/12 - 2019/09/25</a></li>
  <li><a href="https://wg21.link/p2009">P2009: SG16: Unicode meeting summaries 2019-10-09 through 2019-12-11</a></li>
  <li><a href="https://wg21.link/p2179">P2179: SG16: Unicode meeting summaries 2020-01-08 through 2020-05-27</a></li>
  <li><a href="https://wg21.link/p2217">P2217: SG16: Unicode meeting summaries 2020-06-10 through 2020-08-26</a></li>
  <li><a href="https://wg21.link/p2253">P2253: SG16: Unicode meeting summaries 2020-09-09 through 2020-11-11</a></li>
</ul>
</p>


<h1 id="2020_12_09">December 9th, 2020</h1>

<h2>Draft agenda:</h2>

<ul>
  <li><a href="https://wg21.link/p2093r2">P2093R2: Formatted output</a>:
    <ul>
      <li>Continue discussion.</li>
    </ul>
  </li>
</ul>

<h2>Attendees:</h2>

<ul>
  <li>Hubert Tong</li>
  <li>Jens Maurer</li>
  <li>Peter Brett</li>
  <li>Steve Downey</li>
  <li>Tom Honermann</li>
  <li>Victor Zverovich</li>
  <li>Zach Laine</li>
</ul>

<h2>Meeting summary:</h2>

<ul>
  <li>Tom provided some administrative updates:
    <ul>
      <li>A reminder that SG16 telecons operate under the WG21 code of conduct
          as described in the
          <a href="https://isocpp.org/std/standing-documents/sd-4-wg21-practices-and-procedures#code-of-conduct">"Code of conduct" section of WG21 Standing Document #4</a>
          and, by extension, the
          <a href="https://www.iso.org/publication/PUB100397.html">ISO Code of Conduct</a>
          and
          <a href="https://basecamp.iec.ch/download/iec-code-of-conduct-for-delegates-and-experts">IEC Code of Conduct</a>.</li>
      <li>A reminder that SG16 is a public group and that minutes of SG16
          telecons are made publicly available.  Participants may request that
          sensitive information not be minuted.</li>
      <li>A draft paper calling for the creation of a WG21 managed chat service
          will be submitted for the December 15th mailing.</li>
      <li><em>[ Editor's note: the submitted paper is
          <a href="https://wg21.link/p2263r0">P2263R0: A call for a WG21 managed chat service</a>.
          An administrative telecon will be scheduled in early January to
          discuss it with the intent to have a draft revision addressing any
          feedback prepared for the February pre-meeting administrative telecon.
          ]</em></li>
      <li>The deadline for initial proposals of new features to be included in
          C2x is 2021-08-27.</li>
      <li>The next C2x meeting is scheduled for March 8-12, 2021.</li>
      <li>Tom asked to clarify the next steps following our recent discussion of
          <a href="https://wg21.link/p2194r0">P2194R0</a>
          and asked who is planning to write the paper to re-word translation
          phase 1 in terms of Unicode scalar values rather than basic source
          characters and universal-character-names (UCNs).</li>
      <li>Jens stated he will write that paper, but noted some complications:
        <ul>
          <li>Not all string literals should be transcoded into the execution
              encoding because literals that appear in contexts such as
              <tt>static_assert</tt> and language linkage are evaluated at
              compile-time and have different encoding implications.</li>
          <li>The issue of translation phase 5/6 confusion regarding string
              literal concatenation and conversion to the execution encoding
              remains.</li>
          <li>It may become necessary to move string literal conversions and
              concatenation to translation phase 7.</li>
          <li>Care will be required to ensure concatenation of string literals
              does not result in construction or extension of escape
              sequences.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="https://wg21.link/p2093r2">P2093R2: Formatted output</a>:
    <ul>
      <li>PBrett provided an introduction:
        <ul>
          <li>It has been a month since we last reviewed.</li>
          <li>There has been some good discussion on the mailing list.</li>
          <li>Victor will continue his presentation.</li>
        </ul>
      </li>
      <li>Victor presented:
        <ul>
          <li>The intent of the proposal is to integrate formatting facilities
              with output streams.</li>
          <li>A survey of current Java, Python 3, and Rust releases was
              conducted to ascertain their behavior on a Russian Windows system
              (Active Code Page (ACP) set to Windows-1251; console encoding set
              to CP866) when a string containing Russion and Greek characters is
              written to stdout with stdout directed to a console and again with
              stdout redirected to a file.</li>
            <ul>
              <li>For Java, <tt>java.lang.System.out</tt> was used.</li>
              <li>For Python, <tt>print</tt> was used.</li>
              <li>for Rust, <tt>std::print</tt> was used. </li>
              <li>For each language, redirection of stdout to a file was done
                  using the <tt>cmd.exe</tt> shell.</li>
            </ul>
          </li>
          <li>Java failed to display the correct characters to the Windows
              console; UTF-8 output was produced when stdout was redirected to
              a file.</li>
          <li><em>[ Editor's note: See further discussion below regarding the
              Java behavior. ]</em></li>
          <li>Python threw an exception when trying to convert the Greek
              characters to Windows-1251.</li>
          <li>Rust displayed the correct characters to the console and UTF-8
              output was produced when stdout was redirected to a file.</li>
        </ul>
      </li>
      <li>PBrett noted a difference from C++ that each of these languages
          shares; they each always use a UTF encoding for strings.</li>
      <li>PBrett added that both Python and Rust appear to behave in an
          arguably correct manner.</li>
      <li>PBrett stated that he has many tools that operate in ISO-8859
          encodings and where generation of UTF-8 output would not produce
          the expected behavior.</li>
      <li>PBrett noted that this is a new facility, so it could behave
          differently.</li>
      <li>Tom expressed surprise that the Java test produced UTF-8 when stdout
          was directed to a file as that does not match his understanding of
          Java's behavior.</li>
      <li>Steve noted that such surprising behavior can be the result of
          mismatched encoding expectations and asked if the source file
          encoding was correct.</li>
      <li>Steve added that this is an easy thing to get wrong.</li>
      <li>Victor replied that all source files were UTF-8 encoded.</li>
      <li>Tom stated that the Java compiler uses the locale to determine souce
          file encoding unless invoked with the <tt>-encoding</tt> option;
          similar to how Microsoft Visual C++ behaves.</li>
      <li>Zach asked if source file encoding could influence the encoding used
          for file redirection.</li>
      <li>Victor replied that he would conduct additional tests.</li>
      <li><em>[ Editor's note: later tests revealed that the reported behavior
          for Java was incorrect.  The Java compiler had been invoked without a
          <tt>-encoding</tt> option, so the UTF-8 encoded source file was
          misinterpreted as being Windows-1251 encoded and the compiler
          converted string literals from Windows-1251 to UTF-16.  When the
          strings were then written via <tt>java.lang.System.out</tt>, the
          prior conversion was reversed when <tt>java.io.PrintStream</tt>
          converted the string to print from UTF-16 back to Windows-1251.  The
          result was that the original bytes from the source file encoding of
          the string literal were written to stdout.  This produced mojibake on
          the Windows console and gave the appearance that the program had
          (intentionally) generated UTF-8 in the file redirection scenario.
          Note that all valid UTF-8 code unit sequences are also valid
          Windows-1251 code unit sequences. ]</em></li>
      <li>Tom asked Victor if he could extend his testing to cover cases where
          stdout was redirected to a pipe that was connected to stdin of
          another process.</li>
      <li>Victor replied that he would look into that.</li>
      <li>PBrett recalled that, in prior discussion, we had started discussing
          the association of the execution encoding and run-time encoding and
          how that influences behavior.</li>
      <li>Victor summarized the proposed behavior and some of the prior
          discussion:
        <ul>
          <li>Decisions are based solely on execution encoding (known at
              compile time).</li>
          <li>Use of locale settings would be challenging due to the
              involvement of multiple encodings.</li>
          <li>The encoding of the format string must be consistent.</li>
          <li>Tom had raised the question of a z/OS implementation using UTF-8
              as the execution encoding, but operating in an EBCDIC
              environment.</li>
        </ul>
      </li>
      <li>PBrett observed that use of Microsoft's <tt>/utf-8</tt> option would
          cause UTF-8 output to be generated and asked about what should happen
          when that option isn't used.</li>
      <li>Victor replied that the behavior depends on the system configuration
          and that the proposal specifies that bytes be passed through
          unmodified in that case.</li>
      <li>Steve relayed experience with tools that end up writing ANSI terminal
          escape sequences into a file when output is redirected and noted the
          difficulty that would be encountered when attempting to determine what
          kind of device receives the final output; examples may involve
          multiple ssh hops.</li>
      <li>Tom opined that the only case he is aware of where writing directly to
          the device instead of to the file stream makes sense is on Windows
          where it can be known definitively that the file stream is attached to
          a console.</li>
      <li>Hubert explained that, on z/OS, an application can internally be in
          ASCII or EBCDIC mode, open file handles can be imbued with the
          property of being ASCII or EBCDIC, and the C-level I/O APIs can
          automatically translate between them for, at least, single-byte
          encodings.</li>
      <li>Jens commented that the proposed feature appears to be centered around
          a special facility for Windows and expressed uncertain skepticism
          regarding driving a design around it.</li>
      <li>Jens added that, in the z/OS scenario as Hubert described it, there
          appears to be uncertainty that the facility would handle variable
          length encodings adequately.</li>
      <li>Jens stated that, given the wide array of platforms supported by the
          C++ standard, that he would prefer to craft a design around an
          abstract console stream.</li>
      <li>PBrett expressed concern that this facility might not be used much on
          Windows because use of Microsoft's <tt>/utf-8</tt> option is not
          common.</li>
      <li>Victor disagreed with the notion that the design is centered around
          Windows and a particular corner case; the goal is to fix the general
          problem of producing correct output.</li>
      <li>Victor stated that, with respect to use of the <tt>/utf-8</tt> option,
          that he is open to the changes Tom suggested to transcode as necessary
          and write directly to the console when output is directed there
          regardless of what the execution encoding is.</li>
      <li>Tom agreed with Victor that the concerns are more fundamental and not
          a special case; the goal is to improve support for an internal
          encoding distinct from the external encoding.</li>
      <li>Tom asked about coexistence with other formatting facilities and what
          concerns arise due to potentially divergent behavior; programs won't
          be rewritten over night to migrate all <tt>printf()</tt> uses to
          <tt>std::print()</tt>.</li>
      <li>Zach asked what the tradeoffs in design options are, what gets broken
          based on design choices, and how much of this can be left
          implementation-defined.</li>
      <li>Zach expressed support for the approach described in the paper.</li>
      <li>Hubert stated that encompasing the console in a separate facility
          would pose challenges because it assumes the presence of a unique
          "console" in the environment.</li>
      <li>Hubert added that an important concern is encoding of string literals
          vs encoding of strings received from the environment.  For example,
          regex libraries tend to use a possibly pre-compiled pattern encoded
          in the execution encoding, but operate on strings provided by the
          environment; it is necessary to differentiate these.</li>
      <li>PBrett agreed with Hubert's concerns.</li>
      <li>Steve stated that the proposed feature is at least partly QoI and
          that, if we can specify this with sufficient latitude for Microsoft
          to make their customers happy, great; the Windows console
          capabilities are not portable.</li>
      <li>Steve added that locale information is input to the program and used
          to interpret bytes received as input.</li>
      <li>Steve raised the concern that the proposed approach may enclose
          transcoding behavior too deeply where it can't be fixed if there is a
          problem.</li>
      <li>Tom agreed with Steve's concern and noted parallels with Jens'
          previous request to separate transcoding features.</li>
      <li>PBrett asked how encoding errors should be handled.</li>
      <li>Victor replied that the current implementation throws an exception,
          but that there has been a recommendation to use U+FFFD character
          substitution instead.</li>
      <li>Zach noted that use of subtitution characters matches Unicode
          recommendations.</li>
      <li>Victor noted that, when writing to the console, substitution is safe
          since it is known that the output would be incorrect anyway.</li>
      <li>PBrett acknowledged that perception; the text gets converted to
          photons.</li>
      <li>Victor added that the Console font is typically limited in what can be
          displayed as well.</li>
      <li>PBrett asked if there were any objections to use of substitution
          characters in error handling scenarios.</li>
      <li>No objections were raised.</li>
      <li>Jens stated that the proposed feature is effectively a large hammer
          being aimed at more nails than is really desired.  For example, in
          safety critical scenarios, a programmer may need to be notified of
          errors; displaying a Unicode replacement character to an aircraft
          pilot is less than helpful.</li>
      <li>Jens reflected that, on the other hand, perhaps this is a tool
          intended for common users where such substitutions are not an
          issue.</li>
      <li>Jens expressed support for transcoding operations being explicit at
          program boundaries and noted that there are a number of encodings
          involved; execution encoding, locale dependent input, locale
          dependent output (potentially multiple; e.g., Windows ACP and
          console encoding).</li>
      <li>Jens opined that we should promote a programming model that puts more
          control in the hands of the programmer.</li>
      <li>Victor replied that <tt>std::format()</tt> doesn't do any transcoding
          at present; that the encodings must match and that programmers must
          get data into the right encoding first.</li>
      <li>Hubert noted the law of unintended consequences; that trying to ensure
          a behavior in one case can result in undesired behavior in
          another.</li>
      <li>Steve agreed and noted that use of <tt>isatty()</tt> tends to be
          problematic as it can be surprising when behavior changes based on
          redirection.</li>
      <li>PBrett asked Tom what polls should be conducted.</li>
      <li>Tom responded that he did not think discussion had progressed to a
          point where we all hold well-informed positions.</li>
      <li>Tom stated that the additional work Victor has agreed to do should
          help strengthen our understanding and positions; we should therefore
          wait for this additional information before conducting any
          polling.</li>
    </ul>
  </li>
  <li>Tom stated that the next meeting will be on January 13th and the agenda
      will include:
    <ul>
      <li><a href="https://wg21.link/p2246r0">P2246R0: Character encoding of diagnostic text</a></li>
      <li>SG16, SG22, and WG14 coordination; we'll discuss how to make forward
          progress on
          <a href="https://github.com/sg16-unicode/sg16/issues?q=is%3Aissue+is%3Aopen+label%3Awg14">SG16 issues labeled with the WG14 tag</a>.</li>
      <li><a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2620.htm">WG14 N2620: Restartable and Non-Restartable Functions for Efficient Character Conversions | r4</a></li>
    </ul>
  </li>
</ul>


</body>
