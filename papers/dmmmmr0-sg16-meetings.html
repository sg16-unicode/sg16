<!doctype html public "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">

<head>
<title>SG16: Unicode meeting summaries 2022-01-12 through 2022-01-12</title>
</head>

<style type="text/css">

table#header th,
table#header td
{
    text-align: left;
}

tt {
    font-family: monospace;
}

/* Thanks to Elias Kosunen for the following CSS suggestions! */

* {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
    line-height: 125%;
}

html, body {
    background-color: #eee;
}

h1, h2, h3, h4, h5, p, span, li, dt, dd {
    color: #333;
}

p, li {
    line-height: 140%;
}

body {
    padding: 1em;
    max-width: 1600px;
}

p, li {
    -moz-osx-font-smoothing: grayscale;
    -webkit-font-smoothing: antialiased !important;
    -moz-font-smoothing: antialiased !important;
    text-rendering: optimizelegibility !important;
    letter-spacing: .01em;
}

h1, h2, h3 {
    margin-bottom: 1em;
    letter-spacing: .03em;
}

blockquote.quote
{
    margin-left: 0em;
    border-style: solid;
    background-color: lemonchiffon;
    color: #000000;
    border: 1px solid black;
}

</style>

<body>

<table id="header">
  <tr>
    <th>Document Number:</th>
    <td>DXXXXR0 <em>Draft</em></td>
  </tr>
  <tr>
    <th>Date:</th>
    <td>2022-01-24</td>
  </tr>
  <tr>
    <th>Audience:</th>
    <td>SG16</td>
  </tr>
  <tr>
    <th>Reply-to:</th>
    <td>Tom Honermann &lt;tom@honermann.net&gt;</td>
  </tr>
</table>


<h1>SG16: Unicode meeting summaries 2022-01-12 through 2022-01-12</h1>

<p>
Summaries of SG16 meetings are maintained at
<a href="https://github.com/sg16-unicode/sg16-meetings">
https://github.com/sg16-unicode/sg16-meetings</a>.  This paper contains a
snapshot of select meeting summaries from that repository.
</p>

<ul>
  <li><a href="#2022_01_12">
      January 12th, 2022</a></li>
</ul>

<p>
Previously published SG16 meeting summary papers:
<ul>
  <li><a href="https://wg21.link/p1080">P1080: SG16: Unicode meeting summaries 2018/03/28 - 2018/04/25</a></li>
  <li><a href="https://wg21.link/p1137">P1137: SG16: Unicode meeting summaries 2018/05/16 - 2018/06/20</a></li>
  <li><a href="https://wg21.link/p1237">P1237: SG16: Unicode meeting summaries 2018/07/11 - 2018/10/03</a></li>
  <li><a href="https://wg21.link/p1422">P1422: SG16: Unicode meeting summaries 2018/10/17 - 2019/01/09</a></li>
  <li><a href="https://wg21.link/p1666">P1666: SG16: Unicode meeting summaries 2019/01/23 - 2019/05/22</a></li>
  <li><a href="https://wg21.link/p1896">P1896: SG16: Unicode meeting summaries 2019/06/12 - 2019/09/25</a></li>
  <li><a href="https://wg21.link/p2009">P2009: SG16: Unicode meeting summaries 2019-10-09 through 2019-12-11</a></li>
  <li><a href="https://wg21.link/p2179">P2179: SG16: Unicode meeting summaries 2020-01-08 through 2020-05-27</a></li>
  <li><a href="https://wg21.link/p2217">P2217: SG16: Unicode meeting summaries 2020-06-10 through 2020-08-26</a></li>
  <li><a href="https://wg21.link/p2253">P2253: SG16: Unicode meeting summaries 2020-09-09 through 2020-11-11</a></li>
  <li><a href="https://wg21.link/p2352">P2352: SG16: Unicode meeting summaries 2020-12-09 through 2021-03-24</a></li>
  <li><a href="https://wg21.link/p2397">P2397: SG16: Unicode meeting summaries 2021-04-14 through 2021-05-26</a></li>
  <li><a href="https://wg21.link/p2512">P2512: SG16: Unicode meeting summaries 2021-06-09 through 2021-12-15</a></li>
</ul>
</p>


<h1 id="2022_01_12">January 12th, 2022</h1>

<h2>Draft agenda:</h2>

<ul>
  <li><a href="https://wg21.link/p2491r0">P2491R0: Text encodings follow-up</a>
    <ul>
      <li>Initial review.</li>
    </ul>
  </li>
  <li><a href="https://wg21.link/p2498r0">P2498R0: Forward compatibility of text_encoding with additional encoding registries</a>
    <ul>
      <li>Initial review.</li>
    </ul>
  </li>
</ul>

<h2>Attendees:</h2>

<ul>
  <li>Hubert Tong</li>
  <li>Jens Maurer</li>
  <li>Peter Brett</li>
  <li>Steve Downey</li>
  <li>Tom Honermann</li>
  <li>Victor Zverovich</li>
</ul>

<h2>Meeting summary:</h2>

<ul>
  <li><em>[ Editor's note: We did not have quorum due to low attendance;
      as a result, no polls were taken. ]</em></li>
  <li><em>[ Editor's note: Changes made in a draft of
      <a href="https://wg21.link/p1885r9">P1885R9</a>
      were material to review of the papers on the agenda, so we first
      reviewed it. ]</em></li>
  <li><a href="https://wg21.link/p1885r9">P1885R9: Naming Text Encodings to Demystify Them</a>
    <ul>
      <li>Jens stated that there is a procedural question related to the
          changes made in this revision; the new draft changes the design
          after electronic polling.</li>
      <li>Tom replied that the changes were at least partially inspired by
          comments received on the proposal by electronic polling participants
          and were intended to increase consensus.</li>
      <li>PBrett noted that the polled revision did not have the wording to
          mandate <tt>CHAR_BIT == 8</tt> due to a procedural error and asked
          whether that warranted follow up with LEWG.</li>
      <li>PBrett asked what it means in practice for the wording to mandate
          <tt>CHAR_BIT == 8</tt>.</li>
      <li>Jens replied that it requires a call to a function specified with
          that wording to be ill-formed if the requirement is violated.</li>
      <li>Jens explained that implementors can conform with this requirement
          by defining such functions as deleted, implementing them as a
          function template with an appropriate <tt>static_assert</tt>, or
          similar.</li>
      <li>PBrett asked for more details regarding implementation as a function
          template and whether the functions could simply not be declared
          at all.</li>
      <li>Tom replied that a function template is ok because taking the address
          of a standard library function is not allowed; the standard just
          requires a call expression to be well-formed.</li>
      <li>Hubert explained that the name must be declared due to interaction
          with name lookup.</li>
      <li>Jens stated an implementation preference to define the function as
          deleted.</li>
      <li>PBrett: noticed that the revision history simply stated
          "Wording fixes" with no details.</li>
      <li>Tom volunteered to review the R8 and R9 revisions and to summarize
          the differences in the meeting summary.</li>
      <li><em>[ Editor's note: Tom did so; the wording differences identified include:
        <ul>
          <li>An additional <tt>using enum id</tt> declaration was added to
              the definition of <tt>text_encoding</tt>.</li>
          <li>The <tt>wide_literal()</tt>, <tt>wide_environment()</tt>, and
              <tt>wide_environment_is()</tt> declarations were removed and
              wording that referred to them adjusted accordingly.</li>
          <li>"character encoding" was changed to "character encoding scheme"
              in the paragraph following the note regarding how the names of
              <tt>text_encoding::id</tt> enumerators were derived from the
              IANA registry.</li>
          <li>A paragraph describing invariants maintained by
              <tt>text_encoding</tt> was added.</li>
          <li>Wording that introduced and used
              <tt>SUBSTITUTE_UTF_ENCODING()</tt> for mapping the bigendian and
              littleendian UTF-16 and UTF-32 schemes to their respective
              encoding forms was removed; related wording was adjusted
              accordingly.</li>
          <li>Wording to mandate <tt>CHAR_BIT == 8</tt> was added
              throughout.</li>
        </ul>
      ]</em>
      </li>
    </ul>
  </li>
  <li><a href="https://wg21.link/p2491r0">P2491R0: Text encodings follow-up</a>
    <ul>
      <li>Jens summarized the paper.</li>
      <li>Jens stated that the changes in P1885R9 improve consistency with the
          IANA intent and P1885 usage.</li>
      <li>Jens added that there is opportunity for specification improvements,
          but that they can be addressed during LWG review.</li>
      <li>Tom noted that the wording plan described in the paper indicated
          intent to remove the requirement that <tt>CHAR_BIT == 8</tt>.</li>
      <li>Jens confirmed, but expressed a lack of concern; that restriction can
          be removed if motivation to do so arises.</li>
      <li>PBrett expressed a preference for explicit specification for how IANA
          octets are mapped to C++ code units.</li>
      <li>Jens agreed, stated that can be done during LWG review, and expressed
          a preference for a normative sentence that maps an IANA octet to a
          <tt>char</tt> code unit.</li>
      <li>Jens expressed a belief that relying on IANA for anything other than
          octets would be a mistake.</li>
      <li>PBrett asked if Jens had an alternative to suggest.</li>
      <li>Jens replied that he did not, but that such concerns usually arose
          during discussion of UTF-16 and UTF-32.</li>
      <li>Hubert stated that mapping to IANA in those cases is feasible, but
          noted that there are multiple possible mappings that may be platform
          dependent; particularly when the size of <tt>char</tt> is not 8
          bits.</li>
      <li>PBrett agreed, but noted that a particular mapping could be required
          for a conforming implementation.</li>
      <li>Tom added that a non-conforming implementation would map to "other"
          in that case.</li>
    </ul>
  </li>
  <li><a href="https://wg21.link/p2498r0">P2498R0: Forward compatibility of text_encoding with additional encoding registries</a>
    <ul>
      <li>PBrett introduced the proposal:
        <ul>
          <li>Character encoding repositories other than IANA exist.</li>
          <li>The mapping to IANA should be explicit such that a mapping to
              another registry could be gracefully introduced in the future if
              motivation arises.</li>
        </ul>
      </li>
      <li>PBrett summarized the proposed changes:
        <ul>
          <li>Rename "id" to "iana_id"</li>
          <li>Rename "mib" to "iana_mib"</li>
          <li>Add recommended practice to avoid implementations creating an
              over dependence on IANA.</li>
        </ul>
      </li>
      <li>PBrett asked for opinions on the proposed renames.</li>
      <li>Victor asked if other viable candidate registries exist in practice
          and stated that, if not, the proposed renames seem premature.</li>
      <li>PBrett replied that there are NB concerns about IANA being an
          unregulated, unaccountable, and unreliable organization.</li>
      <li>PBrett added that examples of other registries can be found in the
          <a href="https://encoding.spec.whatwg.org">WhatWG Encoding Standard</a>,
          IBM's <a href="https://www.ibm.com/downloads/cas/G01BQVRV">Character Data Representation Architecture (CDRA)</a>,
          and <a href="https://www.iso.org/standard/22747.html">ISO/IEC 2022:1994</a>.</li>
      <li>PBrett noted that the paper does not propose the addition of another
          registry; just the possibility to add more in the future in a
          seamless manner.</li>
      <li>Jens suggested adding examples of other registries to the paper.</li>
      <li>PBrett responded with concern that doing so might create disruption
          for the advancement of P1885 and result in considerable time spent
          debating whether the merits of each such repository warrant their
          being mentioned.</li>
      <li>Steve asked for confirmation that, assuming an additional registry,
          that a single text encoding ID is still needed.</li>
      <li>PBrett responded that the IANA ID is an enum class and that, in
          principle, multiple such classes are possible.</li>
      <li>Steve stated that renaming <tt>mib()</tt> to <tt>iana_mib()</tt>
          results in the feature no longer being generic.</li>
      <li>Jens agreed.</li>
      <li>PBrett responded that code written for P1885 today that consults
          <tt>mib()</tt> is necessarily concerned with IANA specifically.</li>
      <li>Steve asked what function a generic library should call then.</li>
      <li>Jens replied that, if the IANA ID is desired, then call
          <tt>mib()</tt>.</li>
      <li>Tom noted that, since multiple encodings may map to IANA's "other",
          reliance on <tt>mib()</tt> to uniquely identify an encoding is not
          possible.</li>
      <li>Hubert opined that the proposed renames are fine, but that
          extension to other registries might require different
          terminology.</li>
      <li>Jens offered examples such as "unique ID" and "UUID".</li>
      <li>Jens opined that it doesn't hurt to add "iana" to make the
          terminology association explicit.</li>
      <li>Hubert agreed.</li>
      <li>Hubert stated that, for wide encodings, there are some registries
          that are somewhat suitable; in CDRA, wide encodings aren't explicitly
          represented as they constitute a composition of a character set and
          an encoding.</li>
      <li>PBrett acknowledged and noted that the proposal is intended to clear
          design space for extension for such cases.</li>
      <li>Tom provided some arguments in favor of support for multiple
          registries:
        <ul>
          <li>As previously noted, the IANA specification is goverened by an
              organization that some have concerns about.</li>
          <li>The IANA registry is poor from a quality of specification
              perspective.</li>
          <li>The IANA registry is missing entries that are found in other
              registries.</li>
          <li>The same name is sometimes used by different registries to refer
              to differenc encodings.</li>
          <li>Other registries are arguably more suitable for some environments;
              e.g., CDRA for IBM environments.</li>
        </ul>
      </li>
      <li>Tom suggested that the proposal replace the P1885 proposed exposition
          only data members with post conditions on the default constructor to
          require <tt>iana_mib()</tt> and <tt>name()</tt> to return
          <tt>id::other</tt> and an empty string respectively; this is to avoid
          encouraging implementations to simply store an IANA ID.</li>
      <li>PBrett noted that much of the current wording is in terms of the
          <tt>mib_</tt> exposition only data member.</li>
      <li>Tom replied that those can be changed to <tt>mib()</tt>.</li>
      <li>Jens pointed out that the following text from the proposed wording
          creates the impression that the specified feature provides a remote
          API interface.
        <ul>
          <li>"[text.encoding] describes an interface for accessing the IANA
              Character Sets registry".</li>
        </ul>
      </li>
      <li>Jens stated that <tt>text_encoding</tt> currently containes a list of
          all encodings in the IANA registry and that this proposal makes the
          <tt>text_encoding</tt> class more of a first class entity for which
          mapping to other registries is ancillary functionality.</li>
      <li>Jens opined that this direction suggests the need to create our own
          encoding registry since the functionality effectively defines
          one.</li>
      <li>Jens stated that such a change constitutes a change in direction that
          is more significant than the proposed renames suggest.</li>
      <li>PBrett acknowledged that the proposal makes the design more abstract
          in a manner similar to how Unicode specifies abstract characters.</li>
      <li>PBrett added that he could imagine a C++ appendix that lists the
          encodings, but that would then necessitate defining them.</li>
      <li>Jens stated that a registration service could be established, but did
          not advise doing so.</li>
      <li>Jens observed that discussion has not yet reached the bottom of how
          encodings would be mapped between encodings registered with different
          registries.</li>
      <li>Jens suggested the possibility of defining an
          <tt>iana_text_encoding</tt> class and later adding an
          <tt>iso_text_encoding</tt> class or similar for other registries if
          warranted.</li>
      <li>Hubert observed that the P1885 design contains the same mapping
          problem since it presents a single domain, but doesn't adhere solely
          to that domain.</li>
      <li>Hubert suggested the possibility of a <tt>text_encoding</tt> class
          template parameterized by a registry identifier.</li>
      <li>Tom noted that, if one were to map the encodings present in the
          <a href="https://icu4c-demos.unicode.org/icu-bin/convexp">ICU converter explorer</a>,
          then parameterization by registry is necessary due to conflicting
          use of the same name for different encodings.</li>
      <li><em>[ Editor's note: For example, "korean" maps to "windows-949-2000"
          via the "Windows" provider, but to "ibm-1363_P11B-1998" via the "IANA"
          provider. ]</em></li>
      <li>PBrett reiterated the intent of this proposal; to remove complete
          dependency on IANA.</li>
      <li>Tom stated that the proposed change is consistent with the P1885
          direction given that comparison is dependent on name when an encoding
          maps to IANA's "other".</li>
      <li>Tom opined that there is no need to specify a mapping between
          repositories in the standard; the mapping can be
          implementation-defined.</li>
      <li>Jens agreed that leaving the mapping implementation-defined is
          possible but felt an obligation to specify the mapping.</li>
      <li>Hubert noted that, for implementors, the concern is what is in the
          interest of their users.</li>
      <li>PBrett expressed a belief that creation of a character encoding
          registry service would be outside the scope of WG21 work, but that he
          would be willing to assist with such an effort outside of WG21.</li>
      <li>Jens agreed and noted that such a service would essentially be
          attending to graves.</li>
      <li>Hubert suggested that <tt>text_encoding</tt> may be more appropriate
          as a concept.</li>
      <li>Tom stated that distinct classes or class template specializations
          for each registry would create friction at interface boundaries.</li>
      <li>Hubert responded that a type erased interface could still be
          specified.</li>
      <li>PBrett expressed being open to other suggestions.</li>
      <li>Jens suggested renaming the current <tt>text_encoding</tt> class to
          <tt>iana_text_encoding</tt> and, if motivation arises for another
          registry, then a new class can be added.</li>
      <li>General discussion ensued regarding the ramification of distinct
          classes.</li>
      <li>Tom pondered what name would be returned by <tt>name()</tt> if
          multiple registries are supported.</li>
      <li>PBrett responded that his proposal intended to avoid that
          question.</li>
    </ul>
  </li>
  <li>Tom stated that the next telecon will be held on 2022-01-26 and that the
      agenda will include:
    <ul>
      <li><a href="https://wg21.link/p2286r5">P2286R5 (formatting ranges)</a>,</li>
      <li>the LWG issues concerning <tt>std::format</tt> fill characters,
          and/or</li>
      <li>a new revision of
          <a href="https://wg21.link/p2498">P2498 (Forward compatibility of text_encoding with additional encoding registries)</a>.</li>
    </ul>
  </li>
</ul>


</body>
