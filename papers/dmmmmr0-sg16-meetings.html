<!doctype html public "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">

<head>
<title>SG16: Unicode meeting summaries 2023-05-24 through 2023-06-07</title>
</head>

<style type="text/css">

table#header th,
table#header td
{
    text-align: left;
}

tt {
    font-family: monospace;
}

/* Thanks to Elias Kosunen for the following CSS suggestions! */

* {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
    line-height: 125%;
}

html, body {
    background-color: #eee;
}

h1, h2, h3, h4, h5, p, span, li, dt, dd {
    color: #333;
}

p, li {
    line-height: 140%;
}

body {
    padding: 1em;
    max-width: 1600px;
}

p, li {
    -moz-osx-font-smoothing: grayscale;
    -webkit-font-smoothing: antialiased !important;
    -moz-font-smoothing: antialiased !important;
    text-rendering: optimizelegibility !important;
    letter-spacing: .01em;
}

h1, h2, h3 {
    margin-bottom: 1em;
    letter-spacing: .03em;
}

blockquote.quote
{
    margin-left: 0em;
    border-style: solid;
    background-color: lemonchiffon;
    color: #000000;
    border: 1px solid black;
}

</style>

<body style="max-width: 8.5in">

<table id="header">
  <tr>
    <th>Document Number:</th>
    <td>DXXXXR0 <em>Draft</em></td>
  </tr>
  <tr>
    <th>Date:</th>
    <td>2023-09-06</td>
  </tr>
  <tr>
    <th>Audience:</th>
    <td>SG16</td>
  </tr>
  <tr>
    <th>Reply-to:</th>
    <td>Tom Honermann &lt;tom@honermann.net&gt;</td>
  </tr>
</table>


<h1>SG16: Unicode meeting summaries 2023-05-24 through 2023-06-07</h1>

<p>
Summaries of SG16 meetings are maintained at
<a href="https://github.com/sg16-unicode/sg16-meetings">
https://github.com/sg16-unicode/sg16-meetings</a>.  This paper contains a
snapshot of select meeting summaries from that repository.
</p>

<ul>
  <li><a href="#2023_05_24">
      May 24th, 2023</a></li>
  <li><a href="#2023_06_07">
      June 7th, 2023</a></li>
</ul>

<p>
Previously published SG16 meeting summary papers:
<ul>
  <li><a href="https://wg21.link/p1080">P1080: SG16: Unicode meeting summaries 2018/03/28 - 2018/04/25</a></li>
  <li><a href="https://wg21.link/p1137">P1137: SG16: Unicode meeting summaries 2018/05/16 - 2018/06/20</a></li>
  <li><a href="https://wg21.link/p1237">P1237: SG16: Unicode meeting summaries 2018/07/11 - 2018/10/03</a></li>
  <li><a href="https://wg21.link/p1422">P1422: SG16: Unicode meeting summaries 2018/10/17 - 2019/01/09</a></li>
  <li><a href="https://wg21.link/p1666">P1666: SG16: Unicode meeting summaries 2019/01/23 - 2019/05/22</a></li>
  <li><a href="https://wg21.link/p1896">P1896: SG16: Unicode meeting summaries 2019/06/12 - 2019/09/25</a></li>
  <li><a href="https://wg21.link/p2009">P2009: SG16: Unicode meeting summaries 2019-10-09 through 2019-12-11</a></li>
  <li><a href="https://wg21.link/p2179">P2179: SG16: Unicode meeting summaries 2020-01-08 through 2020-05-27</a></li>
  <li><a href="https://wg21.link/p2217">P2217: SG16: Unicode meeting summaries 2020-06-10 through 2020-08-26</a></li>
  <li><a href="https://wg21.link/p2253">P2253: SG16: Unicode meeting summaries 2020-09-09 through 2020-11-11</a></li>
  <li><a href="https://wg21.link/p2352">P2352: SG16: Unicode meeting summaries 2020-12-09 through 2021-03-24</a></li>
  <li><a href="https://wg21.link/p2397">P2397: SG16: Unicode meeting summaries 2021-04-14 through 2021-05-26</a></li>
  <li><a href="https://wg21.link/p2512">P2512: SG16: Unicode meeting summaries 2021-06-09 through 2021-12-15</a></li>
  <li><a href="https://wg21.link/p2605">P2605: SG16: Unicode meeting summaries 2022-01-12 through 2022-06-08</a></li>
  <li><a href="https://wg21.link/p2678">P2678: SG16: Unicode meeting summaries 2022-06-22 through 2022-09-28</a></li>
  <li><a href="https://wg21.link/p2766">P2766: SG16: Unicode meeting summaries 2022-10-12 through 2022-12-14</a></li>
  <li><a href="https://wg21.link/p2891">P2891: SG16: Unicode meeting summaries 2023-01-11 through 2023-05-10</a></li>
</ul>
</p>


<h1 id="2023_05_24">May 24th, 2023</h1>

<h2>Draft agenda:</h2>

<ul>
  <li><a href="https://wg21.link/p2779r0">P2779R0: Make basic_string_view’s range construction conditionally explicit</a>.</li>
  <li><a href="https://wg21.link/p2863r0">P2863R0: Review Annex D for C++26</a>.</li>
  <li><a href="https://wg21.link/p2871r0">P2871R0: Remove Deprecated Unicode Conversion Facets From C++26</a>.</li>
  <li><a href="https://wg21.link/p2873r0">P2873R0: Remove Deprecated Locale Category Facets For Unicode from C++26</a>.</li>
  <li><a href="https://wg21.link/p2872r0">P2872R0: Remove wstring_convert From C++26</a>.</li>
</ul>

<h2>Attendees:</h2>

<ul>
  <li>Alisdair Meredith</li>
  <li>Charlie Barto</li>
  <li>Corentin Jabot</li>
  <li>Eddie Nolan</li>
  <li>Fraser Gordon</li>
  <li>Giuseppe D'Angelo</li>
  <li>Jens Maurer</li>
  <li>Mark de Wever</li>
  <li>Mark Zeren</li>
  <li>Peter Bindels</li>
  <li>Peter Brett</li>
  <li>Robin Leroy</li>
  <li>Tom Honermann</li>
  <li>Victor Zverovich</li>
  <li>Zach Laine</li>
</ul>

<h2>Meeting summary:</h2>

<ul>
  <li><a href="https://wg21.link/p2779r0">P2779R0: Make basic_string_view’s range construction conditionally explicit</a>:
    <ul>
      <li>Giuseppe presented an overview of the paper including relevant
          history:
        <ul>
          <li><a href="https://wg21.link/p1989">P1989R2 (Range constructor for std::string_view 2: Constrain Harder)</a>
              added an implicit <tt>std::string_view</tt> constructor that
              enables implicit conversion from any type that satisfies a set of
              constraints, one of which includes having a member type alias
              named <tt>traits_type</tt> that matches the
              <tt>std::string_view</tt> member of the same name.</li>
          <li><a href="https://wg21.link/p2499">P2499R0 (string_view range constructor should be explicit)</a>
              changed the new constructor to be declared <tt>explicit</tt> due
              to concerns involving ranges that do or do not contain an
              embedded null character; this broke the ability for string types
              to implicitly convert to <tt>std::string_view</tt>.</li>
          <li><a href="https://wg21.link/lwg3857">LWG 3857</a>
              removed the constraint requiring a matching <tt>traits_type</tt>
              member type alias based on the rationale that such a safety
              precaution is no longer necessary since conversions are now
              explicit.</li>
          <li>The proposed paper seeks to conditionally restore implicit
              conversions for string-like types without requiring modifications
              to those types to add conversion operators.</li>
          <li>Two options are proposed:
            <ul>
              <li>Option 1 adds an opt-in trait and makes the constructor
                  conditionally explicit based on the presence of a matching
                  member <tt>traits_type</tt> type alias.</li>
              <li>Option 2 makes the constructor conditionally explicit based on
                  the presence of a matching member <tt>traits_type</tt> type
                  alias without requiring an opt-in trait.</li>
            </ul>
          </li>
          <li>Qt has provided a <tt>QStringView</tt> class with an
              <a href="https://doc.qt.io/qt-6/qstringview.html#QStringView-7">implicit constructor that accepts a range</a>
              that has worked well in practice for a decade.</li>
        </ul>
      </li>
      <li>PBrett asked what the essential nature of a string-like type is.</li>
      <li>Giuseppe responded that it is a contiguous sequence of characters
          and associated character classification traits.</li>
      <li>PBrett argued for substitution of "code units" for "characters".</li>
      <li>Zach noted that the <tt>traits_type</tt> name might be used by types
          that are not string-like types, stated that he does not typically add
          a <tt>traits_type</tt> to his own string-like types, and asked what is
          commonly done in practice.</li>
      <li>Giuseppe responded that the paper lists the results of a survey of
          various projects for occurrences of the <tt>traits_type</tt> name and
          found that it is strongly correlated with string-like types but that
          there are string-like types that don't have such a member.</li>
      <li>Giuseppe acknowledged that the <tt>traits_type</tt> name is quite
          generic.</li>
      <li>Victor expressed opposition to option 2 since it relies on what he
          considers to be a legacy feature and that <tt>traits_type</tt> is, in
          practice, always <tt>std::char_traits</tt>.</li>
      <li>Victor asserted that implicit conversions and implicit interoperation
          with the standard library are not desired for Folly's
          <tt>fbstring</tt>.</li>
      <li>Victor stated that he is ok-ish with option 1.</li>
      <li>Tom asked Victor to further explain his concerns and the damage he
          fears the implicit conversions would cause.</li>
      <li>Victor replied that use of <tt>fbstring</tt> is no longer encouraged
          and the proposed change would facilitate continued usage.</li>
      <li>Victor noted that the proposed changes could also impact overload
          resolution in generic code and potentially introduce overload
          resolution failures due to ambiguity.</li>
      <li>Corentin lamented the ability for programmers to specialize
          <tt>std::char_traits</tt> for their own user-defined types and stated
          he plans to propose deprecating or removing that allowance.</li>
      <li>Corentin explained that the interface that <tt>std::char_traits</tt>
          provides is not a good match for how text processing works in
          practice.</li>
      <li>Corentin asserted that increased use of <tt>std::char_traits</tt>
          should be discouraged.</li>
      <li>Corentin opined that option 1 is fine but that option 2 is
          problematic in the long run.</li>
      <li>Giuseppe acknowledged Corentin's position.</li>
      <li>Corentin clarified that programmers should not be encouraged to use
          a different type than <tt>std::char_traits</tt> but rather that they
          should be encouraged not to use a char-traits-like type at all.</li>
      <li>Tom summarized his understanding of the concerns; the proposed change
          could encourage programmers to add a <tt>traits_type</tt> member type
          alias of <tt>std::char_traits</tt> to classes that otherwise wouldn't
          define the type alias solely to enable implicit conversions to
          <tt>std::string_view</tt>.</li>
      <li>Zach argued for not enabling such implicit conversions at all on the
          basis that <tt>std::string_view</tt> is intended to be implicitly
          convertible from other standard library types and that explicit
          conversions are appropriate elsewhere.</li>
      <li>Alisdair opined that the right approach would be for types to opt
          themselves in to an implicit conversion.</li>
      <li>Alisdair asserted that <tt>std::char_traits</tt> is not legacy and
          that it cannot be removed without significant ABI impact.</li>
      <li>Alisdair stated that the matching <tt>traits_type</tt> constraint is
          a good heuristic and that the opt-in trait in option 1 is so specific
          that he would have a hard time supporting it.</li>
      <li>Jens noted that the proposed wording for option 1 requires both the
          opt-in string-like-type trait and the matching <tt>traits_type</tt>
          constraint to enable implicit conversions.</li>
      <li>Jens expressed a preference for an option that proposed only the
          string-like-type trait.</li>
      <li>Jens stated that the wording needs to be rebased on the current
          working paper since the struck wording has already been removed.</li>
      <li>Jens suggested <tt>is_string_view_like</tt> might not be the best
          choice of name for the opt-in trait and suggested <tt>enable_view</tt>
          as an example name for similar opt-in traits.</li>
      <li>Giuseppe acknowledged the suggestion and stated that the name can be
          changed.</li>
      <li>Jens noted that it doesn't matter how string-view-like the source type
          is as long as it provides contiguous storage and opts itself in.</li>
      <li>Jens agreed with not wanting to encourage the addition of an otherwise
          unused <tt>traits_type</tt> member.</li>
      <li>Jens observed that <tt>is_string_view_like</tt> is false by
          default.</li>
      <li>Jens suggested that, if it is desirable to provide a safety check on a
          matching <tt>traits_type</tt> member, that the
          <tt>is_string_view_like</tt> trait can support a mechanism to enable
          that.</li>
      <li>Jens expressed a preference for postponing a poll to forward the paper
          until it has been rebased on the current working paper.</li>
      <li>Various poll options were discussed but it was decided that polling be
          postponed pending an updated paper revision with wording rebased on
          the current working paper and an additional option to enable implicit
          conversions based solely on the opt-in trait.</li>
    </ul>
  </li>
  <li><a href="https://wg21.link/p2863r0">P2863R0: Review Annex D for C++26</a>:
    <ul>
      <li>Alisdair introduced this and the following papers.</li>
      <li>Tom explained his understanding of the ramifications for removal of
          standard library features; that an implementor may choose not to
          provide the removed features or may choose to provide them since the
          removed names are reserved as "zombie" names.</li>
      <li>Alisdair acknowledged the intent, but noted that the standard
          currently lacks wording to support zombification of explicit template
          specializations.</li>
      <li>Alisdair explained that there are four deprecated subclauses that are
          relevant to SG16;
          <a href="http://eel.is/c++draft/depr.locale.stdcvt">D.26 ([depr.locale.stdcvt])</a>,
          <a href="http://eel.is/c++draft/depr.conversions">D.27 ([depr.conversions])</a>,
          <a href="http://eel.is/c++draft/depr.locale.category">D.28 ([depr.locale.category])</a>,
          and
          <a href="http://eel.is/c++draft/depr.fs.path.factory">D.29 ([depr.fs.path.factory])</a>.</li>
      <li>PBindels stated that
          <a href="http://eel.is/c++draft/depr.str.strstreams">D.15 ([depr.str.strstreams])</a>
          and
          <a href="http://eel.is/c++draft/depr.string.capacity">D.25 ([depr.string.capacity])</a>
          have to do with text facilities but that he reviewed them and
          concluded that the functionality is not strongly relevant for
          SG16.</li>
      <li>Alisdair stated that, for <tt>std::filesystem::u8path</tt>, per
          <a href="https://wg21.link/lwg3840">LWG 3840</a>,
          there have been recent comments that removal would be
          problematic.</li>
      <li>Tom stated that the LWG issue was recently discussed in LEWG but that
          the LWG issue does not appear to have been updated to reflect that
          discussion.</li>
      <li><em>[ Editor's note: LEWG discussed the LWG issue during its
          <a href="https://wiki.edg.com/bin/view/Wg21telecons2023/LWG3840">2023-01-10 telecon</a>.
          ]</em></li>
      <li>Alisdair stated that deprecated features should either be undeprecated
          or removed and noted that this feature has been deprecated since
          C++20.</li>
      <li>Jens expressed concern regarding Billy O'Neal's comment in the LWG
          issue that deprecation of <tt>u8path</tt> was one of the reasons that
          vcpkg discontinued use of <tt>std::filesystem</tt>.</li>
      <li>Jens stated that SG16 should offer an opinion.</li>
      <li>Corentin replied that there was a poll in LEWG in January and that
          there was no consensus to undeprecate <tt>u8path</tt>.</li>
      <li>Corentin stated that a mechanism to access a sequence of <tt>char</tt>
          that holds UTF-8 code units as-if it were a sequence of
          <tt>char8_t</tt> is a feature that we should have; we're missing a way
          to pass such a sequence to the <tt>std::filesystem::path()</tt>
          constructor such that it is interpreted as UTF-8.</li>
      <li>Tom noted that Corentin has a paper on that topic.</li>
      <li><em>[ Editor's note: See
          <a href="https://wg21.link/p2626">P2626 (charN_t incremental adoption: Casting pointers of UTF character types)</a>.
          ]</em></li>
      <li>Alisdair noted that, if removed, <tt>u8path</tt> would be added to the
          list of zombie names, so implementors that wish to continue providing
          it may do so.</li>
      <li>PBindels opined that <tt>u8path</tt> provides a solution to work
          around legacy issues but that Corentin's P2626 provides a proper
          solution.</li>
      <li>PBindels suggested that we should neither undeprecate nor remove
          <tt>u8path</tt> until a proper solution is in place.</li>
      <li>Alisdair stated that he can update the paper to reflect that guidance
          and to note further action as dependent on P2626.</li>
      <li>Charlie agreed with not removing <tt>u8path</tt> without a proper
          alternative.</li>
      <li>Charlie noted that, if <tt>u8path</tt> is zombified, that implementors
          can continue to provide it, but that portability is lost.</li>
      <li>Charlie stated that he didn't see a reason to remove <tt>u8path</tt>;
          that it isn't harmful.</li>
      <li>Alisdair acknowledged that a migration path is needed.</li>
      <li>Tom explained that the original motivation for deprecation was to
          dissuade continuing to provide standard library functions that require
          UTF-8 data in <tt>char</tt>-based storage.</li>
      <li>Tom noted that <tt>u8path</tt> and the deprecated
          <tt>std::codecvt</tt> facets were the only standard library features
          that did so.</li>
    </ul>
  </li>
  <li><a href="https://wg21.link/p2871r0">P2871R0: Remove Deprecated Unicode Conversion Facets From C++26</a>:
    <ul>
      <li>Alisdair presented the paper:
        <ul>
          <li>These facets were deprecated because they did not provide error
              handling capabilities and could not reasonably be extended.</li>
          <li>There are some implementations that do not issue deprecation
              warnings.</li>
        </ul>
      </li>
      <li>Corentin noted the work in progress and general plan to provide
          replacements for C++26 and suggested waiting to remove them pending
          that work.</li>
      <li>Jens agreed and stated that removal without replacements is
          ill-advised unless these are actively causing harm.</li>
      <li>Tom noted that conversions are possible through the <tt>mbrtoc*</tt>
          and <tt>c*rtomb</tt> family of functions though those have their own
          issues.</li>
      <li>Victor stated that the <tt>codecvt</tt> facets are so challenging to
          use that not having a replacement isn't really a problem.</li>
      <li>Alisdair noted that implementors can continue to provide them thanks
          to zombification.</li>
      <li>Alisdair reported that, per the paper, LEWG and SG16 previously
          recommended removal during the C++23 cycle, but that action wasn't
          completed.</li>
      <li>Alisdair reminded the group that <tt>codecvt_utf</tt> and
          <tt>codecvt_utf1</tt> convert to and from UCS-2 or UTF-32 depending
          on the size of the first template parameter.</li>
      <li>PBrett asked for any objections to removal.</li>
      <li>No objections were reported.</li>
      <li>Alisdair stated he will take that feedback back to LEWG.</li>
    </ul>
  </li>
  <li><a href="https://wg21.link/p2873r0">P2873R0: Remove Deprecated Locale Category Facets For Unicode from C++26</a>:
    <ul>
      <li>Tom explained that these facets were deprecated because they convert
          to and from UTF-8 in <tt>char</tt>-based storage rather than between
          the multibyte encoding like the non-deprecated facets do.</li>
      <li>Tom reported that <tt>char8_t</tt>-based replacements were added as
          replacements, but those were a mistake because they won't be used by
          <tt>char</tt>-based streams anyway.</li>
      <li><em>[ Editor's note:
          <a href="https://wg21.link/lwg3767">LWG 3767</a>
          tracks deprecating the <tt>char8_t</tt>-based facets. ]</em></li>
      <li>PBrett asked for any objections to removal.</li>
      <li>No objections were reported.</li>
      <li>Corentin spoke in favor of removal.</li>
    </ul>
  </li>
  <li><a href="https://wg21.link/p2872r0">P2872R0: Remove wstring_convert From C++26</a>:
    <ul>
      <li>Giuseppe asked if the paper includes removal of
          <tt>std::wbuffer_convert</tt>.</li>
      <li>Alisdair confirmed that it does.</li>
      <li>Alisdair explained that these were deprecated because the example for
          <tt>std::wstring_convert</tt> used another deprecated feature,
          <tt>std::codecvt_utf8</tt> and, due to other underspecification
          concerns, noone was motivated to fix them.</li>
      <li>Alisdair asked if SG16 is the right group to address this.</li>
      <li>PBrett responded affirmatively and stated that SG16 is the group that
          misunderstands <tt>wchar_t</tt> the least.</li>
      <li>Alisdair noticed some issues with the paper and concluded that updates
          are required before the paper is ready for any action to be taken on
          it.</li>
    </ul>
  </li>
  <li>Tom stated that the next meeting is tentatively scheduled for 2023-06-07
      and will likely continue review of
      <a href="https://wg21.link/p2779">P2779 (Make basic_string_view’s range construction conditionally explicit)</a>
      and
      <a href="https://wg21.link/p2872">P2872 (Remove wstring_convert From C++26)</a>
      if updated revisions are available followed by an initial review of
      <a href="https://wg21.link/p2845">P2845 (Formatting of std::filesystem::path)</a>.</li>
  <li>Zach reported that he expects to have a new revision of
      <a href="https://wg21.link/p2728">P2728 (Unicode in the Library, Part 1: UTF Transcoding)</a>
      available soon after the Varna meeting.</li>
</ul>


<h1 id="2023_06_07">June 7th, 2023</h1>

<h2>Draft agenda:</h2>

<ul>
  <li><a href="https://wg21.link/p2779r1">P2779R1: Make basic_string_view’s range construction conditionally explicit</a>.</li>
  <li><a href="https://wg21.link/p2872r1">P2872R1: Remove wstring_convert From C++26</a>.</li>
  <li><a href="https://wg21.link/p2845r0">P2845R0: Formatting of std::filesystem::path</a>.</li>
</ul>

<h2>Attendees:</h2>

<ul>
  <li>Alisdair Meredith</li>
  <li>Charlie Barto</li>
  <li>Corentin Jabot</li>
  <li>Fraser Gordon</li>
  <li>Giuseppe D'Angelo</li>
  <li>Jens Maurer</li>
  <li>Mark de Wever</li>
  <li>Mark Zeren</li>
  <li>Peter Brett</li>
  <li>Tom Honermann</li>
  <li>Victor Zverovich</li>
  <li>Zach Laine</li>
</ul>

<h2>Meeting summary:</h2>

<ul>
  <li><a href="https://wg21.link/p2779r1">P2779R1: Make basic_string_view’s range construction conditionally explicit</a>.
    <ul>
      <li><em>[ Editor's note: D2779R1 was the active paper under discussion at
          the telecon.
          The agenda and links used here reference P2749R1 since the links to
          the draft paper were ephemeral.
          The published document may differ from the reviewed draft revision.
          ]</em></li>
      <li>Giuseppe summarized the paper and changes since the last revision:
        <ul>
          <li>The paper endeavors to identify a compromise position for the
              issues that have resulted in multiple changes to how the
              <tt>std::basic_string_view</tt> range constructor is
              specified.</li>
          <li>Option 2 from the previous revision is still present though there
              was not much support for this option in the last discussion.</li>
          <li>Option 1 follows existing precedent for type traits that enable
              some functionality; this option has been divided into two
              sub-options.</li>
          <li>Option 1-A provides a type trait that enables conversion without
              regard to the <tt>traits_type</tt> member.</li>
          <li>Option 1-B provides the type trait from option 1-A as well as an
              additional type trait that can be used to enable conversion that
              is sensitive to the <tt>traits_type</tt> member.</li>
        </ul>
      </li>
      <li>Tom asked if the intent is for the trait to be used only for
          conversion to <tt>std::string_view</tt> or for conversion to any
          string_view-like type.</li>
      <li>Giuseppe responded that it is intended to be used for conversion to
          any string_view-like type.</li>
      <li>Jens suggested in chat: "You can also define
          enable_string_view_conversion in a way so that the user specialization
          can compare char_traits, if so desired (or not)."</li>
      <li>Jens' suggestion received several positive responses.</li>
      <li>Alisdair, following up on Jens' suggestion in chat, asked if the
          traits in option 1-B could be merged.</li>
      <li>Giuseppe confirmed that they could be.</li>
      <li>Alisdair indicated that would be his preference.</li>
      <li>Alisdair stated that the conversion could be enabled based on a class
          member similar to how transparent key comparison for associative
          containers is enabled via the <tt>is_transparent</tt> member of the
          compare class.</li>
      <li>Giuseppe acknowledged that approach would work as well.</li>
      <li>Tom noted that approach would require modifying the class.</li>
      <li>Alisdair responded that the trait could still be specialized but could
          be defaulted based on the presence of a member.</li>
      <li>Jens stated that the most convenient option would be to define a
          conversion operator with the trait available as a fallback.</li>
      <li>Jens expressed a preference for a single trait with template
          parameters such that a specialization can be written to explicitly
          match <tt>traits_type</tt> or <tt>std::char_traits</tt> as
          desired.</li>
      <li>Jens noted that <tt>enable_string_view_conversion_with_traits</tt>
          still requires comparison with <tt>std::char_traits</tt> or a
          <tt>traits_type</tt> member.</li>
      <li>Jens suggested that third party string_view-like classes can provide
          their own trait to enable implicit conversions.</li>
      <li>Giuseppe responded that the goal is to enable interconvertibility
          between different string types.</li>
      <li>Giuseppe noted that the proposal doesn't require comparisons with
          specific type or member names.</li>
      <li>Zach stated that he doesn't find the problem that the paper intends
          to address compelling and noted that <tt>std::string_view</tt> is
          available as a vocabulary type.</li>
      <li>Zach noted that working around the lack of an implicit conversion
          just requires slightly more code; explicit construction of a
          <tt>std::string_view</tt> object.</li>
      <li>Victor requested that the two traits in option 1-B be merged.</li>
      <li>Victor agreed with Alisdair's suggestion to default the trait to
          enable based on the presence of a class member.</li>
      <li>Victor asserted that only the author of a class should opt a class
          into the proposed behavior; not users of the class.</li>
      <li>Victor repeated his opposition to enabling implicit third party
          interoperation.</li>
      <li>Corentin stated that most of the proposed behavior should be being
          discussed in LEWG rather than in SG16 and that SG16 just needs to
          provide a recommendation whether use of <tt>std::char_traits</tt>
          is a good heuristic.</li>
      <li>PBrett responded that there is an SG16 question concerning which
          types are sufficiently text-like.</li>
      <li>PBrett asked for poll suggestions.</li>
      <li>Tom noted that discussion revealed other options that should be
          explored.</li>
      <li>Tom suggested polling the desire to enable interconvertibility
          across any/all string-like types in the ecosystem.</li>
      <li>Poll wordsmithing ensued.</li>
      <li><b>Poll 1.1: Any opt-in to implicit range construction of
          <tt>std::string_view</tt> should be explicit on a per-type basis.</b>
        <ul>
          <li><b>Attendees: 12 (1 abstention)</b></li>
          <li>
            <table>
              <tr>
                <th style="text-align:right">SF</th>
                <th style="text-align:right">F</th>
                <th style="text-align:right">N</th>
                <th style="text-align:right">A</th>
                <th style="text-align:right">SA</th>
              </tr>
              <tr>
                <th style="text-align:right">2</th>
                <th style="text-align:right">8</th>
                <th style="text-align:right">0</th>
                <th style="text-align:right">1</th>
                <th style="text-align:right">0</th>
              </tr>
            </table>
          </li>
          <li><b>Strong consensus.</b></li>
          <li><b>A: If types have character traits, we should be making use of
              them to determine compatibility.</b></li>
        </ul>
      </li>
      <li>Jens responded to the against rationale by stating that use of
          character traits is not excluded; per-type enablement could be
          conditional on matching traits.</li>
      <li><b>Poll 1.2: The standard library should provide a general-purpose
          facility for enablement of implicit interconvertibility between
          string and string_view-like types (including UDTs).</b>
        <ul>
          <li><b>Attendance: 12 (2 abstentions)</b></li>
          <li>
            <table>
              <tr>
                <th style="text-align:right">SF</th>
                <th style="text-align:right">F</th>
                <th style="text-align:right">N</th>
                <th style="text-align:right">A</th>
                <th style="text-align:right">SA</th>
              </tr>
              <tr>
                <th style="text-align:right">1</th>
                <th style="text-align:right">1</th>
                <th style="text-align:right">4</th>
                <th style="text-align:right">4</th>
                <th style="text-align:right">0</th>
              </tr>
            </table>
          </li>
          <li><b>No consensus.</b></li>
        </ul>
      </li>
      <li><b>Poll 1.3: A solution to the problem stated in P2779 needs to be
          included in the C++ standard library.</b>
        <ul>
          <li><b>Attendance: 12 (1 abstention)</b></li>
          <li>
            <table>
              <tr>
                <th style="text-align:right">SF</th>
                <th style="text-align:right">F</th>
                <th style="text-align:right">N</th>
                <th style="text-align:right">A</th>
                <th style="text-align:right">SA</th>
              </tr>
              <tr>
                <th style="text-align:right">1</th>
                <th style="text-align:right">1</th>
                <th style="text-align:right">5</th>
                <th style="text-align:right">4</th>
                <th style="text-align:right">0</th>
              </tr>
            </table>
          </li>
          <li><b>No consensus.</b></li>
        </ul>
      </li>
      <li>Tom stated that he will record the poll results in the paper tracker
          and that it will be up to the LEWG chair to decide what to do
          next.</li>
      <li>PBrett suggested that more examples of how this proposal could
          alleviate programming challenges</li>
      <li>might help to increase motivation.</li>
      <li>Tom agreed and noted that the large proportion of N votes presumably
          reflects insufficient motivation.</li>
    </ul>
  </li>
  <li><a href="https://wg21.link/p2872r1">P2872R1: Remove wstring_convert From C++26</a>.
    <ul>
      <li><em>[ Editor's note: D2872R1 was the active paper under discussion at
          the telecon.
          The agenda and links used here reference P2872R1 since the links to
          the draft paper were ephemeral.
          The published document may differ from the reviewed draft revision.
          ]</em></li>
      <li>Alisdair stated that, If feedback is light, that he will incorporate
          it and publish the paper as P2872R1; otherwise, he will publish
          P2872R1 as-is and incorporate the feedback in a newer revision.</li>
      <li>Alisdair explained that <tt>wbuffer_convert</tt> and
          <tt>wstring_convert</tt> have been deprecated for three standard
          releases now.</li>
      <li>Alisdair noted that removal permits implementors to continue to
          provide the functionality thanks to the additions to zombie
          names.</li>
      <li>Alisdair indicated that wording updates might be needed, but that LWG
          will handle that.</li>
      <li>Alisdair explained that the deprecation was motivated by
          underspecification and dependence on other deprecated features like
          <tt>std::codecvt_utf8</tt>.</li>
      <li>Alisdair reported that there are currently four related open LWG
          issues and that reviving the feature would require more.</li>
      <li>Corentin stated that, without <tt>std::codecvt_utf8</tt>, the
          standard no longer provides features needed to use these types.</li>
      <li>Alisdair agreed and explained that programmers would have to provide
          their own <tt>std::codecvt</tt> facet.</li>
      <li>Corentin acknowledged the requirement, but observed that programmers
          could more easily just implement the needed conversion.</li>
      <li>Victor opined that these types provide little value since they are
          just light wrappers anyway.</li>
      <li>Victor reported that a search of the projects he works on found a few
          uses, but that those uses should be replaced anyway.</li>
      <li>PBrett asked if anyone had an objection to removing these
          features.</li>
      <li>No objections were raised.</li>
      <li>MarkZ reported that a Github search identified few uses.</li>
    </ul>
  </li>
  <li><a href="https://wg21.link/p2845r0">P2845R0: Formatting of std::filesystem::path</a>.
    <ul>
      <li>Victor introduced the paper:
        <ul>
          <li><a href="https://wg21.link/p1636">P1636 (Formatters for library types)</a>
              previously proposed formatting for <tt>std::filesystem::path</tt>
              but was specified to use the <tt>native()</tt> member function
              which might require transcoding and had no provisions for
              handling of non-printable characters.</li>
          <li>This paper proposes a formatter that performs proper transcoding
              and substitutes escape sequences for non-printable characters and
              ill-formed code units.</li>
        </ul>
      </li>
      <li>Victor noticed a missing doublequote character in the first source
          code example in section 2, "Problems".</li>
      <li>Victor reported that some minor issues have been fixed in a draft R1
          revision.</li>
      <li>Corentin asked if backslash path delimiters on Windows would be
          formatted with escape sequences.</li>
      <li>Victor confirmed that they would be, that such substitution might be
          surprising, but is consistent with <tt>std::quoted()</tt>.</li>
      <li>Victor noted that an additional format specifier could be provided
          to choose an alternate behavior.</li>
      <li>Corentin asked about use of the debug specifier, "{:?}".</li>
      <li>Victor replied that the escaped format is proposed as the default
          behavior.</li>
      <li>Charlie asserted that some lattitude is needed to choose an alternate
          escape character since backslash in paths has an important meaning
          on Windows.</li>
      <li>Charlie noted that an alternate escape character could be surprising
          and would create an inconsistency across platforms.</li>
      <li>PBrett asked about adding a specifier that enables specifying a
          different escape character.</li>
      <li>Victor responded that such a specifier would be cumbersome and that
          there are other options such as performing a transformation.</li>
      <li>Victor stated that there are use cases for both an escaped and a
          non-escaped variant.</li>
      <li>Tom presented a few use cases including formatting for generic text,
          byte preserved for filesystem access, punycode for URLs, and quoted
          for shell scripts.</li>
      <li>Tom suggested that most transformations should be done outside of
          formatting.</li>
      <li>Corentin stated that the default behavior should just escape
          ill-formed code units and that the debug format specifier could be
          used to escape problematic characters.</li>
      <li>Victor replied that quoting is useful but not always needed.</li>
      <li>Tom suggested that a specifier could be added to opt in to
          quoting.</li>
      <li>PBrett expressed two high level use cases:</li>
        <ul>
          <li>The need to format the path precisely such that it can be used
              to open a file.</li>
          <li>The need to format the path for textual display in a format
              friendly to humans.</li>
        </ul>
      </li>
      <li>PBrett opined that the paper does not clearly define the problem it
          intends to solve.</li>
      <li>PBrett noted that, in
          <a href="https://docs.gtk.org/glib">GLib</a>,
          functions are provided to request a file name suitable for display
          as valid UTF-8 or as a byte array.</li>
      <li>Victor replied that the goal of the paper is to address the issues
          discovered from prior review of
          <a href="https://wg21.link/p1636">P1636 (Formatters for library types)</a>.</li>
      <li>Victor stated that additional use cases can be addressed as
          needed.</li>
      <li>Zach reported that Python provides the functionality this paper is
          proposing and noted that its formatters will double Windows path
          separators.</li>
      <li>Zach stated that Python allows printing unformatted paths by treating
          paths as a string and that C++ can do so as well.</li>
      <li>Zach agreed that some kind of escaping and quoting is needed.</li>
      <li><em>[ Editor's note: Corentin later
          <a href="https://lists.isocpp.org/sg16/2023/06/3886.php">posted a message to the SG16 mailing list</a>
          that demonstrates Python's behavior with a
          <a href="https://godbolt.org/z/7sf5xPPsc">Compiler Explorer link</a>.
          ]</em></li>
      <li>Jens asserted that, due to various quirks with
          <tt>std::filesystem::path</tt>, that the paper should cover the
          motivation and design space and not solely focus on addressing the
          issues found from review of P1636.</li>
      <li>Jens stated that the paper should discuss, for example, the
          implication of using backslashes in the syntax of character escapes
          in formatted paths.</li>
      <li>PBrett agreed.</li>
      <li>PBrett noted that we were out of time and that additional review will
          be needed to discuss encoding issues.</li>
    </ul>
  </li>
  <li>Tom stated that the next meeting is scheduled for 2023-06-28, that there
      are several LWG issues awaiting review, and that Zach is working on a
      revision of
      <a href="https://wg21.link/p2728">P2728 (Unicode in the Library, Part 1: UTF Transcoding)</a>.</li>
  <li><em>[ Editor's note: The following meeting was canceled due to summer
      vacations. ]</em></li>
  <li>Zach stated an expectation to have a new revision available in the next
      two weeks.</li>
</ul>


</body>
