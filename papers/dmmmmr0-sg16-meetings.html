<!doctype html public "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">

<head>
<title>SG16: Unicode meeting summaries 2022-06-22 through 2022-09-14</title>
</head>

<style type="text/css">

table#header th,
table#header td
{
    text-align: left;
}

tt {
    font-family: monospace;
}

/* Thanks to Elias Kosunen for the following CSS suggestions! */

* {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
    line-height: 125%;
}

html, body {
    background-color: #eee;
}

h1, h2, h3, h4, h5, p, span, li, dt, dd {
    color: #333;
}

p, li {
    line-height: 140%;
}

body {
    padding: 1em;
    max-width: 1600px;
}

p, li {
    -moz-osx-font-smoothing: grayscale;
    -webkit-font-smoothing: antialiased !important;
    -moz-font-smoothing: antialiased !important;
    text-rendering: optimizelegibility !important;
    letter-spacing: .01em;
}

h1, h2, h3 {
    margin-bottom: 1em;
    letter-spacing: .03em;
}

blockquote.quote
{
    margin-left: 0em;
    border-style: solid;
    background-color: lemonchiffon;
    color: #000000;
    border: 1px solid black;
}

</style>

<body style="max-width: 8.5in">

<table id="header">
  <tr>
    <th>Document Number:</th>
    <td>DXXXXR0 <em>Draft</em></td>
  </tr>
  <tr>
    <th>Date:</th>
    <td>2022-09-26</td>
  </tr>
  <tr>
    <th>Audience:</th>
    <td>SG16</td>
  </tr>
  <tr>
    <th>Reply-to:</th>
    <td>Tom Honermann &lt;tom@honermann.net&gt;</td>
  </tr>
</table>


<h1>SG16: Unicode meeting summaries 2022-06-22 through 2022-09-14</h1>

<p>
Summaries of SG16 meetings are maintained at
<a href="https://github.com/sg16-unicode/sg16-meetings">
https://github.com/sg16-unicode/sg16-meetings</a>.  This paper contains a
snapshot of select meeting summaries from that repository.
</p>

<ul>
  <li><a href="#2022_06_22">
      June 22nd, 2022</a></li>
  <li><a href="#2022_07_27">
      July 27th, 2022</a></li>
  <li><a href="#2022_08_24">
      August 24th, 2022</a></li>
  <li><a href="#2022_09_14">
      September 14th, 2022</a></li>
</ul>

<p>
Previously published SG16 meeting summary papers:
<ul>
  <li><a href="https://wg21.link/p1080">P1080: SG16: Unicode meeting summaries 2018/03/28 - 2018/04/25</a></li>
  <li><a href="https://wg21.link/p1137">P1137: SG16: Unicode meeting summaries 2018/05/16 - 2018/06/20</a></li>
  <li><a href="https://wg21.link/p1237">P1237: SG16: Unicode meeting summaries 2018/07/11 - 2018/10/03</a></li>
  <li><a href="https://wg21.link/p1422">P1422: SG16: Unicode meeting summaries 2018/10/17 - 2019/01/09</a></li>
  <li><a href="https://wg21.link/p1666">P1666: SG16: Unicode meeting summaries 2019/01/23 - 2019/05/22</a></li>
  <li><a href="https://wg21.link/p1896">P1896: SG16: Unicode meeting summaries 2019/06/12 - 2019/09/25</a></li>
  <li><a href="https://wg21.link/p2009">P2009: SG16: Unicode meeting summaries 2019-10-09 through 2019-12-11</a></li>
  <li><a href="https://wg21.link/p2179">P2179: SG16: Unicode meeting summaries 2020-01-08 through 2020-05-27</a></li>
  <li><a href="https://wg21.link/p2217">P2217: SG16: Unicode meeting summaries 2020-06-10 through 2020-08-26</a></li>
  <li><a href="https://wg21.link/p2253">P2253: SG16: Unicode meeting summaries 2020-09-09 through 2020-11-11</a></li>
  <li><a href="https://wg21.link/p2352">P2352: SG16: Unicode meeting summaries 2020-12-09 through 2021-03-24</a></li>
  <li><a href="https://wg21.link/p2397">P2397: SG16: Unicode meeting summaries 2021-04-14 through 2021-05-26</a></li>
  <li><a href="https://wg21.link/p2512">P2512: SG16: Unicode meeting summaries 2021-06-09 through 2021-12-15</a></li>
  <li><a href="https://wg21.link/p2605">P2605: SG16: Unicode meeting summaries 2022-01-12 through 2022-06-08</a></li>
</ul>
</p>


<h1 id="2022_06_22">June 22nd, 2022</h1>

<h2>Draft agenda:</h2>

<ul>
  <li>Continue discussion of survey questions for the 2023 C++ Developer Survey.
    <ul>
      <li>Revise, add, and remove questions from the
          <a href="https://docs.google.com/document/d/1lRU7uErn2Vc7LOGG2H3PrzCvmf69u8S_v-43by_Vb9c/edit?usp=sharing">draft survey document</a>.
    </ul>
  </li>
</ul>

<h2>Attendees:</h2>

<ul>
  <li>Hubert Tong</li>
  <li>Jens Maurer</li>
  <li>Peter Brett</li>
  <li>Steve Downey</li>
  <li>Tom Honermann</li>
</ul>

<h2>Meeting summary:</h2>

<ul>
  <li>Continue discussion of survey questions for the 2023 C++ Developer Survey:
    <ul>
      <li><em>[ Editor's note: The active revision at the start of the meeting
          can be viewed by selecting <tt>File</tt> | <tt>Version history</tt> |
          <tt>See version history</tt>, then selecting the version named
          "pre 2022-06-22 meeting", then clicking the rightward facing triangle
          next to the version name to "expand detailed versions"; this latter
          step is necessary to exclude detailed edits that otherwise interfere
          with numbering of the questions. ]</em></li>
      <li>Tom asked attendees to nominate questions to be removed from
          consideration.</li>
      <li>PBrett suggested removing
          Q1 (What character encoding(s) do you use for source files?)
          since we already have consensus for moving towards UTF-8 encoded
          source files.</li>
      <li>PBrett asked how answers to Q1 would affect our decision making.</li>
      <li>Jens concurred and asked hypothetically whether responses would
          entice us to, for example, add a translation phase 1 option to
          support GB18030 as we are doing for UTF-8 via
          <a href="https://wg21.link/p2295">P2295 (Support for UTF-8 as a portable source file encoding)</a>.</li>
      <li>Jens noted that implementations that support non-UTF-8 source files
          will continue to support them and argued that there is nothing to be
          done within the standard.</li>
      <li>Hubert suggested an alternative formulation that asks which scripts
          programmers are using in their source files and for which they might
          be using specific encodings.</li>
      <li>Jens noted that
          <a href="https://wg21.link/p2528">P2528 (C++ Identifier Security using Unicode Standard Annex 39)</a>
          assumes that everyone is using Unicode for their source file encoding
          and that encoding does not imply which scripts are being used.</li>
      <li>Jens stated that use of a particular encoding such as ISO8859-1 does
          restrict what scripts can be used and that such information could
          potentially be used in confusability analysis.</li>
      <li>Jens suggested the question could probe which scripts are used in
          conjunction with a non-Unicode encoding.</li>
      <li>PBrett noted the existence of the Big-5 encoding and that it is being
          phased out in favor of GB18030 and UTF-8.</li>
      <li>PBrett asked if we are at risk of discussing whether support for
          additional encodings should be mandated.</li>
      <li>Hubert responded negatively and stated that the question is intended
          to probe the extent to which substantial use of non-Unicode encodings
          remains.</li>
      <li>Tom stated that it sounds like we have not identified a use case for
          this question.</li>
      <li>Tom struck Q1 from the draft document.</li>
      <li>PBrett expressed uncertainty as to what
          Q2 (What character encoding(s) do you use for string literals?)
          is intended to ask and stated that it might be interpreted as asking
          if <tt>L</tt>, <tt>u8</tt>, <tt>u</tt>, or <tt>U</tt> prefixed
          literals are being used.</li>
      <li>Tom replied that the question is intended to ascertain what encodings
          are being used for the encoding of ordinary (non-prefixed) literals
          in order to learn about trends occurring in the ecosystem.</li>
      <li>Hubert noted that we now assume that if string literals are UTF-8,
          then the locale encoding is as well.</li>
      <li>PBrett expressed a feeling of persistent saltiness over that
          assumption.</li>
      <li>Jens stated that only <tt>std::format</tt> is currently pushing us
          towards Unicode in this way.</li>
      <li>Tom stated that we seem to have no use case for this question.</li>
      <li>Tom struck Q2 from the draft document.</li>
      <li>PBrett suggested removing
          Q10 (How are the project(s) that you work on organized for Unicode
              normalization?)
          on the basis that few programmers are aware of Unicode
          normalization.</li>
      <li>Tom responded that the question is intended to provide input
          regarding whether normalization should be reflected in the type
          system.</li>
      <li>Steve stated that it doesn't matter for most programmers, but that
          it matters immensely for a few.</li>
      <li>PBrett suggested it is not a good candidate question if we believe it
          impacts few programmers.</li>
      <li>Tom struck Q10 from the draft document.</li>
      <li>PBrett opined that
          Q13 (Do your project(s) use regular expressions for which the search
              pattern is not known at compile-time?)
          is important to determine if programmers create regular expressions
          using user input.</li>
      <li>PBrett stated that it probes whether
          <a href="https://compile-time-regular-expressions.readthedocs.io/en/latest">CTRE</a>
          is a suitable replacement for <tt>std::regex</tt>.</li>
      <li>PBrett stated that
          Q14 (Which regular expression languages do you use?)
          appears to duplicate
          Q12 (What libraries do you use for regular expression support?).</li>
      <li>Tom replied that Q14 is intended to ask which regular expression
          languages are being used; for example, which of the six languages
          supported by <tt>std::regex</tt> are being used.</li>
      <li>Hubert stated that Q12 could be useful to determine whether collation
          support is useful and noted that use of POSIX languages may imply
          better locale support needs.</li>
      <li>Jens observed that programmers might use those languages for other
          reasons.</li>
      <li>PBrett replied that programmers tend to use whatever language the
          regular expression facility they are already using supports.</li>
      <li>Tom struck Q14 from the draft document.</li>
      <li>Jens asserted that
          Q15 (Do you use the signed char or unsigned char types for text
              processing?)
          is not interesting.</li>
      <li>Hubert asked if that concern is motivated by the lack of standard
          library support.</li>
      <li>Jens replied that iostream supports signed and unsigned char
          types.</li>
      <li>Tom stated that the question is intended to help determine whether
          these types should be used exclusively as small integer types as
          opposed to character types.</li>
      <li>Jens opined that programmers should use <tt>char</tt>,
          <tt>char8_t</tt>, etc... for character types.</li>
      <li>PBrett noted that <tt>unsigned char</tt> is commonly used as a
          character type in C.</li>
      <li>Tom stated that this reflects a policy issue regarding whether we
          intend to extend the standard library to support use of these types
          for text and stated we have no such intent.</li>
      <li>Jens agreed, noted that the aliasing is unfortunate, and expressed
          support for not making the situation worse.</li>
      <li>Tom struck Q15 from the draft document.</li>
      <li>Jens expressed support for asking programmers how they support
          internationalization and localization.</li>
      <li>PBrett suggested dropping
          Q19 (What libraries do you use for collation?).</li>
      <li>Jens countered with a suggestion to merge
          Q17 (What libraries or operating system features do you use for
              language translation?),
          Q18 (What libraries do you use for localization?),
          and Q19.</li>
      <li>Tom agreed to do so.</li>
      <li>Tom pondered whether it is worth asking about prohibition of standard
          library facilities.</li>
      <li>PBrett responded that we can infer avoidance of the standard library
          when programmers state that they use, for example, ICU, but not the
          standard library facilities.</li>
      <li>Steve stated that the explicit locale capabilities present in
          <tt>std::format</tt> are representative of what programmers want.</li>
      <li>PBrett asked about adding a free form field for programmers to state
          how they support localization.</li>
      <li>Tom responded that it is difficult to extract data from free form
          entries.</li>
      <li>Steve stated that it is useful to know that no one uses, for example,
          <tt>stdcoll()</tt>.</li>
      <li>Tom asked if the "discourage or prohibit" language should be
          retained.</li>
      <li>Jens replied negatively and stated that we want to know what they do
          use.</li>
      <li>Hubert stated that
          Q16 (Do you use the C and C++ locale features?)
          is useful to know if, or to what extent, programmers depend on the C
          and C++ locale for identification purposes.</li>
      <li>Tom agreed to simplify Q16.</li>
      <li>Tom pondered what we would use the responses to questions about
          languages and scripts for.</li>
      <li>PBrett replied that Visual Studio Code has
          <a href="https://unicode.org/reports/tr9/#HL4">UAX#9 HL4</a>
          features intended to help with display of bidirectional text in
          source files; that information could be used for SG15 guidance.</li>
      <li>Jens stated that the standard allows identifiers, literals, and
          comments to be written in many kinds of scripts; support for
          languages such as Japanese is intentional.</li>
      <li>Jens added that he favors developing guidelines to encourage features
          like those that Visual Studio Code offers.</li>
      <li>Tom noted that guidance will be forthcoming from the Unicode Source
          Code Ad-Hoc Group.</li>
      <li>PBrett concluded that it sounds like we already know we want to
          support these features; the data could help establish urgency.</li>
      <li>Jens agreed, but noted that implementors can decide for themselves
          what is and is not urgent.</li>
      <li>Tom struck Q3 and Q4 from the draft document.</li>
      <li>Tom opined that
          Q5 (Do you use characters other than the basic character set in
             identifiers)
          is probably irrelevant following the adoption of
          <a href="https://wg21.link/p1949">P1949 (C++ Identifier Syntax using Unicode Standard Annex 31)</a>.</li>
      <li>Steve indicated that language specific concerns are best addressed in
          a code style guide.</li>
      <li>Tom struck Q5 from the draft document.</li>
      <li>Discussion ensued regarding poll bias and privacy concerns.</li>
      <li>PBrett suggested we could ask which region of the world respondents
          are located in.</li>
      <li>Jens replied that such a question might be one that the Standard C++
          Foundation is interested in asking anyway; it may not need to be
          included within our quota of questions.</li>
      <li>Hubert suggested it would be useful to emphasize culture as opposed
          to geographical location.</li>
      <li>PBrett expressed a preference for asking which nation the respondent
          is in.</li>
      <li>Tom suggested asking respondents what their native language is.</li>
      <li>Jens replied negatively; there are many languages spoken in
          India.</li>
      <li>Tom proposed striking
          Q6 (Do the projects you work on limit locale selection in deployment
             environments to those that use a specific character encoding?)
          on the basis that mainframes aren't going away any time soon.</li>
      <li>Tom struck Q6 from the draft document.</li>
      <li>PBrett suggested merging
          Q7 (What libraries do you use for text processing?),
          Q8 (How are the project(s) that you work on organized for text
             processing?), and
          Q9 (If your project(s) convert text to and from an internal encoding,
             what encoding(s) are used for the internal encoding?)
          based on an expectation that use of framework libraries like QT
          sufficiently answer these questions.</li>
      <li>Jens noted that we already have agreement that we want utilities to
          convert to/from UTF-8 and possibly UTF-16.</li>
      <li>Tom asked for clarification that such agreement is relative to locale
          dependent encodings.</li>
      <li>Steve replied yes, but also to other specified encodings.</li>
      <li>PBrett asserted that these questions have already been probed by
          JeanHeyd.</li>
      <li>Tom explained that
          Q7 (What libraries do you use for text processing?)
          is really intended to ascertain what features are supported via
          non-standard libraries because the standard does not provide adequate
          support for them.</li>
      <li>Jens suggested asking that question instead.</li>
      <li>Tom agreed to rephrase Q7 accordingly.</li>
      <li>Jens suggested asking what text processing features people most need;
          whether that be transcoding, Unicode algorithms, or something
          else.</li>
      <li>Jens noted that regular expression support could be added to that
          list differentiated by compile-time vs run-time support.</li>
      <li>Steve asserted that a laundry list would be ok.</li>
    </ul>
  </li>
  <li>Tom stated that the next meeting is scheduled for July 13th but that we
      need new papers.</li>
</ul>


<h1 id="2022_07_27">July 27th, 2022</h1>

<h2>Draft agenda:</h2>

<ul>
  <li><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3016.pdf">WG14 N3016: Unicode Length Modifiers v3</a>
</ul>

<h2>Attendees:</h2>

<ul>
  <li>Eskil Steenberg</li>
  <li>Hubert Tong</li>
  <li>Jens Maurer</li>
  <li>Marcus Johnson</li>
  <li>Peter Brett</li>
  <li>Tom Honermann</li>
  <li>Victor Zverovich</li>
</ul>

<h2>Meeting summary:</h2>

<ul>
  <li><a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3016.pdf">WG14 N3016: Unicode Length Modifiers v3</a>:
    <ul>
      <li>PBrett introduced the topic and invited Marcus to present his
          paper.</li>
      <li>Marcus discussed the motivation for the paper; the desire to be able
          to easily format text in a Unicode encoding.</li>
      <li>Tom provided a summary of the WG14 review of the paper during the
          recent WG14 meeting.</li>
      <li>PBrett described how <tt>gettext()</tt> is used; a string in the
          string literal encoding is provided and a string in the current
          locale encoding is produced.</li>
      <li>Tom stated that there is effectively a contract that the string
          produced by <tt>gettext()</tt> is encoded in the current locale
          encoding.</li>
      <li>PBrett confirmed.</li>
      <li>PBrett asked how <tt>printf()</tt> would handle formatting a UTF-16
          encoded argument.</li>
      <li>Tom replied that the existing practice for <tt>wchar_t</tt> based
          arguments is to convert them to the current locale encoding.</li>
      <li>Tom asked if motivation exists for an alternative behavior.</li>
      <li>Jens asked for an example of alternative behavior.</li>
      <li>Tom replied that the string literal encoding could be used to guide
          conversions instead of the current locale and noted that this would
          match the behavior chosen for <tt>std::format()</tt> when the string
          literal encoding is a Unicode encoding.</li>
      <li>Tom explained that such behavior would require preserving the string
          literal encoding for each translation unit and then somehow passing
          that information to <tt>printf()</tt>.</li>
      <li>Jens noted that <tt>std::printf()</tt> and <tt>gettext()</tt> have
          different encoding expectations; the former expects the formatting
          string to be in the current locale encoding while the latter expects
          something else.</li>
      <li><em>[ Editor's note: The
          <a href="https://man7.org/linux/man-pages/man3/gettext.3.html">GNU gettext man page</a>
          states:</em>
          <blockquote class="quote">
            The <tt>msgid</tt> argument identifies the message to be translated.
            By convention, it is the English version of the message, with
            non-ASCII characters replaced by ASCII approximations.
          </blockquote>
          <em>]</em></li>
      <li>PBrett stated that it is rare in his experience for a string literal
          to be passed as the format string to <tt>printf()</tt>.</li>
      <li>Victor replied that in the code base he works on, approximately 50%
          of <tt>printf()</tt> calls pass a string literal.</li>
      <li>Tom surmised that Victor's experience may reflect an assumption of
          UTF-8 as both the string literal encoding and the locale
          encoding.</li>
      <li>Victor replied that third party libraries are more likely to not
          assume UTF-8.</li>
      <li>Jens asked if there is motivation to introduce a
          <tt>u8printf()</tt>.</li>
      <li>Tom replied that adding such an interface is an option.</li>
      <li>Jens expressed belief that we have consensus that the future is UTF-8
          and that transcoding operations should occur at program
          boundaries.</li>
      <li>PBrett expressed acceptance of library UB as a result of passing a
          format string to <tt>printf()</tt> that is not encoded in the
          expected encoding.</li>
      <li>Jens asked how <tt>printf()</tt> implementations recognize the '%'
          character today.</li>
      <li>Hubert responded that <tt>printf()</tt> is required to be locale
          sensitive and that the code point value of the '%' character may vary
          across encodings.</li>
      <li>Eskil professed that implementations simply search for a code unit
          that matches the ASCII encoding of '%'.</li>
      <li>Jens argued that is an unlikely implementation choice for an
          EBCDIC-based system.</li>
      <li>Hubert explained that the '%' character encoding is non-varying
          across EBCDIC code pages so a simple search for a code unit that
          matches the EBCDIC encoding works on such systems.</li>
      <li>Jens surmised that, for implementations that support a locale
          encoding that is unrelated to the string literal encoding, there must
          exist a compile time decision regarding calls to
          <tt>printf()</tt>.</li>
      <li>Hubert responded affirmatively and stated that the <tt>printf()</tt>
          family of functions have multiple entry points on z/OS.</li>
      <li><em>[ Editor's note: The z/OS C run-time library provides
          EBCDIC-based implementations and ASCII-based implementations.
          The latter exist to support an ASCII environment on z/OS systems.
          See IBM's
          <a href="https://www.ibm.com/docs/en/zos/2.3.0?topic=table-enhanced-ascii-support">Enhanced ASCII support documentation</a>.
          ]</em></li>
      <li>PBrett reported having seen cases where, if <tt>printf()</tt> was not
          locale sensitive, the results produced would not have matched
          expectations.</li>
      <li>Tom agreed that we have established that the format string must match
          the locale encoding.</li>
      <li>Eskil stated that, ideally, the string literal and locale encodings
          would match.</li>
      <li>Hubert agreed but noted that the locale encoding is controlled by the
          program user as opposed to the program author.</li>
      <li>Eskil observed that character conversions are not desirable in all
          cases and provided production of a JPEG header as an example.</li>
      <li>Jens noted that there is no current proposal to implicitly convert
          the <tt>printf()</tt> format string to the locale encoding.</li>
      <li>Eskil and others agreed that such a proposal would be
          ill-advised.</li>
      <li>PBrett concluded that the current <tt>printf()</tt> behavior matches
          the needs of the paper; it must alreadly be locale encoding aware, so
          conversion between UTF encodings and the locale encoding is
          reasonable.</li>
      <li>Hubert agreed assuming requisite functionality as proposed in
          JeanHeyd's transcoding facilities.</li>
      <li>Hubert stated that it would be necessary to specify how transcoding
          errors are handled.</li>
      <li>Tom expressed a belief that the C standard already specifies how such
          errors are handled via delegation to functions like
          <tt>wcrtomb()</tt>.</li>
      <li>Hubert responded with a belief that the C standard requires that
          well-formed multibyte strings and well-formed wide strings always be
          interconvertible without loss.</li>
      <li>Tom expressed surprise that such a requirement exist.</li>
      <li>PBrett noted that the wording would need to specify whether the
          precision flag applies to code units, code points, or extended
          grapheme clusters (EGCs).</li>
      <li>PBrett stated that additional flags could select either code units,
          code points, or EGCs.</li>
      <li>PBrett asserted that the grapheme break algorithm is not too onerous
          a requirement.</li>
      <li>Tom asserted that the precision flag must specify code units for
          consistency with other uses of precision flags and that written code
          units should not split code points or EGCs.</li>
      <li>Hubert explained that the number of code units read from the input must
          not exceed the specified precision for security reasons.</li>
      <li>Discussion ensued regarding the possibility of buffer overflows and
          existing uses of the precision flag.</li>
      <li>Victor asked if the precision flag currently specifies the maximum
          number of input characters when performing wide character
          conversions.</li>
      <li>Hubert responded affirmatively but suggested verifying.</li>
      <li>PBrett noted that, for existing uses, code units is equivalent to
          characters.</li>
      <li>Tom explained his understanding of the precision flag; that if the
          precision is <em>X</em>, then up to <em>X</em> code units are read,
          but only the complete code unit sequences are written.</li>
      <li>Hubert responded that, if the input string had <em>X</em> code
          points, but the number of code units to write differs, then the same
          number of characters written would not match <em>X</em>.</li>
      <li>PBrett asserted that it is common to use the precision to limit
          output.</li>
      <li>Tom checked
          <a href="https://cppreference.com">https://cppreference.com</a>
          and reported that it claims that the <tt>%s</tt> specifier uses the
          precision to limit the maximum number of bytes to write.</li>
      <li>Eskil expressed a preference towards designing for the future and
          that legal output always be produced.</li>
      <li>Hubert checked the C standard and reported that the precision
          specifies the maximum number of output code units in the target
          encoding and that partial characters are not written.</li>
      <li>Victor summarized; the precision is the amount of output to write
          and the remainder of what was read is discarded.</li>
      <li>PBrett asserted that programmers expect the precision to express
          display width.</li>
      <li>Hubert responded that existing behavior hasn't matched that
          expectation for as long as multibyte encodings have existed.</li>
      <li>Hubert pondered whether field width has a meaning in this case.</li>
      <li>PBrett replied that field width fills and that precision
          truncates.</li>
      <li>PBrett asserted that what code authors really want is the ability to
          specify display width.</li>
      <li>Tom asked if there is agreement that <tt>printf()</tt> does not
          currently have the ability to specify display width.</li>
      <li>PBrett and Eskil responded negatively.</li>
      <li>Discussion ensued regarding EGCs and display width.</li>
      <li>Eskil expressed a preference that the C standard provide base level
          functionality and that additional functionality be built as
          libraries.</li>
      <li>Eskil asserted that there isn't always a single best solution.</li>
      <li>Hubert noted that, with regard to code points vs EGCs, splitting an
          EGC can produce misleading output.</li>
      <li>PBrett noted that virtually all programs need to interact with text
          in some capacity.</li>
      <li>Eskil stated that some capabilities are fundamental and provided the
          example of formatting a number.</li>
      <li>Eskil stated that, with regard to string types, there are uses for a
          size+pointer string type,
          a size+buffer string type,
          a size+capacity+buffer string type,
          a string-with-allocator string type,
          and more.</li>
    </ul>
  </li>
  <li>Tom indicated that the next meeting is scheduled for August 10th and that
      the agenda is yet to be determined.</li>
</ul>


<h1 id="2022_08_24">August 24th, 2022</h1>

<h2>Draft agenda:</h2>

<ul>
  <li>Initial planning for Kona.</li>
  <li><a href="https://wg21.link/p2626r0">P2626R0: charN_t incremental adoption: Casting pointers of UTF character types</a>.
</ul>

<h2>Attendees:</h2>

<ul>
  <li>Corentin Jabot</li>
  <li>Hubert Tong</li>
  <li>Jens Maurer</li>
  <li>Mark de Wever</li>
  <li>Peter Brett</li>
  <li>Steve Downey</li>
  <li>Tom Honermann</li>
  <li>Victor Zverovich</li>
</ul>

<h2>Meeting summary:</h2>

<ul>
  <li>Initial planning for Kona.
    <ul>
      <li>Tom stated that there will likely be NB comments for SG16 to address
          and that they are unlikely to be available in a timeframe that would
          allow us to discuss them before the Kona meeting begins.</li>
      <li>Tom explained that, if few people will be present in Kona, that he is
          inclined not to reserve a room, but rather to have both in-person and
          remote attendees join a Zoom meeting for discussions.</li>
      <li>PBrett suggested that any such meetings should be planned for early
          morning Kona time in order for remote attendees in Europe and the US
          east coast to be able to attend.</li>
      <li>Jens explained his current plans and expectations for room setup and
          audio capabilities.</li>
      <li>Jens cautioned that the conference wifi may not handle many in-person
          attendees using Zoom at the same time.</li>
    </ul>
  </li>
  <li><a href="https://wg21.link/p2626r0">P2626R0: charN_t incremental adoption: Casting pointers of UTF character types</a>:
    <ul>
      <li>Corentin presented the paper.
        <ul>
          <li><tt>char8_t</tt>, <tt>char16_t</tt>, and <tt>char32_t</tt> are
              useful for their encoding assurances, but lack support in the
              standard library.</li>
          <li>Unfortunately, we can't just assume UTF-8 with <tt>char</tt>-based
              types and avoid use of the UTF variants.</li>
          <li>Some form of interconvertibility between <tt>char</tt>,
              <tt>wchar_t</tt>, and the UTF character types is needed for the
              latter types to be incrementally adopted.</li>
          <li>Copying the content of an array of one character type to an array
              of another character type just because existing code needs to
              access it by the latter type is expensive.</li>
          <li>None of the current language facilities enable zero cost
              interconvertibility.</li>
          <li>The proposed functions are intended to have a narrow
              contract.</li>
          <li>The names of the functions are intended to reflect the
              partitioning of character types that are always used with UTF data
              and other character types.</li>
          <li>The functions are intended to provide interoperability in constant
              expressions.</li>
          <li>The <tt>basic_string_view</tt> and <tt>span</tt> interfaces are
              provided for convenience.</li>
          <li>The alias barrier based conversion operations that ICU uses are
              non-conforming, probably don't work reliably, and probably can't
              be made to work in the C++ core language.</li>
          <li><em>[ Editor's note: See
              <a href="https://github.com/sg16-unicode/sg16/issues/67">SG16 issue #67</a>
              for more background information regarding the ICU alias barriers.
              ]</em></li>
          <li>An interoperability solution is needed for the UTF character types
              to be adopted in practice.·</li>
        </ul>
      </li>
      <li>Victor asked how the proposed functions would work on a system where,
          for example, <tt>wchar_t</tt> is not the same size as
          <tt>char16_t</tt>.</li>
      <li>Corentin responded that the functions are constrained such that the
          source and target types must have the same size and alignment; a call
          is ill-formed otherwise.</li>
      <li>Victor requested that the paper be updated to explicitly state early
          in the paper what properties of the types must match for the
          operations to be well-formed.</li>
      <li>Hubert stated that there are memory model concerns that may make this
          feature not worth pursuing; the proposed functions provide a very
          sharp feature.</li>
      <li>Tom asked Corentin why he felt SG1 might want to review the
          paper.</li>
      <li>Corentin responded that his understanding is that SG1 is generally
          consulted regarding the C++ abstract machine, the memory model, and
          concurrency concerns.</li>
      <li>Jens explained that the concerns the paper raises have more to do with
          the object model than the memory model and that these concerns fall
          more under CWG than SG1.</li>
      <li>Jens noted that
          <a href="https://wg21.link/p2590">P2590 (Explicit lifetime management)</a>,
          a paper with related concerns, was reviewed by LWG and CWG, but not
          by SG1.</li>
      <li>Jens added that
          <a href="https://wg21.link/p2590">P2590</a>
          completed work that began with
          <a href="https://wg21.link/p0593">P0593 (Implicit creation of objects for low-level object manipulation)</a>
          and that paper also targeted LWG and CWG.</li>
      <li>Corentin asked if the paper represents a good direction.</li>
      <li>Hubert stated that the proposed semantics are such that, if these
          functions were called to replace a subobject, that the enclosing
          complete object would be destroyed.</li>
      <li><em>[ Editor's note: Hubert provided a reference to the relevant
          wording in
          <a href="http://eel.is/c++draft/basic.life#1">[basic.life]p1</a>
          in a follow up
          <a href="https://lists.isocpp.org/sg16/2022/08/3359.php">post to the SG16 mailing list</a>.
          ]</em></li>
      <li>Hubert repeated his assertion that the proposed semantics have sharp
          edges.</li>
      <li>Hubert noted that there are on-going concerns involving
          <tt>start_lifetime_as()</tt> and base classes.</li>
      <li>Jens commented that the complete object would only be saved from
          destruction if there is a <em>provides storage</em> relationship
          (<a href="http://eel.is/c++draft/basic#intro.object-3">[intro.object]p3</a>)
          between the subobject and the target type.</li>
      <li>Jens suggested that a better approach might be to add
          <tt>constexpr</tt> support to <tt>start_lifetime_as_array()</tt>.</li>
      <li>Jens added that it might be possible for
          <tt>start_lifetime_as_array()</tt> to offer additional guarantees in
          cases where an underlying type is shared.</li>
      <li>Tom stated that there is a complicated relationship between the core
          language possibilities and how that impacts the library interface
          possibilities.</li>
      <li>Tom expressed a preference for specifying an ideal library interface
          that then drives the core language needs.</li>
      <li>Hubert expressed uncertainty with regard to how to word restrictions
          around usage of an enclosing object following a change of type for a
          subobject; use or destruction of the subobject via the enclosing
          object would have to be avoided.</li>
      <li>Corentin said he would try to address that.</li>
      <li>Corentin stressed that, once an object's type is changed, the memory
          for that object cannot be accessed as though an object of the
          previous type is there.</li>
      <li>Hubert reiterated that a change of type for a subobject becomes very
          complicated.</li>
      <li>Jens asked if the paper includes examples that are reflective of how
          this facility would be used in something like real world code.</li>
      <li>Jens noted that the mailing list discussion indicated that conversion
          in one direction must be followed by a conversion back.</li>
      <li>Corentin expressed uncertainty regarding what limitations must be
          imposed and voiced an assumption that, since the character types are
          trivial, there is more flexibility.</li>
      <li>Jens stated that the core language has moved towards objects of a
          trivial type being destroyed at the same point as other types; in the
          past objects of a trivial type could be accessed after their point of
          destruction until their storage was destroyed.</li>
      <li>Jens noted that there may be wording that states that destruction of
          a trivial object where an object of another type is present results
          in undefined behavior and provided
          <a href="http://eel.is/c++draft/basic.life#6">[basic.life]p6</a>
          as a reference.</li>
      <li>Tom described his understanding of how constant evaluation works in
          terms of interterpretation of an AST; constant evaluators can
          currently rely on the type system; changing the type of an object
          could lead to undefined behavior within the evaluator.</li>
      <li>Hubert agreed with Tom's description and stated that multiple
          implementors should be consulted.</li>
      <li>Corentin suggested that such problems might be avoided via dependence
          on an underlying type relationship.</li>
      <li>PBrett asked why the object type is so problematic and why, if a
          region of memory contains bytes that represent UTF-8 encoded text, it
          can't simply be accessed as an array of <tt>char8_t</tt>.</li>
      <li>Tom explained that constant evaluation is based on the C++ object
          model and that the concept of memory regions don't apply there.</li>
      <li>Corentin further explained that compiler optimizers use
          <a href="https://en.wikipedia.org/wiki/Alias_analysis#Type-based_alias_analysis">type based alias analysis (TBAA)</a>
          to eliminate re-reading memory and
          <a href="https://en.wikipedia.org/wiki/Dead_store">dead stores</a>
          (writes to memory that will never be observed according to the
          abstract machine) based on the type system.</li>
      <li>PBrett suggested that such alias restrictions could be removed.</li>
      <li>Hubert responded that doing so would impact performance.</li>
      <li>Jens noted that <tt>char8_t</tt> raised the abstraction level in C++
          but not in C since <tt>char8_t</tt> is a type alias of
          <tt>unsigned char</tt> there.</li>
      <li>PBrett stated that the issue with the object model must be solved in
          order to specify a zero cost abstraction.</li>
      <li>Hubert explained that there is a trade off; using both
          <tt>wchar_t</tt> and <tt>char16_t</tt> increases costs, but the
          latter provides encoding and portability guarantees.</li>
      <li>PBrett opined that this suggests that use of the UTF character types
          is not zero cost.</li>
      <li>Jens responded that C++ opted to add those types as fundamental types
          in order to support overload resolution.</li>
      <li>Hubert explained the competing costs; restricting aliasing improves
          performance at the cost of having to workaround the type system.</li>
      <li>Jens noted that <tt>memcpy()</tt> can be used to workaround the type
          system.</li>
      <li>Tom noted that <tt>memcpy()</tt> can even be optimized away in some
          cases.</li>
      <li>PBrett pondered whether the abstractions adopted for UTF character
          types were the right choice and noted that a library facility could
          have provided the same encoding guarantees while using <tt>char</tt>
          internally.</li>
      <li>Tom explained that doing so wasn't an option for <tt>char8_t</tt>
          since UTF-8 string literals were already part of the core
          language.</li>
      <li>Steve explained that we use the type system to annotate how a block
          of memory is used and that <tt>char8_t</tt> provided the ability to
          annotate a block of memory as holding UTF-8 data.</li>
      <li>Steve asserted that making the UTF character types aliasing types
          would impose costs like those he has seen with code that loops over
          <tt>std::byte</tt>; the aliasing behavior hurts code generation.</li>
      <li>Steve noted that there are good libraries available that do use
          <tt>char</tt> and translate between code units and code points.</li>
      <li>Corentin stated that the choice to make <tt>char8_t</tt> a
          non-aliasing type was intentional and that any such change would
          further harm adoption.</li>
      <li>Corentin asserted that a way to use <tt>char8_t</tt> with historic
          <tt>char</tt>-based interfaces is needed or it just won't get used,
          but we'll still be left with the problems that motivated its
          introduction in the first place.</li>
      <li>Corentin opined that strong types are needed to support the
          <a href="https://nedbatchelder.com/text/unipain/unipain.html#35">Unicode sandwich model</a>.</li>
      <li>Corentin expressed a belief that this is solvable, implementable,
          and therefore should be specified.</li>
      <li>Jens suggested that an alternative UTF-8 design could have been based
          on something like <tt>std::span&lt;char8_t&gt;</tt> over a sequence
          of <tt>unsigned char</tt>.</li>
      <li>Jens opined that code unit types are not particularly interesting
          since an individual code unit by itself conveys little meaning.</li>
      <li>Jens noted that the proposed library interfaces have rough edges and
          expressed skepticism regarding a need for anything UTF specific since
          the underlying functionality is not encoding dependent.</li>
      <li>Steve agreed that the desire expressed in the paper is a special case
          of the problem where we want to get objects of one type out of a
          region of memory that holds objects of another type.</li>
      <li>Steve also agreed that the underlying storage for a text type is not
          interesting; the interface provided is.</li>
      <li>Steve noted that none of the suggested library solutions would have
          avoided the string literal concerns.</li>
      <li>Hubert provided a list of what he termed "a few uncomfortable facts":
        <ul>
          <li>Reading object representations is allowed but the existing
              wording is not satisfactory and fixing it will be hard.</li>
          <li>Implementations don't always follow the standard; for example,
              Clang's support for placement new is non-conforming.</li>
          <li>Implementations sometimes implement behavior that can't be
              expressed in the standard.</li>
          <li>Determining that wording is sufficient requires that multiple
              implementations are completed based on the wording.</li>
        </ul>
      </li>
      <li>Corentin, referring to earlier discussion regarding the possibility
          of making <tt>start_lifetime_as_array</tt> constexpr, noted that,
          since the memory location is provided by a parameter of type
          <tt>void*</tt>, any original source object type information is not
          present.</li>
    </ul>
  </li>
  <li>Tom reported that the Unicode Source Code Ad Hoc Group suggested that
      SG16 author a paper to discuss the issues that have been reported
      following adoption of
      <a href="https://wg21.link/p1949">P1949</a>
      for C++23 as a defect report and the migration from
      <a href="https://unicode.org/reports/tr31/#Immutable_Identifier_Syntax">immutable identifier syntax</a>
      to
      <a href="https://unicode.org/reports/tr31/#Default_Identifier_Syntax">default identifier syntax</a>
      in order to assist implementors with migration techniques, particularly
      in light of the intent for a future Unicode standard to introduce to
      default identifiers some currently excluded characters that are included
      in immutable identifiers.
    <ul>
      <li>Jens stated that he would like to understand more about the issues
          reported and requested that it be added to the agenda for a future
          meeting.</li>
      <li>Hubert expressed an interest in understanding more about the
          discussion going on between WG21 and the Unicode Consortium.</li>
      <li>Steve volunteered to add writing such a paper to his todo list.</li>
      <li>Tom said he would file an SG16 issue to track the reported issues
          and submission of a paper.</li>
      <li><em>[ Editor's note: Tom filed
          <a href="https://github.com/sg16-unicode/sg16/issues/79">SG16 issue #79</a>.
          ]</em></li>
    </ul>
  </li>
  <li>Tom stated that the next SG16 meeting is scheduled for September 14th
      and will likely include further discussion of
      <a href="https://wg21.link/p2626r0">P2626R0</a>
      and the above requests for more information about the identifier issues
      and collaboration with the Unicode Consortium.</li>
</ul>


<h1 id="2022_09_14">September 14th, 2022</h1>

<h2>Draft agenda:</h2>

<ul>
  <li>Report on the on-going interactions between WG21 and the Unicode
      Consortium.</li>
  <li>Report on the backward compatibility impact of
      <a href="https://wg21.link/p1949">P1949 (C++ Identifier Syntax using Unicode Standard Annex 31)</a>.</li>
  <li>Continued discussion of
      <a href="https://wg21.link/p2626r0">P2626R0: charN_t incremental adoption: Casting pointers of UTF character types</a>.</li>
</ul>

<h2>Attendees:</h2>

<ul>
  <li>Corentin Jabot</li>
  <li>Hubert Tong</li>
  <li>Mark Davis</li>
  <li>Michael Kuperstein</li>
  <li>Peter Bindels</li>
  <li>Robin Leroy</li>
  <li>Steve Downey</li>
  <li>Tom Honermann</li>
  <li>Victor Zverovich</li>
</ul>

<h2>Meeting summary:</h2>

<ul>
  <li>A round of introductions was held in honor of new attendees.</li>
  <li>Report on the on-going interactions between WG21 and the Unicode
      Consortium:
    <ul>
      <li>Tom provided an introduction and presented prepared slides.</li>
      <li><em>[ Editor's note: Tom's slides are available at
          <a href="https://github.com/sg16-unicode/sg16-meetings/blob/master/presentations/2022-09-14-WG21-UC-collab-p1949-presentation.odp">https://github.com/sg16-unicode/sg16-meetings/blob/master/presentations/2022-09-14-WG21-UC-collab-p1949-presentation.odp</a>.
          ]</em></li>
      <li>Unicode Message Format Working Group (MFWG):
        <ul>
          <li>Tom presented his understanding of the group's progress as
              previously relayed to him by Peter Brett as Peter was unable to
              attend the meeting.
            <ul>
              <li>Progress is on-going.</li>
              <li>A draft specification is available.</li>
              <li>The specification is complicated.</li>
              <li>The features provided subsume those currently available in
                  ICU.</li>
              <li>Implementations are available in Javascript and Rust.</li>
              <li>The design might not integrate well with
                  <tt>std::format()</tt>.</li>
            </ul>
          </li>
          <li>Mark elaborated on the group's work.
            <ul>
              <li>A tech preview will be available in an upcoming release of
                  ICU; In Java first with C++ support to come later.</li>
              <li>The current specification (2.0) supercedes previous work.</li>
              <li>The design is intended to minimize dynamic processing.</li>
              <li>In support of higher level processes, the design enables
                  formatting to a data model that is then formatted to a
                  string.</li>
              <li>Formatting is sensitive to surrounding characters.</li>
            </ul>
          </li>
          <li>Robin stated that, with regard to dynamic and static formatting
              models, the previous 1.0 specification could be used to produce
              a statically checked implementation via code generation.</li>
          <li>Michael noted that most formatting needs involve simple cases and
              that the interfaces provided must support difficult cases without
              complicating the simple cases.</li>
          <li>Mark replied that making simple things simple is a goal, but that
              challenges naturally arise.</li>
          <li>Mark provided an example of such challenges; some languages have
              gendered forms of sentences that should be tailored for the
              user.</li>
          <li>Mark further emphasized the desire to cater to those cases while
              maintaining simplicity.</li>
          <li>Tom noted an implication; that locale is insufficient by itself
              for producing a message; information about the recipient is
              needed.</li>
          <li>Mark acknowledged, but noted that gender should not be imposed;
              formatting should reflect the diversity of recipients.</li>
          <li>Michael reflected on how these concerns are expressed in social
              media.</li>
          <li>Mark noted the concerns apply in any case where a particular user
              is the target of a message.</li>
          <li>Mark added that western speakers are not often aware of these
              concerns.</li>
        </ul>
      </li>
      <li>Unicode Source Code Ad Hoc Group (SCWG):
        <ul>
          <li>Tom presented the group's progress and on-going activities.
            <ul>
              <li>The group started meeting in late 2021.</li>
              <li>A liaison relationship between ISO SC22 and the Unicode
                  Consortium might be established.</li>
              <li>Proposed updates to
                  <a href="https://www.unicode.org/reports/tr9/tr9-46.html">UAX #9</a>
                  and
                  <a href="https://www.unicode.org/reports/tr31/tr31-37.html">UAX #31</a>
                  were accepted for Unicode 15.</li>
              <li>On-going work includes:
                <ul>
                  <li>Establishing principles for source code as text.</li>
                  <li>Considerations for language designers.</li>
                  <li>A new UTS.</li>
                </ul>
              </li>
              <li>A new group will be formed to focus on issues of character
                  confusability.</li>
            </ul>
          </li>
          <li>Mark commented that the updates adopted for Unicode 15 were done
              to address some fairly obvious deficiencies.</li>
          <li>Robin categorized the updates as non-normative
              clarifications.</li>
          <li>Steve stated that
              <a href="http://eel.is/c++draft/uaxid">annex E</a>
              should be updated to reflect these clarifications.</li>
          <li>Steve noted such an update would only modify non-normative
              wording.</li>
          <li>Hubert cautioned that the updates must be consistent with prior
              intent and noted there was a desire not to speculate on uncertain
              interpretations at the time.</li>
          <li>Hubert stated that we tend to favor normative text when there is
              a conflict with non-normative text.</li>
          <li>Mark noted that non-normative text may better explain the intent
              of normative wording.</li>
          <li>Robin described in more detail some of the on-going work:
            <ul>
              <li>There will be a new UTS that will be a one-stop shop for
                  source code.</li>
              <li>Much of the focus concerns display of source code in the
                  presence of bidirectional text or invisible characters.</li>
              <li>Considerations for language design.</li>
              <li>Considerations for language evolution; for example, migrating
                  a language from immutable identifiers to default
                  identifiers.</li>
            </ul>
          </li>
          <li>Mark explained the intent to define a suite of standard profiles
              that language designers can choose from in order to provide a
              simple set of options that encompass complicated concerns.</li>
          <li>Corentin noted that most language designers are not qualified to
              determine what characters should be used for what purposes and
              that it is important to understand the consequences of
              changes.</li>
          <li>Corentin expressed a desire for the Unicode Consortium to make
              decisions about character use; for example, for what characters
              are allowed in an identifier.</li>
          <li>Mark reiterated that the goal is to make choices as easy as
              possible.</li>
          <li>Mark noted that language designers have to make choices for
              backward compatibility purposes and provided the example of
              maintaining use of '_' in identifiers.</li>
          <li>Mark explained that providing well-defined profiles allows
              language designers to better understand the implications of
              combining profiles.</li>
          <li>Mark stated that some profiles will offer the option of removing
              characters that are otherwise in a default included set.</li>
          <li>Robin acknowledged Corentin's concern and agreed with not wanting
              language designers to be burdened with having to consider
              individual characters.</li>
          <li>Robin stated that characters in these profiles won't be added to
              <tt>XID_Start</tt> and <tt>XID_Continue</tt> because those
              properties are required to be universal.</li>
          <li>Tom noted that this work was partially motivated by the C++
              migration from immutable identifiers to default identifiers and
              the effort required to appreciate the consequences.</li>
          <li>Mark reflected on the difficulties encountered by backward
              incompatible changes made for XML 2.0 relating to C1 control
              characters.</li>
          <li>Robin offered assurances that a new UAX #31 revision will make
              the consequences of such choices more clear.</li>
          <li>Steve noted limitations imposed by concerns we don't have control
              over and provided the examples of separate compilation and
              linkers; identifiers might be written in normalization form C
              (NFC) but a linker might just interpret it as a sequence of
              bytes.</li>
          <li>Mark responded that requiring NFC is a good solution for a lot of
              matching cases that also arise outside of programming
              languages.</li>
          <li>Robin lamented the problems that occur by burdening users with
              NFC requirements and asserted that programmers can help.</li>
          <li>Steve noted that programs can validate NFC quickly.</li>
          <li>Mark agreed and noted that hits to the slow path during NFC
              validation are infrequent.</li>
          <li>Tom stated that the Unicode Consortium will form a new group to
              address character confusability in order to take that security
              burden off the programmer.</li>
          <li>Mark responded that the Unicode Standard provides some data
              regarding confusable characters but is limited to cases where
              glyphs for a single code point might be confused with a sequence
              of multiple code points; maps between code point sequences are
              not currently provided.</li>
          <li>Mark noted that confusability is often dependent on the font
              being used, that programming languages tend to use a reduced set
              of characters, and that programmers tend to use fonts that avoid
              some confusability issues.</li>
          <li>Robin explained that major changes to confusability analysis will
              be handled by the new group and that smaller issues will likely
              follow the existing processes.</li>
          <li>Michael asked if the confusability work will focus more on
              usability or security.</li>
          <li>Mark responded that both are important and that improving one
              often helps with the other.</li>
          <li>Corentin mentioned that visual markup for confusability can impact
              usability and noted that VS Code currently highlights all
              non-ASCII characters.</li>
          <li>Mark acknowledged the concern and stated that efforts will be
              focused on avoiding markup that isn't helpful.</li>
          <li>Robin commented that he has a note in his working draft that
              states "don't do what VS Code does".</li>
          <li>Mark suggested a thought exercise; imagine using an editor that
              highlights all Latin characters that look like characters in
              other lanugages.</li>
          <li>Robin explained that mixed script identifier support is important
              and provided <tt>HTTP_&lt;russion-identifier&gt;</tt> as an
              example in which an identifier is composed of names that
              originate from different languages.</li>
          <li>Michael expressed support for a code library that provides
              confusability analysis.</li>
          <li>Mark replied that ICU provides confusability data but noted that
              application of that data necessarily requires understanding text
              structure.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Report on the backward compatibility impact of
      <a href="https://wg21.link/p1949">P1949 (C++ Identifier Syntax using Unicode Standard Annex 31)</a>:
    <ul>
      <li>Tom provided an introduction.
        <ul>
          <li><a href="https://github.com/sg16-unicode/sg16/issues/79">SG16 issue #79</a>
              tracks reports of backward compatibility impact.</li>
          <li><a href="https://github.com/llvm/llvm-project/issues/54732">Clang defect report #54732</a>
              tracks Clang user reports; four users have reported impact, but
              the number of projects represented by them is unknown.</li>
          <li>Robin maintains code that was impacted.</li>
          <li>Robin conducted a survey of character usage in identifiers and
              published
              <a href="https://www.unicode.org/L2/L2022/22102-non-xid-ident-usage.pdf">L2/22-102 (A survey of non-XID identifier usage in program text)</a>.</li>
        </ul>
      </li>
      <li>Robin explained that his code that was impacted is in a hobby
          project.</li>
      <li>Robin described the survey he conducted and reported that it
          identified impacted code in a number of projects.</li>
      <li>Robin reported that the SCWG intends to provide standard profiles
          for optional inclusion of select mathematical symbols and emoji in
          identifiers.</li>
      <li>Robin noted that the main character differences between immutable and
          default identifiers is the selection of allowed mathematical symbols
          and emoji characters.</li>
      <li>Corentin expressed concern that, if C++ were to add support for
          user-defined operators as Swift did, we don't want to end up in a
          situation where characters previously allowed in identifiers become
          candidates for use as operators.</li>
      <li>Robin reiterated that there is no intent to add these characters to
          <tt>XID_Start</tt> or <tt>XID_Continue</tt>; that they are only being
          considered for standard profiles.</li>
      <li>Robin reported that character reviews are being performed by other
          members of the Unicode Consortium and that those reviews are
          considering existing use; for example, those reviews are considering
          the use of mathematical symbols in Julia and which ones are used for
          which purposes.</li>
      <li>Steve expressed sympathy towards use of mathematical symbols in
          Mathematica and that doing similarly in C++ means using those symbols
          in identifiers since algorithms are typically implemented as
          functions in C++.</li>
      <li>Steve stated that the subscript and superscript characters are
          problematic since many fonts don't support those characters.</li>
      <li>Michael asked what motivates programmers to want their code to look
          like mathematical equations.</li>
      <li>Steve responded that, in mathematics heavy fields like physics
          simulation, it is desirable for the code to match equations in other
          documents.</li>
      <li>Michael expressed uncertainty whether that is reasonable and reported
          that his closest experience has involved equations in
          Mathematica.</li>
      <li>Michael noted that typesetting languages like TeX are able to render
          such characters appropriately but that he wasn't sure about common
          programming language editors.</li>
      <li>Steve responded that such concerns may be limited if code is not
          widely shared or reused.</li>
      <li>Steve asserted that depending on a finicky environment is
          ill-advised.</li>
      <li>Corentin expressed a belief that language designers don't want to
          make such decisions and that implementors should not offer such
          extensions.</li>
      <li>Tom responded that different recommendations are appropriate for,
          for example, general purpose languages vs domain specific ones.</li>
      <li>Corentin agreed.</li>
      <li>Steve stated that defining standard profiles helps to provide
          sensible options.</li>
      <li>Steve suggested that profiles also provide a clearly defined feature
          for which implementors can be lobbied for an extension that could
          then be standardized based on adoption.</li>
      <li>Hubert replied that common extensions are not necessarily good
          evidence of widely used or appreciated extensions.</li>
      <li>Steve agreed with not wanting to make decisions on individual
          characters; that an appeal to authority is desired.</li>
      <li>Robin agreed with not placing the burden of evaluating individual
          characters on language designers.</li>
      <li>Corentin asked about the anticipated timeline for this work.</li>
      <li>Robin responded that a draft is expected in November, that feedback
          from the UTC will then be provided, and that the work is targeting
          next September's Unicode release.</li>
    </ul>
  </li>
  <li><a href="https://wg21.link/p2626r0">P2626R0: charN_t incremental adoption: Casting pointers of UTF character types</a>:
    <ul>
      <li>Tom apologized for the lack of time available to continue discussion
          of this paper.</li>
    </ul>
  </li>
  <li>Tom stated that the next meeting will be held on September 28th and asked
      for opinions regarding what to prioritize next.
    <ul>
      <li>Corentin replied that continued discussion of P2626 is not a high
          priority right now.</li>
      <li>Corentin stated that there is a need to update the standard to use
          and reference the current Unicode version.</li>
      <li>Corentin stated that work is needed to improve estimated field
          widths.</li>
      <li>Corentin stated that the escape string format added via
          <a href="https://wg21.link/p2286">P2286 (Formatting Ranges)</a>
          needs additional work to handle combining characters in extended
          grapheme clusters.</li>
      <li>Hubert cautioned that concern is warranted regarding debug strings
          getting corrupted during copy/paste operations.</li>
      <li>Steve stated that Bloomberg will be filing an NB comment to update
          annex E.</li>
      <li>Hubert stated that he will be filing an NB comment about
          <tt>std::format()</tt> debug strings.</li>
      <li>Tom pondered the possibility of requesting that NB comment authors
          send copies of relevant NB comments to us when they submit them so
          that we can start work on them sooner.</li>
      <li><em>[ Editor's note: Tom reached out to Herb and he arranged for all
          SGs to get early access to NB comments. ]</em></li>
      <li>Tom reported that the next meeting will focus on LWG issues and that
          the following meeting will likely include a presentation from
          Michael.</li>
    </ul>
  </li>
</ul>


</body>
