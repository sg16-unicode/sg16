<!doctype html public "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">

<head>
<title>SG16: Unicode meeting summaries 2023-05-24 through 2023-07-12</title>
</head>

<style type="text/css">

table#header th,
table#header td
{
    text-align: left;
}

tt {
    font-family: monospace;
}

/* Thanks to Elias Kosunen for the following CSS suggestions! */

* {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
    line-height: 125%;
}

html, body {
    background-color: #eee;
}

h1, h2, h3, h4, h5, p, span, li, dt, dd {
    color: #333;
}

p, li {
    line-height: 140%;
}

body {
    padding: 1em;
    max-width: 1600px;
}

p, li {
    -moz-osx-font-smoothing: grayscale;
    -webkit-font-smoothing: antialiased !important;
    -moz-font-smoothing: antialiased !important;
    text-rendering: optimizelegibility !important;
    letter-spacing: .01em;
}

h1, h2, h3 {
    margin-bottom: 1em;
    letter-spacing: .03em;
}

blockquote.quote
{
    margin-left: 0em;
    border-style: solid;
    background-color: lemonchiffon;
    color: #000000;
    border: 1px solid black;
}

</style>

<body style="max-width: 8.5in">

<table id="header">
  <tr>
    <th>Document Number:</th>
    <td>DXXXXR0 <em>Draft</em></td>
  </tr>
  <tr>
    <th>Date:</th>
    <td>2023-09-06</td>
  </tr>
  <tr>
    <th>Audience:</th>
    <td>SG16</td>
  </tr>
  <tr>
    <th>Reply-to:</th>
    <td>Tom Honermann &lt;tom@honermann.net&gt;</td>
  </tr>
</table>


<h1>SG16: Unicode meeting summaries 2023-05-24 through 2023-07-12</h1>

<p>
Summaries of SG16 meetings are maintained at
<a href="https://github.com/sg16-unicode/sg16-meetings">
https://github.com/sg16-unicode/sg16-meetings</a>.  This paper contains a
snapshot of select meeting summaries from that repository.
</p>

<ul>
  <li><a href="#2023_05_24">
      May 24th, 2023</a></li>
  <li><a href="#2023_06_07">
      June 7th, 2023</a></li>
  <li><a href="#2023_07_12">
      July 12th, 2023</a></li>
</ul>

<p>
Previously published SG16 meeting summary papers:
<ul>
  <li><a href="https://wg21.link/p1080">P1080: SG16: Unicode meeting summaries 2018/03/28 - 2018/04/25</a></li>
  <li><a href="https://wg21.link/p1137">P1137: SG16: Unicode meeting summaries 2018/05/16 - 2018/06/20</a></li>
  <li><a href="https://wg21.link/p1237">P1237: SG16: Unicode meeting summaries 2018/07/11 - 2018/10/03</a></li>
  <li><a href="https://wg21.link/p1422">P1422: SG16: Unicode meeting summaries 2018/10/17 - 2019/01/09</a></li>
  <li><a href="https://wg21.link/p1666">P1666: SG16: Unicode meeting summaries 2019/01/23 - 2019/05/22</a></li>
  <li><a href="https://wg21.link/p1896">P1896: SG16: Unicode meeting summaries 2019/06/12 - 2019/09/25</a></li>
  <li><a href="https://wg21.link/p2009">P2009: SG16: Unicode meeting summaries 2019-10-09 through 2019-12-11</a></li>
  <li><a href="https://wg21.link/p2179">P2179: SG16: Unicode meeting summaries 2020-01-08 through 2020-05-27</a></li>
  <li><a href="https://wg21.link/p2217">P2217: SG16: Unicode meeting summaries 2020-06-10 through 2020-08-26</a></li>
  <li><a href="https://wg21.link/p2253">P2253: SG16: Unicode meeting summaries 2020-09-09 through 2020-11-11</a></li>
  <li><a href="https://wg21.link/p2352">P2352: SG16: Unicode meeting summaries 2020-12-09 through 2021-03-24</a></li>
  <li><a href="https://wg21.link/p2397">P2397: SG16: Unicode meeting summaries 2021-04-14 through 2021-05-26</a></li>
  <li><a href="https://wg21.link/p2512">P2512: SG16: Unicode meeting summaries 2021-06-09 through 2021-12-15</a></li>
  <li><a href="https://wg21.link/p2605">P2605: SG16: Unicode meeting summaries 2022-01-12 through 2022-06-08</a></li>
  <li><a href="https://wg21.link/p2678">P2678: SG16: Unicode meeting summaries 2022-06-22 through 2022-09-28</a></li>
  <li><a href="https://wg21.link/p2766">P2766: SG16: Unicode meeting summaries 2022-10-12 through 2022-12-14</a></li>
  <li><a href="https://wg21.link/p2891">P2891: SG16: Unicode meeting summaries 2023-01-11 through 2023-05-10</a></li>
</ul>
</p>


<h1 id="2023_05_24">May 24th, 2023</h1>

<h2>Draft agenda:</h2>

<ul>
  <li><a href="https://wg21.link/p2779r0">P2779R0: Make basic_string_view’s range construction conditionally explicit</a>.</li>
  <li><a href="https://wg21.link/p2863r0">P2863R0: Review Annex D for C++26</a>.</li>
  <li><a href="https://wg21.link/p2871r0">P2871R0: Remove Deprecated Unicode Conversion Facets From C++26</a>.</li>
  <li><a href="https://wg21.link/p2873r0">P2873R0: Remove Deprecated Locale Category Facets For Unicode from C++26</a>.</li>
  <li><a href="https://wg21.link/p2872r0">P2872R0: Remove wstring_convert From C++26</a>.</li>
</ul>

<h2>Attendees:</h2>

<ul>
  <li>Alisdair Meredith</li>
  <li>Charlie Barto</li>
  <li>Corentin Jabot</li>
  <li>Eddie Nolan</li>
  <li>Fraser Gordon</li>
  <li>Giuseppe D'Angelo</li>
  <li>Jens Maurer</li>
  <li>Mark de Wever</li>
  <li>Mark Zeren</li>
  <li>Peter Bindels</li>
  <li>Peter Brett</li>
  <li>Robin Leroy</li>
  <li>Tom Honermann</li>
  <li>Victor Zverovich</li>
  <li>Zach Laine</li>
</ul>

<h2>Meeting summary:</h2>

<ul>
  <li><a href="https://wg21.link/p2779r0">P2779R0: Make basic_string_view’s range construction conditionally explicit</a>:
    <ul>
      <li>Giuseppe presented an overview of the paper including relevant
          history:
        <ul>
          <li><a href="https://wg21.link/p1989">P1989R2 (Range constructor for std::string_view 2: Constrain Harder)</a>
              added an implicit <tt>std::string_view</tt> constructor that
              enables implicit conversion from any type that satisfies a set of
              constraints, one of which includes having a member type alias
              named <tt>traits_type</tt> that matches the
              <tt>std::string_view</tt> member of the same name.</li>
          <li><a href="https://wg21.link/p2499">P2499R0 (string_view range constructor should be explicit)</a>
              changed the new constructor to be declared <tt>explicit</tt> due
              to concerns involving ranges that do or do not contain an
              embedded null character; this broke the ability for string types
              to implicitly convert to <tt>std::string_view</tt>.</li>
          <li><a href="https://wg21.link/lwg3857">LWG 3857</a>
              removed the constraint requiring a matching <tt>traits_type</tt>
              member type alias based on the rationale that such a safety
              precaution is no longer necessary since conversions are now
              explicit.</li>
          <li>The proposed paper seeks to conditionally restore implicit
              conversions for string-like types without requiring modifications
              to those types to add conversion operators.</li>
          <li>Two options are proposed:
            <ul>
              <li>Option 1 adds an opt-in trait and makes the constructor
                  conditionally explicit based on the presence of a matching
                  member <tt>traits_type</tt> type alias.</li>
              <li>Option 2 makes the constructor conditionally explicit based on
                  the presence of a matching member <tt>traits_type</tt> type
                  alias without requiring an opt-in trait.</li>
            </ul>
          </li>
          <li>Qt has provided a <tt>QStringView</tt> class with an
              <a href="https://doc.qt.io/qt-6/qstringview.html#QStringView-7">implicit constructor that accepts a range</a>
              that has worked well in practice for a decade.</li>
        </ul>
      </li>
      <li>PBrett asked what the essential nature of a string-like type is.</li>
      <li>Giuseppe responded that it is a contiguous sequence of characters
          and associated character classification traits.</li>
      <li>PBrett argued for substitution of "code units" for "characters".</li>
      <li>Zach noted that the <tt>traits_type</tt> name might be used by types
          that are not string-like types, stated that he does not typically add
          a <tt>traits_type</tt> to his own string-like types, and asked what is
          commonly done in practice.</li>
      <li>Giuseppe responded that the paper lists the results of a survey of
          various projects for occurrences of the <tt>traits_type</tt> name and
          found that it is strongly correlated with string-like types but that
          there are string-like types that don't have such a member.</li>
      <li>Giuseppe acknowledged that the <tt>traits_type</tt> name is quite
          generic.</li>
      <li>Victor expressed opposition to option 2 since it relies on what he
          considers to be a legacy feature and that <tt>traits_type</tt> is, in
          practice, always <tt>std::char_traits</tt>.</li>
      <li>Victor asserted that implicit conversions and implicit interoperation
          with the standard library are not desired for Folly's
          <tt>fbstring</tt>.</li>
      <li>Victor stated that he is ok-ish with option 1.</li>
      <li>Tom asked Victor to further explain his concerns and the damage he
          fears the implicit conversions would cause.</li>
      <li>Victor replied that use of <tt>fbstring</tt> is no longer encouraged
          and the proposed change would facilitate continued usage.</li>
      <li>Victor noted that the proposed changes could also impact overload
          resolution in generic code and potentially introduce overload
          resolution failures due to ambiguity.</li>
      <li>Corentin lamented the ability for programmers to specialize
          <tt>std::char_traits</tt> for their own user-defined types and stated
          he plans to propose deprecating or removing that allowance.</li>
      <li>Corentin explained that the interface that <tt>std::char_traits</tt>
          provides is not a good match for how text processing works in
          practice.</li>
      <li>Corentin asserted that increased use of <tt>std::char_traits</tt>
          should be discouraged.</li>
      <li>Corentin opined that option 1 is fine but that option 2 is
          problematic in the long run.</li>
      <li>Giuseppe acknowledged Corentin's position.</li>
      <li>Corentin clarified that programmers should not be encouraged to use
          a different type than <tt>std::char_traits</tt> but rather that they
          should be encouraged not to use a char-traits-like type at all.</li>
      <li>Tom summarized his understanding of the concerns; the proposed change
          could encourage programmers to add a <tt>traits_type</tt> member type
          alias of <tt>std::char_traits</tt> to classes that otherwise wouldn't
          define the type alias solely to enable implicit conversions to
          <tt>std::string_view</tt>.</li>
      <li>Zach argued for not enabling such implicit conversions at all on the
          basis that <tt>std::string_view</tt> is intended to be implicitly
          convertible from other standard library types and that explicit
          conversions are appropriate elsewhere.</li>
      <li>Alisdair opined that the right approach would be for types to opt
          themselves in to an implicit conversion.</li>
      <li>Alisdair asserted that <tt>std::char_traits</tt> is not legacy and
          that it cannot be removed without significant ABI impact.</li>
      <li>Alisdair stated that the matching <tt>traits_type</tt> constraint is
          a good heuristic and that the opt-in trait in option 1 is so specific
          that he would have a hard time supporting it.</li>
      <li>Jens noted that the proposed wording for option 1 requires both the
          opt-in string-like-type trait and the matching <tt>traits_type</tt>
          constraint to enable implicit conversions.</li>
      <li>Jens expressed a preference for an option that proposed only the
          string-like-type trait.</li>
      <li>Jens stated that the wording needs to be rebased on the current
          working paper since the struck wording has already been removed.</li>
      <li>Jens suggested <tt>is_string_view_like</tt> might not be the best
          choice of name for the opt-in trait and suggested <tt>enable_view</tt>
          as an example name for similar opt-in traits.</li>
      <li>Giuseppe acknowledged the suggestion and stated that the name can be
          changed.</li>
      <li>Jens noted that it doesn't matter how string-view-like the source type
          is as long as it provides contiguous storage and opts itself in.</li>
      <li>Jens agreed with not wanting to encourage the addition of an otherwise
          unused <tt>traits_type</tt> member.</li>
      <li>Jens observed that <tt>is_string_view_like</tt> is false by
          default.</li>
      <li>Jens suggested that, if it is desirable to provide a safety check on a
          matching <tt>traits_type</tt> member, that the
          <tt>is_string_view_like</tt> trait can support a mechanism to enable
          that.</li>
      <li>Jens expressed a preference for postponing a poll to forward the paper
          until it has been rebased on the current working paper.</li>
      <li>Various poll options were discussed but it was decided that polling be
          postponed pending an updated paper revision with wording rebased on
          the current working paper and an additional option to enable implicit
          conversions based solely on the opt-in trait.</li>
    </ul>
  </li>
  <li><a href="https://wg21.link/p2863r0">P2863R0: Review Annex D for C++26</a>:
    <ul>
      <li>Alisdair introduced this and the following papers.</li>
      <li>Tom explained his understanding of the ramifications for removal of
          standard library features; that an implementor may choose not to
          provide the removed features or may choose to provide them since the
          removed names are reserved as "zombie" names.</li>
      <li>Alisdair acknowledged the intent, but noted that the standard
          currently lacks wording to support zombification of explicit template
          specializations.</li>
      <li>Alisdair explained that there are four deprecated subclauses that are
          relevant to SG16;
          <a href="http://eel.is/c++draft/depr.locale.stdcvt">D.26 ([depr.locale.stdcvt])</a>,
          <a href="http://eel.is/c++draft/depr.conversions">D.27 ([depr.conversions])</a>,
          <a href="http://eel.is/c++draft/depr.locale.category">D.28 ([depr.locale.category])</a>,
          and
          <a href="http://eel.is/c++draft/depr.fs.path.factory">D.29 ([depr.fs.path.factory])</a>.</li>
      <li>PBindels stated that
          <a href="http://eel.is/c++draft/depr.str.strstreams">D.15 ([depr.str.strstreams])</a>
          and
          <a href="http://eel.is/c++draft/depr.string.capacity">D.25 ([depr.string.capacity])</a>
          have to do with text facilities but that he reviewed them and
          concluded that the functionality is not strongly relevant for
          SG16.</li>
      <li>Alisdair stated that, for <tt>std::filesystem::u8path</tt>, per
          <a href="https://wg21.link/lwg3840">LWG 3840</a>,
          there have been recent comments that removal would be
          problematic.</li>
      <li>Tom stated that the LWG issue was recently discussed in LEWG but that
          the LWG issue does not appear to have been updated to reflect that
          discussion.</li>
      <li><em>[ Editor's note: LEWG discussed the LWG issue during its
          <a href="https://wiki.edg.com/bin/view/Wg21telecons2023/LWG3840">2023-01-10 telecon</a>.
          ]</em></li>
      <li>Alisdair stated that deprecated features should either be undeprecated
          or removed and noted that this feature has been deprecated since
          C++20.</li>
      <li>Jens expressed concern regarding Billy O'Neal's comment in the LWG
          issue that deprecation of <tt>u8path</tt> was one of the reasons that
          vcpkg discontinued use of <tt>std::filesystem</tt>.</li>
      <li>Jens stated that SG16 should offer an opinion.</li>
      <li>Corentin replied that there was a poll in LEWG in January and that
          there was no consensus to undeprecate <tt>u8path</tt>.</li>
      <li>Corentin stated that a mechanism to access a sequence of <tt>char</tt>
          that holds UTF-8 code units as-if it were a sequence of
          <tt>char8_t</tt> is a feature that we should have; we're missing a way
          to pass such a sequence to the <tt>std::filesystem::path()</tt>
          constructor such that it is interpreted as UTF-8.</li>
      <li>Tom noted that Corentin has a paper on that topic.</li>
      <li><em>[ Editor's note: See
          <a href="https://wg21.link/p2626">P2626 (charN_t incremental adoption: Casting pointers of UTF character types)</a>.
          ]</em></li>
      <li>Alisdair noted that, if removed, <tt>u8path</tt> would be added to the
          list of zombie names, so implementors that wish to continue providing
          it may do so.</li>
      <li>PBindels opined that <tt>u8path</tt> provides a solution to work
          around legacy issues but that Corentin's P2626 provides a proper
          solution.</li>
      <li>PBindels suggested that we should neither undeprecate nor remove
          <tt>u8path</tt> until a proper solution is in place.</li>
      <li>Alisdair stated that he can update the paper to reflect that guidance
          and to note further action as dependent on P2626.</li>
      <li>Charlie agreed with not removing <tt>u8path</tt> without a proper
          alternative.</li>
      <li>Charlie noted that, if <tt>u8path</tt> is zombified, that implementors
          can continue to provide it, but that portability is lost.</li>
      <li>Charlie stated that he didn't see a reason to remove <tt>u8path</tt>;
          that it isn't harmful.</li>
      <li>Alisdair acknowledged that a migration path is needed.</li>
      <li>Tom explained that the original motivation for deprecation was to
          dissuade continuing to provide standard library functions that require
          UTF-8 data in <tt>char</tt>-based storage.</li>
      <li>Tom noted that <tt>u8path</tt> and the deprecated
          <tt>std::codecvt</tt> facets were the only standard library features
          that did so.</li>
    </ul>
  </li>
  <li><a href="https://wg21.link/p2871r0">P2871R0: Remove Deprecated Unicode Conversion Facets From C++26</a>:
    <ul>
      <li>Alisdair presented the paper:
        <ul>
          <li>These facets were deprecated because they did not provide error
              handling capabilities and could not reasonably be extended.</li>
          <li>There are some implementations that do not issue deprecation
              warnings.</li>
        </ul>
      </li>
      <li>Corentin noted the work in progress and general plan to provide
          replacements for C++26 and suggested waiting to remove them pending
          that work.</li>
      <li>Jens agreed and stated that removal without replacements is
          ill-advised unless these are actively causing harm.</li>
      <li>Tom noted that conversions are possible through the <tt>mbrtoc*</tt>
          and <tt>c*rtomb</tt> family of functions though those have their own
          issues.</li>
      <li>Victor stated that the <tt>codecvt</tt> facets are so challenging to
          use that not having a replacement isn't really a problem.</li>
      <li>Alisdair noted that implementors can continue to provide them thanks
          to zombification.</li>
      <li>Alisdair reported that, per the paper, LEWG and SG16 previously
          recommended removal during the C++23 cycle, but that action wasn't
          completed.</li>
      <li>Alisdair reminded the group that <tt>codecvt_utf</tt> and
          <tt>codecvt_utf1</tt> convert to and from UCS-2 or UTF-32 depending
          on the size of the first template parameter.</li>
      <li>PBrett asked for any objections to removal.</li>
      <li>No objections were reported.</li>
      <li>Alisdair stated he will take that feedback back to LEWG.</li>
    </ul>
  </li>
  <li><a href="https://wg21.link/p2873r0">P2873R0: Remove Deprecated Locale Category Facets For Unicode from C++26</a>:
    <ul>
      <li>Tom explained that these facets were deprecated because they convert
          to and from UTF-8 in <tt>char</tt>-based storage rather than between
          the multibyte encoding like the non-deprecated facets do.</li>
      <li>Tom reported that <tt>char8_t</tt>-based replacements were added as
          replacements, but those were a mistake because they won't be used by
          <tt>char</tt>-based streams anyway.</li>
      <li><em>[ Editor's note:
          <a href="https://wg21.link/lwg3767">LWG 3767</a>
          tracks deprecating the <tt>char8_t</tt>-based facets. ]</em></li>
      <li>PBrett asked for any objections to removal.</li>
      <li>No objections were reported.</li>
      <li>Corentin spoke in favor of removal.</li>
    </ul>
  </li>
  <li><a href="https://wg21.link/p2872r0">P2872R0: Remove wstring_convert From C++26</a>:
    <ul>
      <li>Giuseppe asked if the paper includes removal of
          <tt>std::wbuffer_convert</tt>.</li>
      <li>Alisdair confirmed that it does.</li>
      <li>Alisdair explained that these were deprecated because the example for
          <tt>std::wstring_convert</tt> used another deprecated feature,
          <tt>std::codecvt_utf8</tt> and, due to other underspecification
          concerns, noone was motivated to fix them.</li>
      <li>Alisdair asked if SG16 is the right group to address this.</li>
      <li>PBrett responded affirmatively and stated that SG16 is the group that
          misunderstands <tt>wchar_t</tt> the least.</li>
      <li>Alisdair noticed some issues with the paper and concluded that updates
          are required before the paper is ready for any action to be taken on
          it.</li>
    </ul>
  </li>
  <li>Tom stated that the next meeting is tentatively scheduled for 2023-06-07
      and will likely continue review of
      <a href="https://wg21.link/p2779">P2779 (Make basic_string_view’s range construction conditionally explicit)</a>
      and
      <a href="https://wg21.link/p2872">P2872 (Remove wstring_convert From C++26)</a>
      if updated revisions are available followed by an initial review of
      <a href="https://wg21.link/p2845">P2845 (Formatting of std::filesystem::path)</a>.</li>
  <li>Zach reported that he expects to have a new revision of
      <a href="https://wg21.link/p2728">P2728 (Unicode in the Library, Part 1: UTF Transcoding)</a>
      available soon after the Varna meeting.</li>
</ul>


<h1 id="2023_06_07">June 7th, 2023</h1>

<h2>Draft agenda:</h2>

<ul>
  <li><a href="https://wg21.link/p2779r1">P2779R1: Make basic_string_view’s range construction conditionally explicit</a>.</li>
  <li><a href="https://wg21.link/p2872r1">P2872R1: Remove wstring_convert From C++26</a>.</li>
  <li><a href="https://wg21.link/p2845r0">P2845R0: Formatting of std::filesystem::path</a>.</li>
</ul>

<h2>Attendees:</h2>

<ul>
  <li>Alisdair Meredith</li>
  <li>Charlie Barto</li>
  <li>Corentin Jabot</li>
  <li>Fraser Gordon</li>
  <li>Giuseppe D'Angelo</li>
  <li>Jens Maurer</li>
  <li>Mark de Wever</li>
  <li>Mark Zeren</li>
  <li>Peter Brett</li>
  <li>Tom Honermann</li>
  <li>Victor Zverovich</li>
  <li>Zach Laine</li>
</ul>

<h2>Meeting summary:</h2>

<ul>
  <li><a href="https://wg21.link/p2779r1">P2779R1: Make basic_string_view’s range construction conditionally explicit</a>.
    <ul>
      <li><em>[ Editor's note: D2779R1 was the active paper under discussion at
          the telecon.
          The agenda and links used here reference P2749R1 since the links to
          the draft paper were ephemeral.
          The published document may differ from the reviewed draft revision.
          ]</em></li>
      <li>Giuseppe summarized the paper and changes since the last revision:
        <ul>
          <li>The paper endeavors to identify a compromise position for the
              issues that have resulted in multiple changes to how the
              <tt>std::basic_string_view</tt> range constructor is
              specified.</li>
          <li>Option 2 from the previous revision is still present though there
              was not much support for this option in the last discussion.</li>
          <li>Option 1 follows existing precedent for type traits that enable
              some functionality; this option has been divided into two
              sub-options.</li>
          <li>Option 1-A provides a type trait that enables conversion without
              regard to the <tt>traits_type</tt> member.</li>
          <li>Option 1-B provides the type trait from option 1-A as well as an
              additional type trait that can be used to enable conversion that
              is sensitive to the <tt>traits_type</tt> member.</li>
        </ul>
      </li>
      <li>Tom asked if the intent is for the trait to be used only for
          conversion to <tt>std::string_view</tt> or for conversion to any
          string_view-like type.</li>
      <li>Giuseppe responded that it is intended to be used for conversion to
          any string_view-like type.</li>
      <li>Jens suggested in chat: "You can also define
          enable_string_view_conversion in a way so that the user specialization
          can compare char_traits, if so desired (or not)."</li>
      <li>Jens' suggestion received several positive responses.</li>
      <li>Alisdair, following up on Jens' suggestion in chat, asked if the
          traits in option 1-B could be merged.</li>
      <li>Giuseppe confirmed that they could be.</li>
      <li>Alisdair indicated that would be his preference.</li>
      <li>Alisdair stated that the conversion could be enabled based on a class
          member similar to how transparent key comparison for associative
          containers is enabled via the <tt>is_transparent</tt> member of the
          compare class.</li>
      <li>Giuseppe acknowledged that approach would work as well.</li>
      <li>Tom noted that approach would require modifying the class.</li>
      <li>Alisdair responded that the trait could still be specialized but could
          be defaulted based on the presence of a member.</li>
      <li>Jens stated that the most convenient option would be to define a
          conversion operator with the trait available as a fallback.</li>
      <li>Jens expressed a preference for a single trait with template
          parameters such that a specialization can be written to explicitly
          match <tt>traits_type</tt> or <tt>std::char_traits</tt> as
          desired.</li>
      <li>Jens noted that <tt>enable_string_view_conversion_with_traits</tt>
          still requires comparison with <tt>std::char_traits</tt> or a
          <tt>traits_type</tt> member.</li>
      <li>Jens suggested that third party string_view-like classes can provide
          their own trait to enable implicit conversions.</li>
      <li>Giuseppe responded that the goal is to enable interconvertibility
          between different string types.</li>
      <li>Giuseppe noted that the proposal doesn't require comparisons with
          specific type or member names.</li>
      <li>Zach stated that he doesn't find the problem that the paper intends
          to address compelling and noted that <tt>std::string_view</tt> is
          available as a vocabulary type.</li>
      <li>Zach noted that working around the lack of an implicit conversion
          just requires slightly more code; explicit construction of a
          <tt>std::string_view</tt> object.</li>
      <li>Victor requested that the two traits in option 1-B be merged.</li>
      <li>Victor agreed with Alisdair's suggestion to default the trait to
          enable based on the presence of a class member.</li>
      <li>Victor asserted that only the author of a class should opt a class
          into the proposed behavior; not users of the class.</li>
      <li>Victor repeated his opposition to enabling implicit third party
          interoperation.</li>
      <li>Corentin stated that most of the proposed behavior should be being
          discussed in LEWG rather than in SG16 and that SG16 just needs to
          provide a recommendation whether use of <tt>std::char_traits</tt>
          is a good heuristic.</li>
      <li>PBrett responded that there is an SG16 question concerning which
          types are sufficiently text-like.</li>
      <li>PBrett asked for poll suggestions.</li>
      <li>Tom noted that discussion revealed other options that should be
          explored.</li>
      <li>Tom suggested polling the desire to enable interconvertibility
          across any/all string-like types in the ecosystem.</li>
      <li>Poll wordsmithing ensued.</li>
      <li><b>Poll 1.1: Any opt-in to implicit range construction of
          <tt>std::string_view</tt> should be explicit on a per-type basis.</b>
        <ul>
          <li><b>Attendees: 12 (1 abstention)</b></li>
          <li>
            <table>
              <tr>
                <th style="text-align:right">SF</th>
                <th style="text-align:right">F</th>
                <th style="text-align:right">N</th>
                <th style="text-align:right">A</th>
                <th style="text-align:right">SA</th>
              </tr>
              <tr>
                <th style="text-align:right">2</th>
                <th style="text-align:right">8</th>
                <th style="text-align:right">0</th>
                <th style="text-align:right">1</th>
                <th style="text-align:right">0</th>
              </tr>
            </table>
          </li>
          <li><b>Strong consensus.</b></li>
          <li><b>A: If types have character traits, we should be making use of
              them to determine compatibility.</b></li>
        </ul>
      </li>
      <li>Jens responded to the against rationale by stating that use of
          character traits is not excluded; per-type enablement could be
          conditional on matching traits.</li>
      <li><b>Poll 1.2: The standard library should provide a general-purpose
          facility for enablement of implicit interconvertibility between
          string and string_view-like types (including UDTs).</b>
        <ul>
          <li><b>Attendance: 12 (2 abstentions)</b></li>
          <li>
            <table>
              <tr>
                <th style="text-align:right">SF</th>
                <th style="text-align:right">F</th>
                <th style="text-align:right">N</th>
                <th style="text-align:right">A</th>
                <th style="text-align:right">SA</th>
              </tr>
              <tr>
                <th style="text-align:right">1</th>
                <th style="text-align:right">1</th>
                <th style="text-align:right">4</th>
                <th style="text-align:right">4</th>
                <th style="text-align:right">0</th>
              </tr>
            </table>
          </li>
          <li><b>No consensus.</b></li>
        </ul>
      </li>
      <li><b>Poll 1.3: A solution to the problem stated in P2779 needs to be
          included in the C++ standard library.</b>
        <ul>
          <li><b>Attendance: 12 (1 abstention)</b></li>
          <li>
            <table>
              <tr>
                <th style="text-align:right">SF</th>
                <th style="text-align:right">F</th>
                <th style="text-align:right">N</th>
                <th style="text-align:right">A</th>
                <th style="text-align:right">SA</th>
              </tr>
              <tr>
                <th style="text-align:right">1</th>
                <th style="text-align:right">1</th>
                <th style="text-align:right">5</th>
                <th style="text-align:right">4</th>
                <th style="text-align:right">0</th>
              </tr>
            </table>
          </li>
          <li><b>No consensus.</b></li>
        </ul>
      </li>
      <li>Tom stated that he will record the poll results in the paper tracker
          and that it will be up to the LEWG chair to decide what to do
          next.</li>
      <li>PBrett suggested that more examples of how this proposal could
          alleviate programming challenges</li>
      <li>might help to increase motivation.</li>
      <li>Tom agreed and noted that the large proportion of N votes presumably
          reflects insufficient motivation.</li>
    </ul>
  </li>
  <li><a href="https://wg21.link/p2872r1">P2872R1: Remove wstring_convert From C++26</a>.
    <ul>
      <li><em>[ Editor's note: D2872R1 was the active paper under discussion at
          the telecon.
          The agenda and links used here reference P2872R1 since the links to
          the draft paper were ephemeral.
          The published document may differ from the reviewed draft revision.
          ]</em></li>
      <li>Alisdair stated that, If feedback is light, that he will incorporate
          it and publish the paper as P2872R1; otherwise, he will publish
          P2872R1 as-is and incorporate the feedback in a newer revision.</li>
      <li>Alisdair explained that <tt>wbuffer_convert</tt> and
          <tt>wstring_convert</tt> have been deprecated for three standard
          releases now.</li>
      <li>Alisdair noted that removal permits implementors to continue to
          provide the functionality thanks to the additions to zombie
          names.</li>
      <li>Alisdair indicated that wording updates might be needed, but that LWG
          will handle that.</li>
      <li>Alisdair explained that the deprecation was motivated by
          underspecification and dependence on other deprecated features like
          <tt>std::codecvt_utf8</tt>.</li>
      <li>Alisdair reported that there are currently four related open LWG
          issues and that reviving the feature would require more.</li>
      <li>Corentin stated that, without <tt>std::codecvt_utf8</tt>, the
          standard no longer provides features needed to use these types.</li>
      <li>Alisdair agreed and explained that programmers would have to provide
          their own <tt>std::codecvt</tt> facet.</li>
      <li>Corentin acknowledged the requirement, but observed that programmers
          could more easily just implement the needed conversion.</li>
      <li>Victor opined that these types provide little value since they are
          just light wrappers anyway.</li>
      <li>Victor reported that a search of the projects he works on found a few
          uses, but that those uses should be replaced anyway.</li>
      <li>PBrett asked if anyone had an objection to removing these
          features.</li>
      <li>No objections were raised.</li>
      <li>MarkZ reported that a Github search identified few uses.</li>
    </ul>
  </li>
  <li><a href="https://wg21.link/p2845r0">P2845R0: Formatting of std::filesystem::path</a>.
    <ul>
      <li>Victor introduced the paper:
        <ul>
          <li><a href="https://wg21.link/p1636">P1636 (Formatters for library types)</a>
              previously proposed formatting for <tt>std::filesystem::path</tt>
              but was specified to use the <tt>native()</tt> member function
              which might require transcoding and had no provisions for
              handling of non-printable characters.</li>
          <li>This paper proposes a formatter that performs proper transcoding
              and substitutes escape sequences for non-printable characters and
              ill-formed code units.</li>
        </ul>
      </li>
      <li>Victor noticed a missing doublequote character in the first source
          code example in section 2, "Problems".</li>
      <li>Victor reported that some minor issues have been fixed in a draft R1
          revision.</li>
      <li>Corentin asked if backslash path delimiters on Windows would be
          formatted with escape sequences.</li>
      <li>Victor confirmed that they would be, that such substitution might be
          surprising, but is consistent with <tt>std::quoted()</tt>.</li>
      <li>Victor noted that an additional format specifier could be provided
          to choose an alternate behavior.</li>
      <li>Corentin asked about use of the debug specifier, "{:?}".</li>
      <li>Victor replied that the escaped format is proposed as the default
          behavior.</li>
      <li>Charlie asserted that some lattitude is needed to choose an alternate
          escape character since backslash in paths has an important meaning
          on Windows.</li>
      <li>Charlie noted that an alternate escape character could be surprising
          and would create an inconsistency across platforms.</li>
      <li>PBrett asked about adding a specifier that enables specifying a
          different escape character.</li>
      <li>Victor responded that such a specifier would be cumbersome and that
          there are other options such as performing a transformation.</li>
      <li>Victor stated that there are use cases for both an escaped and a
          non-escaped variant.</li>
      <li>Tom presented a few use cases including formatting for generic text,
          byte preserved for filesystem access, punycode for URLs, and quoted
          for shell scripts.</li>
      <li>Tom suggested that most transformations should be done outside of
          formatting.</li>
      <li>Corentin stated that the default behavior should just escape
          ill-formed code units and that the debug format specifier could be
          used to escape problematic characters.</li>
      <li>Victor replied that quoting is useful but not always needed.</li>
      <li>Tom suggested that a specifier could be added to opt in to
          quoting.</li>
      <li>PBrett expressed two high level use cases:</li>
        <ul>
          <li>The need to format the path precisely such that it can be used
              to open a file.</li>
          <li>The need to format the path for textual display in a format
              friendly to humans.</li>
        </ul>
      </li>
      <li>PBrett opined that the paper does not clearly define the problem it
          intends to solve.</li>
      <li>PBrett noted that, in
          <a href="https://docs.gtk.org/glib">GLib</a>,
          functions are provided to request a file name suitable for display
          as valid UTF-8 or as a byte array.</li>
      <li>Victor replied that the goal of the paper is to address the issues
          discovered from prior review of
          <a href="https://wg21.link/p1636">P1636 (Formatters for library types)</a>.</li>
      <li>Victor stated that additional use cases can be addressed as
          needed.</li>
      <li>Zach reported that Python provides the functionality this paper is
          proposing and noted that its formatters will double Windows path
          separators.</li>
      <li>Zach stated that Python allows printing unformatted paths by treating
          paths as a string and that C++ can do so as well.</li>
      <li>Zach agreed that some kind of escaping and quoting is needed.</li>
      <li><em>[ Editor's note: Corentin later
          <a href="https://lists.isocpp.org/sg16/2023/06/3886.php">posted a message to the SG16 mailing list</a>
          that demonstrates Python's behavior with a
          <a href="https://godbolt.org/z/7sf5xPPsc">Compiler Explorer link</a>.
          ]</em></li>
      <li>Jens asserted that, due to various quirks with
          <tt>std::filesystem::path</tt>, that the paper should cover the
          motivation and design space and not solely focus on addressing the
          issues found from review of P1636.</li>
      <li>Jens stated that the paper should discuss, for example, the
          implication of using backslashes in the syntax of character escapes
          in formatted paths.</li>
      <li>PBrett agreed.</li>
      <li>PBrett noted that we were out of time and that additional review will
          be needed to discuss encoding issues.</li>
    </ul>
  </li>
  <li>Tom stated that the next meeting is scheduled for 2023-06-28, that there
      are several LWG issues awaiting review, and that Zach is working on a
      revision of
      <a href="https://wg21.link/p2728">P2728 (Unicode in the Library, Part 1: UTF Transcoding)</a>.</li>
  <li><em>[ Editor's note: The following meeting was canceled due to summer
      vacations. ]</em></li>
  <li>Zach stated an expectation to have a new revision available in the next
      two weeks.</li>
</ul>


<h1 id="2023_07_12">July 12th, 2023</h1>

<h2>Draft agenda:</h2>

<ul>
  <li><a href="https://wg21.link/p1030r5">P1030R5: std::filesystem::path_view</a>:
    <ul>
      <li>Discuss what to do in lieu of overloads with <tt>std::locale</tt> parameters.</li>
    </ul>
  </li>
  <li><a href="https://wg21.link/p2845r0">P2845R0: Formatting of std::filesystem::path</a>:
    <ul>
      <li>Continue review.</li>
    </ul>
  </li>
  <li><a href="https://wg21.link/lwg3944">LWG 3944: Formatters converting sequences of char to sequences of wchar_t</a>:
    <ul>
      <li>Initial review.</li>
    </ul>
  </li>
</ul>

<h2>Attendees:</h2>

<ul>
  <li>Charlie Barto</li>
  <li>Fraser Gordon</li>
  <li>Hubert Tong</li>
  <li>Jens Maurer</li>
  <li>Mark de Wever</li>
  <li>Nathan Owen</li>
  <li>Niall Douglas</li>
  <li>Peter Brett</li>
  <li>Robin Leroy</li>
  <li>Tom Honermann</li>
  <li>Victor Zverovich</li>
  <li>Zach Laine</li>
</ul>

<h2>Meeting summary:</h2>

<ul>
  <li><a href="https://wg21.link/p1030r5">P1030R5: std::filesystem::path_view</a>:
    <ul>
      <li>Niall stated that, during LEWG discussion in Varna, LEWG approved
          removal of <tt>std::locale</tt> function overloads that were added
          for compatibility with <tt>std::filesystem::path</tt>.</li>
      <li>Niall noted that, for each overload set that has an overload with a
          <tt>std::locale</tt> parameter, there is an overload that does
          not.</li>
      <li>PBrett asked for an explanation of the concerns with the overloads
          that work with <tt>std::locale</tt>.</li>
      <li>Niall responded that locale support generally delegates conversion to
          the OS where they are handled efficiently, but conversions performed
          via <tt>std::locale</tt> impose considerable performance overhead;
          possibly including multiple conversions on some platforms.</li>
      <li><em>[ Editor's note: conversions controlled by <tt>std::locale</tt>
          require use of the <tt>std::codecvt</tt> facet which, per
          <a href="http://eel.is/c++draft/filesystems#fs.path.construct-6">[fs.path.construct]p6</a>,
          may require multiple conversions. ]</em></li>
      <li>Niall stated that a replacement for <tt>std::locale</tt> would be
          welcome.</li>
      <li>PBrett opined that, in his experience, treating paths as having an
          encoding leads to sadness.</li>
      <li>PBrett stated that a lossy conversion to a definitive encoding can
          be used to display paths.</li>
      <li>Niall noted that the proposed <tt>path_view</tt> supports a raw byte
          encoding and provides rendering operations.</li>
      <li>PBrett asked if the facility provides features to produce a path
          suitable for display purposes.</li>
      <li>Niall replied that such formatting falls more in the domain of
          <a href="https://wg21.link/p2845">P2845 (Formatting of std::filesystem::path)</a>
         and that he has been in discussion with Victor.</li>
      <li>PBrett asked if there is a plan to provide a formatter for
          <tt>path_view</tt>.</li>
      <li>Niall suggested that such a formatter behave the same as for
          <tt>std::filesystem::path</tt>.</li>
      <li>Victor summarized observations made during the LEWG discussion:
        <ul>
          <li><tt>std::locale</tt> was present in <tt>constexpr</tt> overloads;
              that issue is easily solved by removing the <tt>constexpr</tt>
              specifier from those declarations.</li>
          <li>the <tt>std::locale</tt> parameter is only present to support
              encoding conversions, but those conversions are better handled by
              an interface designed for such conversions.</li>
        </ul>
      </li>
      <li>Victor noted that <tt>std::codecvt</tt> is not an efficient method
          for transcoding.</li>
      <li>Victor opined that the overloads with a <tt>std::locale</tt>
          parameter are not known to be needed and can be added back later,
          perhaps in a more restrictive form, if desired.</li>
      <li>Niall asked Victor if he is suggesting that the existing
          <tt>std::filesystem::path</tt> overloads with a <tt>std::locale</tt>
          parameter should be deprecated.</li>
      <li>Victor replied that he would be happy to write such a paper at some
          future point.</li>
      <li>Tom asked why there is a <tt>compare()</tt> overload with a
          <tt>std::locale</tt> parameter.</li>
      <li>Niall responded that comparisons are shallow by default and
          <tt>compare()</tt> is provided to allow for more comprehensive
          equivalence comparisons.</li>
      <li>Niall explained that the <tt>std::locale</tt> parameter is used to
          convert each path to a common form that is then compared.</li>
      <li>PBrett expressed an assumption that the <tt>std::locale</tt>
          parameter would be used for collation purposes using the
          <tt>std::collate</tt> facet.</li>
      <li>Hubert asked why collation would be relevant for equality.</li>
      <li>PBrett asked if, given a set of <tt>path_view</tt> objects, whether
          the <tt>compare()</tt> operation could be used to order them.</li>
      <li>Zach responded that such collation might be better performed using
          features outside of the <tt>std::filesystem</tt> library.</li>
      <li>Jens stated that the wording in the paper is suggestive that only
          the encoding is intended to be consumed from the locale object.</li>
      <li>Jens observed that removal of the <tt>std::locale</tt> parameter
          results in a loss of transcoding facilities, but since what was
          provided was so thin, it isn't much of a loss.</li>
      <li>Victor stated that the equivalent facility in <tt>path_view</tt> of
          the <tt>std::locale</tt> based <tt>std::filesystem::path</tt>
          construction is the locale dependent <tt>render()</tt> member
          function.</li>
      <li>Niall explained that the reference implementation of the locale
          dependent <tt>render()</tt> member uses the <tt>std::locale</tt>
          object to convert a path to UTF-8 and then compares it.</li>
      <li>Tom expressed confusion, stated that <tt>std::locale</tt> doesn't
          support conversion to UTF-8, and then realized the reference
          implementation is probably using the <tt>char8_t</tt> codecvt
          facets that don't actually convert between the locale encoding.</li>
      <li>Niall responded that he is not aware of anyone that uses
          <tt>std::locale</tt> with the filesystem.</li>
      <li>Victor pondered interaction with <tt>std::format</tt> and
          <tt>std::print</tt> and whether it would make sense for
          <tt>path_view</tt> to also rely on the literal encoding to detect
          UTF-8 encoding; that would enable construction with
          <tt>char</tt>-based data to be saved as <tt>char8_t</tt>.</li>
      <li>Tom expressed some reservations; programmers might compile with a
          <tt>/utf-8</tt> or equivalent option, but file names produced or
          provided at run-time might be differently encoded.</li>
      <li>Hubert expressed concerns regarding implementation experience
          obtained so far regarding preservation of the literal encoding for
          use by the standard library.</li>
      <li><b>Poll 1: Modify P1030R6 "std::filesystem::path_view" to restore
          function overloads with locale parameters.</b>
        <ul>
          <li><b>Attendees: 12 (4 abstentions)</b></li>
          <li>
            <table>
              <tr>
                <th style="text-align:right">SF</th>
                <th style="text-align:right">F</th>
                <th style="text-align:right">N</th>
                <th style="text-align:right">A</th>
                <th style="text-align:right">SA</th>
              </tr>
              <tr>
                <th style="text-align:right">0</th>
                <th style="text-align:right">0</th>
                <th style="text-align:right">2</th>
                <th style="text-align:right">4</th>
                <th style="text-align:right">2</th>
              </tr>
            </table>
          </li>
          <li><b>Consensus against.</b></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="https://wg21.link/p2845r0">P2845R0: Formatting of std::filesystem::path</a>:
    <ul>
      <li>Tom apologized for his delinquency in producing a meeting summary for
          the previous discussion on this paper that took place at the prior
          SG16 meeting.</li>
      <li>Victor summarized his understanding of the direction from the prior
          meeting; to explore more options for quoting and escaping.</li>
      <li>PBrett explained a desired ability to obtain a close approximation of
          a path validly encoded for display purposes and stated that the paper
          does not currently provide sufficient detail.</li>
      <li>Victor asked for confirmation that Peter wants the path formatted
          without any transformation, no loss of information, no quoting, and
          perhaps just escaping for invalid code unit sequences.</li>
      <li>PBrett explained that he wants three version:
        <ul>
          <li>one that provides the raw bytes; <tt>path_view</tt> provides that,
              but <tt>std::filesystem::path</tt> does not.</li>
          <li>one that understands encoding and provides the path unmodified
              with the exception of substitution characters for invalid code
              unit sequences.</li>
          <li>one with quotes and escape sequences for problematic
              characters.</li>
        </ul>
      </li>
      <li>Niall stated that, for both <tt>std::filesystem::path</tt> and
          <tt>path_view</tt>, it is possible to obtain the path as a string or
          to visit the components with a lambda.</li>
      <li>Jens asked for confirmation that <tt>std::format</tt> includes a
          debug specifier that enables a string to be printed with escape
          sequences for problematic characters.</li>
      <li>Victor confirmed that is the case and stated that it could be used
          for paths such that the default formatting provides the second option
          PBrett listed.</li>
      <li>Jens asked what the output would be for the Belarusian example in the
          paper for arbitrary code pages used in practice.</li>
      <li>Victor replied that, in either case, the same substitutions would be
          performed.</li>
      <li>Jens expressed approval and noted that behavior would be consistent
          with choices previously made.</li>
      <li>Mark observed that the options discussed so far, with an exception
          for the debug specifier, would retain newline characters.</li>
      <li>PBrett acknowledged the behavior and noted that additional
          translations can be applied on the formatted result as needed;
          e.g., to substitute a space for the newline character.</li>
      <li>Niall expressed frustration regarding rendering paths in quotes since
          quote characters are also valid path characters.</li>
      <li>Tom acknowledged feeling similary frustrated by that.</li>
      <li>PBrett stated that quotes would only be present when the debug
          specifier is used.</li>
      <li>Niall pondered whether an additional format specifier to format the
          path with escape sequences but without quotes is warranted.</li>
      <li>Tom responded that additional such options could be recognized by the
          <tt>formatter</tt> specialization.</li>
      <li>Zach asked how control characters like RTL isolates should be handled;
          whether they should be ignored when formatting for display but
          preserved by the debug format.</li>
      <li>PBrett replied that he doesn't have experience with those in path
          names but that he would expect them to be handled as a custom
          translation.</li>
      <li>Zach suggested such characters should probably be passed through when
          formatting for display.</li>
      <li>PBrett asked if the paper should be updated to address the
          <tt>path_view</tt> proposal.</li>
      <li>Victor replied that <tt>path_view</tt> should be handled separately
          since there are additional complications for the byte case.</li>
      <li>Tom stated that the consensus direction seems pretty clear for a
          paper revision.</li>
    </ul>
  </li>
  <li><a href="https://wg21.link/lwg3944">LWG 3944: Formatters converting sequences of char to sequences of wchar_t</a>:
    <ul>
      <li>Mark summarized the issue:
        <ul>
          <li>In C++20, it was an intentional design decision to not support
              formatting of <tt>char</tt>-based string arguments when
              formatting for <tt>wchar_t</tt>.</li>
          <li>In C++23, such formatting was inadvertently added via support for
              range formatting since a range might have a <tt>char</tt> element
              type.</li>
        </ul>
      </li>
      <li>PBrett asked Mark what his preferred resolution is.</li>
      <li>Mark replied with a preference to preserve formatting of individual
          characters of type <tt>char</tt> in general but to disable formatting
          of ranges with a <tt>char</tt> element type.</li>
      <li>Mark noted that such range formatting probably wouldn't produce the
          intended result when the characters are, for example, individual
          UTF-8 code units.</li>
      <li>PBrett expressed skepticism that the reported formatting was
          intentional.</li>
      <li>Tom asked why a different conclusion is reached for formatting of an
          individual character vs an individual character in a range.</li>
      <li>Hubert replied that a range of individual code units is more
          string-like.</li>
      <li>Niall stated that, in principle, the range could be iterated to
          decode characters.</li>
      <li>PBrett agreed but noted that doing so would require encoding
          information.</li>
      <li>Niall acknowledged the requirement and noted it could be inferred for
          the <tt>charN_t</tt> types, but not for <tt>char</tt>.</li>
      <li>Tom expressed a belief that support for the <tt>charN_t</tt> types is
          disabled.</li>
      <li>Victor confirmed that is the case.</li>
      <li>Hubert indicated that such conversions could be enabled, but that
          necessary facilities are not currently available at run-time;
          something like ICU or iconv would be needed.</li>
      <li>PBrett suggested that an escape translation could be produced.</li>
      <li>Hubert replied that stateful encodings would require representing
          state.</li>
      <li>Tom asked what the downside is of disabling support for ranges that
          have a mismatched character type as the element type.</li>
      <li>PBrett replied that, ideally, it should be possible to format
          everything.</li>
      <li>Victor agreed with PBrett and stated that formatters for string-like
          types that have a mismatched character element type could be disabled
          and that a specifier to format a range as a string could be
          provided.</li>
      <li>Hubert expressed support for a protocol to opt-in to support of
          string-like types.</li>
      <li>Zach asked if <tt>std::vector</tt> would be considered a string-like
          type.</li>
      <li>Zach expressed support for disabling formatting of ranges with a
          mismatched character element type.</li>
      <li>Victor observed that disabling formatters for mismatched
          <tt>std::string</tt> and <tt>std::string_view</tt> would suffice to
          automatically disable types that derive from them.</li>
      <li>Victor expressed support for distinguishing between string-like and
          non-string-like types.</li>
      <li>Mark noted that support can always be added later for a disabled
          formatter and that disabling these formatters would be an improvement
          over the status quo.</li>
      <li>PBrett agreed and asked Mark if he is willing to author a proposed
          resolution.</li>
      <li>Mark agreed to do so.</li>
      <li><em>[ Editor's note: Mark offered a proposed resolution that is now
          reflected in the LWG issue. ]</em></li>
    </ul>
  </li>
  <li>Tom announced that the next meeting will be 2023-07-26 and that the
      agenda will cover allowances for <tt>$</tt> in identifiers, encoding for
      the proposed <tt>std::contracts::contract_violation::comment()</tt> member
      function, and continued review of of Zach's UTF transcoding paper if a
      new revision becomes available.</li>
</ul>


</body>
