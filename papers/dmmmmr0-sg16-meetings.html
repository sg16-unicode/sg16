<!doctype html public "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">

<head>
<title>SG16: Unicode meeting summaries 2024-03-13 through 2024-03-13</title>
</head>

<style type="text/css">

table#header th,
table#header td
{
    text-align: left;
}

tt {
    font-family: monospace;
}

/* Thanks to Elias Kosunen for the following CSS suggestions! */

* {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
    line-height: 125%;
}

html, body {
    background-color: #eee;
}

h1, h2, h3, h4, h5, p, span, li, dt, dd {
    color: #333;
}

p, li {
    line-height: 140%;
}

body {
    padding: 1em;
    max-width: 1600px;
}

p, li {
    -moz-osx-font-smoothing: grayscale;
    -webkit-font-smoothing: antialiased !important;
    -moz-font-smoothing: antialiased !important;
    text-rendering: optimizelegibility !important;
    letter-spacing: .01em;
}

h1, h2, h3 {
    margin-bottom: 1em;
    letter-spacing: .03em;
}

blockquote.quote
{
    margin-left: 0em;
    border-style: solid;
    background-color: lemonchiffon;
    color: #000000;
    border: 1px solid black;
}

</style>

<body style="max-width: 8.5in">

<table id="header">
  <tr>
    <th>Document Number:</th>
    <td>DXXXXR0 <em>Draft</em></td>
  </tr>
  <tr>
    <th>Date:</th>
    <td>2024-03-22</td>
  </tr>
  <tr>
    <th>Audience:</th>
    <td>SG16</td>
  </tr>
  <tr>
    <th>Reply-to:</th>
    <td>Tom Honermann &lt;tom@honermann.net&gt;</td>
  </tr>
</table>


<h1>SG16: Unicode meeting summaries 2024-03-13 through 2024-03-13</h1>

<p>
Summaries of SG16 meetings are maintained at
<a href="https://github.com/sg16-unicode/sg16-meetings">
https://github.com/sg16-unicode/sg16-meetings</a>.  This paper contains a
snapshot of select meeting summaries from that repository.
</p>

<ul>
  <li><a href="#2024_03_13">
      March 13th, 2024</a></li>
</ul>

<p>
Previously published SG16 meeting summary papers:
<ul>
  <li><a href="https://wg21.link/p1080">P1080: SG16: Unicode meeting summaries 2018/03/28 - 2018/04/25</a></li>
  <li><a href="https://wg21.link/p1137">P1137: SG16: Unicode meeting summaries 2018/05/16 - 2018/06/20</a></li>
  <li><a href="https://wg21.link/p1237">P1237: SG16: Unicode meeting summaries 2018/07/11 - 2018/10/03</a></li>
  <li><a href="https://wg21.link/p1422">P1422: SG16: Unicode meeting summaries 2018/10/17 - 2019/01/09</a></li>
  <li><a href="https://wg21.link/p1666">P1666: SG16: Unicode meeting summaries 2019/01/23 - 2019/05/22</a></li>
  <li><a href="https://wg21.link/p1896">P1896: SG16: Unicode meeting summaries 2019/06/12 - 2019/09/25</a></li>
  <li><a href="https://wg21.link/p2009">P2009: SG16: Unicode meeting summaries 2019-10-09 through 2019-12-11</a></li>
  <li><a href="https://wg21.link/p2179">P2179: SG16: Unicode meeting summaries 2020-01-08 through 2020-05-27</a></li>
  <li><a href="https://wg21.link/p2217">P2217: SG16: Unicode meeting summaries 2020-06-10 through 2020-08-26</a></li>
  <li><a href="https://wg21.link/p2253">P2253: SG16: Unicode meeting summaries 2020-09-09 through 2020-11-11</a></li>
  <li><a href="https://wg21.link/p2352">P2352: SG16: Unicode meeting summaries 2020-12-09 through 2021-03-24</a></li>
  <li><a href="https://wg21.link/p2397">P2397: SG16: Unicode meeting summaries 2021-04-14 through 2021-05-26</a></li>
  <li><a href="https://wg21.link/p2512">P2512: SG16: Unicode meeting summaries 2021-06-09 through 2021-12-15</a></li>
  <li><a href="https://wg21.link/p2605">P2605: SG16: Unicode meeting summaries 2022-01-12 through 2022-06-08</a></li>
  <li><a href="https://wg21.link/p2678">P2678: SG16: Unicode meeting summaries 2022-06-22 through 2022-09-28</a></li>
  <li><a href="https://wg21.link/p2766">P2766: SG16: Unicode meeting summaries 2022-10-12 through 2022-12-14</a></li>
  <li><a href="https://wg21.link/p2891">P2891: SG16: Unicode meeting summaries 2023-01-11 through 2023-05-10</a></li>
  <li><a href="https://wg21.link/p2995">P2995: SG16: Unicode meeting summaries 2023-05-24 through 2023-09-27</a></li>
  <li><a href="https://wg21.link/p3174">P3174: SG16: Unicode meeting summaries 2023-10-11 through 2024-02-21</a></li>
</ul>
</p>


<h1 id="2024_03_13">March 13th, 2024</h1>

<h2>Draft agenda:</h2>

<ul>
  <li><a href="https://wg21.link/p1729r4">P1729R4: Text Parsing</a>.</li>
  <li><a href="https://wg21.link/p3154r0">P3154R0: Deprecating signed character types in iostreams</a>.</li>
</ul>

<h2>Attendees:</h2>

<ul>
  <li>Alisdair Meredith</li>
  <li>Braden Ganetsky</li>
  <li>Eddie Nolan</li>
  <li>Elias Kosunen</li>
  <li>Fraser Gordon</li>
  <li>Jens Maurer</li>
  <li>Mark de Wever</li>
  <li>Nathan Owens</li>
  <li>Robin Leroy</li>
  <li>Tom Honermann</li>
  <li>Victor Zverovich</li>
</ul>

<h2>Meeting summary:</h2>

<ul>
  <li>A round of introductions was held for new attendee Braden Ganetsky.</li>
  <li><a href="https://wg21.link/p1729r4">P1729R4: Text Parsing</a>:
    <ul>
      <li>Elias explained that prior feedback has been addressed and that the
          paper is expected to be ready for a forwarding poll.</li>
      <li>Elias reviewed the revision history and the changes requested by
          SG9.</li>
      <li>Elias stated that support for stdin will be provided in a future
          paper; similar to how <tt>std::print()</tt> was proposed after
          <tt>std::format()</tt> was adopted.</li>
      <li>Elias proceeded to review each section of the paper.</li>
      <li>Eddie noted that the comment in the example in section 3.2,
          "Reading multiple values at once", appears to be missing
          <tt>values()</tt> following <tt>operator-&gt;</tt>.</li>
      <li><em>[ Editor's note: The comment appears to be intentional in only
          referring to <tt>operator-&gt;</tt>, but incorrect in stating,
          "will throw if it doesn't contain a value"; a call to
          <tt>std::expected&lt;T&gt;::operator-&gt;()</tt> exhibits UB if
          <tt>has_value()</tt> is not true. ]</em></li>
      <li>Tom asked, while looking at the example in section 3.4,
          "Reading multiple values in a loop", if all result values are
          definitely assigned.</li>
      <li>Elias explained that the scan result is returned by value and that
          there is no way to provide an object that is referenced within the
          result object.</li>
      <li>Tom asked, while looking at the example in section 3.6,
          "Scanning a user-defined type", if the use of <tt>std::expected</tt>
          is required or whether another <tt>std::expected</tt>-like type could
          be used.</li>
      <li>Elias replied that a concept-like approach is used in the reference
          implementation.</li>
      <li>Braden asked if it will be surprising to programmers that
          <tt>std::scan</tt> reports errors via <tt>std::expected</tt> where as
          <tt>std::format</tt> uses exceptions.</li>
      <li>Elias responded that a failure to parse input provided at run-time is
          expected and therefore a different category of error than what is
          expected when formatting.</li>
      <li>Victor agreed with Elias and stated that this is a reasonable
          design.</li>
      <li>Mark asked what happens if the scan format string is not valid.</li>
      <li>Elias replied that the format string is constant evaluated and, if
          not valid, renders the program ill-formed.</li>
      <li>Mark commented that both throwing an exception and returning a
          <tt>std::expected</tt> value that holds an error type in response to
          an invalid format string can suffice to produce a compile-time
          error.</li>
      <li>Elias proceeded to review section 4, "Design".</li>
      <li>Robin requested that, in section 4.2, "Format strings", in the
          discussion of whitespace, the word "currently" in
          "Those code points are currently" be struck since the Unicode
          stability policy ensures these won't change.</li>
      <li>Robin observed that the list of whitespace code points appears to be
          missing some characters; U+000B LINE TABULATION for example.</li>
      <li>Elias responded that the ASCII line includes a range of code points
          that includes that character.</li>
      <li>Tom suggested it would be more clear for the list to include all of
          the
          <a href="https://util.unicode.org/UnicodeJsps/list-unicodeset.jsp?a=%5B%3Apattern_white_space%3A%5D&g=&i="><tt>Pattern_White_Space</tt></a>
          characters individually.</li>
      <li>Elias continued review in section 4.3.2, "Fill and align", and
          explained the behavior for scanning of centered text without an
          explicit width; an unambiguous width cannot be inferred based on
          surrounding fill characters.</li>
      <li>Tom referenced the <tt>rH</tt> example that scans <tt>"*42**"</tt>
          with a <tt>"{:*^}"</tt> format specification, noted that the final
          <tt>*</tt> character is not scanned, and asked for confirmation that
          the example won't roundtrip with what <tt>std::format()</tt> produces
          with an explicit field width.</li>
      <li>Elias confirmed.</li>
      <li>Victor suggested double checking how the
          <a href="https://pypi.org/project/parse/">Python parse project</a>
          handles that situation.</li>
      <li>Elias responded that he had checked at one point, but would need to
          do so again.</li>
      <li><em>[ Editor's note: The "Format Specification" section in the
          <a href="https://pypi.org/project/parse/">Python parse project description</a>
          states:</em>
          <blockquote class="quote">
            Note that the “center” alignment does not test to make sure the
            value is centered - it just strips leading and trailing whitespace.
          </blockquote>
          <em>]</em>
      </li>
      <li>Victor pondered whether it is possible to roundtrip in general without
          field width information and suggested the possibility of not
          supporting scanning of center aligned text without an explicit field
          width.</li>
      <li>Elias agreed that such cases could be disallowed.</li>
      <li>Jens questioned whether it might be a good to scale back the options
          for scanning.</li>
      <li>Jens noted that there are already some asymmetries and provided an
          example; <tt>std::format()</tt> produces a specific whitespace
          sequence while <tt>std::scan()</tt> will consume arbitrary
          whitespace.</li>
      <li>Jens suggested that use of a regular expression to consume fill
          characters might provide a more practical approach.</li>
      <li>Elias asked if Jens' suggestion is intended just for handling of
          center alignment or for all field widths.</li>
      <li>Jens clarified that the goal would be for the <tt>r5</tt> example to
          have a format specifier that consumes an arbitrary number of fill
          characters.</li>
      <li>Jens stated that perhaps the <tt>r7</tt> example would not be covered
          by this idea since it has an explicit field width.</li>
      <li>Jens opined that the <tt>r5</tt> example and all those that follow it
          are a little concerning; particularly with regard to centering.</li>
      <li>Elias responded that section 6.2, "<tt>scanf</tt>-like
          <tt>[character set]</tt> matching" discusses potential future support
          for matching regular expressions and discarding characters.</li>
      <li>Elias stated these future directions would cover Jens' suggested
          approach, but acknowledged that a format specifier option would be
          convenient.</li>
      <li>Jens stated that full regular expression support would invite
          complication.</li>
      <li>Mark asked if dynamic field widths are supported.</li>
      <li>Elias replied that they are explicitly disallowed.</li>
      <li>Elias reported that there was a poll in LEWGI that supported
          compatibility with <tt>std::format</tt> as a guiding principle.</li>
      <li>Elias acknowledged that formatting and scanning are different.</li>
      <li>Jens agreed and stated that compatibility makes sense as long as it
          makes sense.</li>
      <li>Victor stated that symmetry with <tt>std::format()</tt> is not a goal,
          but that providing a replacement for <tt>scanf()</tt> is a goal and
          the motivation for many of these use cases.</li>
      <li>Jens replied that he is not aware of features in <tt>scanf()</tt>
          that would allow for skipping over fill characters.</li>
      <li>Victor acknowledged the lack of such general features but that the
          use cases apply when the fill character is a space character.</li>
      <li>Victor asked if iostreams supports skipping fill characters when
          scanning.</li>
      <li>General uncertainty was expressed.</li>
      <li>Jens reported that it appears that example <tt>r5</tt> cannot be
          parsed with <tt>scanf()</tt>.</li>
      <li>Tom stated that it sounds like there is some homework to be done.</li>
      <li>Jens suggested that homework be done and that review continue at a
          future telecon.</li>
      <li>Tom agreed.</li>
      <li>Eddie moved on to section 4.3.3, "Sign, '#', and '0'", and stated
          that ignoring '+' and '-' signs or leading '0' characters would not
          be desirable by default, but could be useful in conjunction with
          the sign and '0' format options.</li>
      <li>Elias responded that, in his experience, it is more important to have
          a clean design space than it is to have compatible format strings and
          that he preferred to not allow those flags in order to avoid
          confusion.</li>
      <li>Victor agreed with Elias.</li>
      <li>Elias explained that there is an additional roundtrip asymmetry when
          formatted text exceeds an explicit field width; scanning the text
          with an explicit field width won't consume all of the formatted
          text.</li>
      <li>Elias noted that section 4.3.5.2,
          "Design discussion: Separate flag for thousands separators"
          will be removed; it was unintentionally left in.</li>
    </ul>
  </li>
  <li><a href="https://wg21.link/p3154r0">P3154R0: Deprecating signed character types in iostreams</a>:
    <ul>
      <li>Elias introduced the paper by explaining that the
          <tt>signed char</tt> and <tt>unsigned char</tt> inserters and
          extractors behavior is surprising because those types are treated as
          character types but are often used as the underlying types of
          <tt>int8_t</tt> and <tt>uint8_t</tt>.</li>
      <li>Alisdair asked how <tt>std::format()</tt> handles these types.</li>
      <li>Elias responded that they are formatted as integer types.</li>
      <li>Jens suggested updating section 1, "Motivation", to add a
          <tt>std::format()</tt> example for each of the <tt>std::cout</tt>
          examples.</li>
      <li>Alisdair asked about the long term intent and whether these functions
          might be defined as deleted or specified to have different behavior
          after a deprecation period.</li>
      <li>Alisdair asserted that deprecation should be a transitional state;
          features should not stay deprecated indefinitely.</li>
      <li>Elias expressed a preference for defining them as deleted due to
          concerns about just switching to new behavior.</li>
      <li>Victor expressed strong support for deprecation and stated that these
          functions are a common source of errors.</li>
      <li>Victor noted that the existing behavior will remain available but
          will require an explicit cast to a <tt>char</tt>-based type.</li>
      <li>Jens stated that a plan to deprecate in C++26, to define these
          functions as deleted for C++29, and to define them with new behavior
          for C++40 or so could make sense.</li>
      <li>Jens expressed strong support for defining these functions as deleted
          as either a final or further intermediate step.</li>
      <li>Jens requested gathering some implementation experience by modifying
          a C++ standard library to define these functions as deleted and then
          compiling some real world projects to see if any latent bugs are
          discovered.</li>
      <li>Jens opined that deprecation is a LEWG concern and that SG16 should
          offer a recommendation on use of <tt>signed char</tt> and
          <tt>unsigned char</tt> as character types.</li>
      <li>Alisdair pondered an option to change the behavior to
          implementation-defined or unspecified.</li>
      <li><b>Poll 1: Recommend reserving <tt>signed char</tt> and
          <tt>unsigned char</tt> for use as integer types, not character
          types.</b>
        <ul>
          <li><b>Attendees: 11 (1 abstention)</b></li>
          <li>
            <table>
              <tr>
                <th style="text-align:right">SF</th>
                <th style="text-align:right">F</th>
                <th style="text-align:right">N</th>
                <th style="text-align:right">A</th>
                <th style="text-align:right">SA</th>
              </tr>
              <tr>
                <th style="text-align:right">7</th>
                <th style="text-align:right">2</th>
                <th style="text-align:right">0</th>
                <th style="text-align:right">1</th>
                <th style="text-align:right">0</th>
              </tr>
            </table>
          </li>
          <li><b>Consensus in favor.</b></li>
          <li><b>A: I would like to see the results for the experiment Jens
              suggested first.</b></li>
        </ul>
      </li>
      <li><b>Poll 2: Forward P3154R0 with the suggested modifications to the
          motivation section to LEWG for C++26.</b>
        <ul>
          <li><b>Attendees: 11 (3 abstentions)</b></li>
          <li>
            <table>
              <tr>
                <th style="text-align:right">SF</th>
                <th style="text-align:right">F</th>
                <th style="text-align:right">N</th>
                <th style="text-align:right">A</th>
                <th style="text-align:right">SA</th>
              </tr>
              <tr>
                <th style="text-align:right">4</th>
                <th style="text-align:right">2</th>
                <th style="text-align:right">1</th>
                <th style="text-align:right">1</th>
                <th style="text-align:right">0</th>
              </tr>
            </table>
          </li>
          <li><b>Consensus in favor.</b></li>
          <li><b>A: The direction is more a matter for LEWG.</b></li>
        </ul>
      </li>
      <li>Those that abstained from the second poll reported being uneasy with
          the poll because the proposed change to deprecate these features is
          not an SG16 concern.</li>
      <li>Tom explained that his intention with forwarding polls is to confirm
          that there are no outstanding SG16 concerns that are not either
          addressed or discussed in the paper; these polls are not intended to
          state a position on matters that do not fall under SG16's
          purview.</li>
    </ul>
  </li>
  <li>Tom reported intent to cancel the scheduled 2024-03-27 SG16 meeting since
      the WG21 meeting in Tokyo will have just concluded and we'll all be busy
      catching up with our regular lives.</li>
  <li>Jens expressed support for that cancellation.</li>
  <li>Tom reported that he has historically scheduled SG16 meetings for the 2nd
      and 4th Wednesday of each month, but that meetings from now through
      2024-10-24 were scheduled for every two weeks; whether inadvertently or
      intentionally with now forgotten intent remains a mystery.</li>
  <li>Tom indicated an inclination to stick with that schedule for now and
      requested that anyone that will encounter attendance difficulties because
      of it let him know.</li>
  <li>Tom announced that the next meeting is scheduled for 2024-04-10 and that
      there are a number of papers awaiting review.</li>
</ul>


</body>
