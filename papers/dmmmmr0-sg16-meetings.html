<!doctype html public "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">

<head>
<title>SG16: Unicode meeting summaries 2023-10-11 through 2023-10-25</title>
</head>

<style type="text/css">

table#header th,
table#header td
{
    text-align: left;
}

tt {
    font-family: monospace;
}

/* Thanks to Elias Kosunen for the following CSS suggestions! */

* {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
    line-height: 125%;
}

html, body {
    background-color: #eee;
}

h1, h2, h3, h4, h5, p, span, li, dt, dd {
    color: #333;
}

p, li {
    line-height: 140%;
}

body {
    padding: 1em;
    max-width: 1600px;
}

p, li {
    -moz-osx-font-smoothing: grayscale;
    -webkit-font-smoothing: antialiased !important;
    -moz-font-smoothing: antialiased !important;
    text-rendering: optimizelegibility !important;
    letter-spacing: .01em;
}

h1, h2, h3 {
    margin-bottom: 1em;
    letter-spacing: .03em;
}

blockquote.quote
{
    margin-left: 0em;
    border-style: solid;
    background-color: lemonchiffon;
    color: #000000;
    border: 1px solid black;
}

</style>

<body style="max-width: 8.5in">

<table id="header">
  <tr>
    <th>Document Number:</th>
    <td>DXXXXR0 <em>Draft</em></td>
  </tr>
  <tr>
    <th>Date:</th>
    <td>2023-11-28</td>
  </tr>
  <tr>
    <th>Audience:</th>
    <td>SG16</td>
  </tr>
  <tr>
    <th>Reply-to:</th>
    <td>Tom Honermann &lt;tom@honermann.net&gt;</td>
  </tr>
</table>


<h1>SG16: Unicode meeting summaries 2023-10-11 through 2023-10-25</h1>

<p>
Summaries of SG16 meetings are maintained at
<a href="https://github.com/sg16-unicode/sg16-meetings">
https://github.com/sg16-unicode/sg16-meetings</a>.  This paper contains a
snapshot of select meeting summaries from that repository.
</p>

<ul>
  <li><a href="#2023_10_11">
      October 11th, 2023</a></li>
  <li><a href="#2023_10_25">
      October 25th, 2023</a></li>
</ul>

<p>
Previously published SG16 meeting summary papers:
<ul>
  <li><a href="https://wg21.link/p1080">P1080: SG16: Unicode meeting summaries 2018/03/28 - 2018/04/25</a></li>
  <li><a href="https://wg21.link/p1137">P1137: SG16: Unicode meeting summaries 2018/05/16 - 2018/06/20</a></li>
  <li><a href="https://wg21.link/p1237">P1237: SG16: Unicode meeting summaries 2018/07/11 - 2018/10/03</a></li>
  <li><a href="https://wg21.link/p1422">P1422: SG16: Unicode meeting summaries 2018/10/17 - 2019/01/09</a></li>
  <li><a href="https://wg21.link/p1666">P1666: SG16: Unicode meeting summaries 2019/01/23 - 2019/05/22</a></li>
  <li><a href="https://wg21.link/p1896">P1896: SG16: Unicode meeting summaries 2019/06/12 - 2019/09/25</a></li>
  <li><a href="https://wg21.link/p2009">P2009: SG16: Unicode meeting summaries 2019-10-09 through 2019-12-11</a></li>
  <li><a href="https://wg21.link/p2179">P2179: SG16: Unicode meeting summaries 2020-01-08 through 2020-05-27</a></li>
  <li><a href="https://wg21.link/p2217">P2217: SG16: Unicode meeting summaries 2020-06-10 through 2020-08-26</a></li>
  <li><a href="https://wg21.link/p2253">P2253: SG16: Unicode meeting summaries 2020-09-09 through 2020-11-11</a></li>
  <li><a href="https://wg21.link/p2352">P2352: SG16: Unicode meeting summaries 2020-12-09 through 2021-03-24</a></li>
  <li><a href="https://wg21.link/p2397">P2397: SG16: Unicode meeting summaries 2021-04-14 through 2021-05-26</a></li>
  <li><a href="https://wg21.link/p2512">P2512: SG16: Unicode meeting summaries 2021-06-09 through 2021-12-15</a></li>
  <li><a href="https://wg21.link/p2605">P2605: SG16: Unicode meeting summaries 2022-01-12 through 2022-06-08</a></li>
  <li><a href="https://wg21.link/p2678">P2678: SG16: Unicode meeting summaries 2022-06-22 through 2022-09-28</a></li>
  <li><a href="https://wg21.link/p2766">P2766: SG16: Unicode meeting summaries 2022-10-12 through 2022-12-14</a></li>
  <li><a href="https://wg21.link/p2891">P2891: SG16: Unicode meeting summaries 2023-01-11 through 2023-05-10</a></li>
  <li><a href="https://wg21.link/p2995">P2995: SG16: Unicode meeting summaries 2023-05-24 through 2023-09-27</a></li>
</ul>
</p>


<h1 id="2023_10_11">October 11th, 2023</h1>

<h2>Draft agenda:</h2>

<ul>
  <li><a href="https://wg21.link/p1729r3">P1729R3: Text Parsing</a>:
    <ul>
      <li>Continue review.</li>
    </ul>
  </li>
</ul>

<h2>Attendees:</h2>

<ul>
  <li>Corentin Jabot</li>
  <li>Elias Kosunen</li>
  <li>Hubert Tong</li>
  <li>Nathan Owen</li>
  <li>Robin Leroy</li>
  <li>Steve Downey</li>
  <li>Tom Honermann</li>
  <li>Victor Zverovich</li>
</ul>

<h2>Meeting summary:</h2>

<ul>
  <li><a href="https://wg21.link/p1729r3">P1729R3: Text Parsing</a>:
    <ul>
      <li><em>[ Editor's note: D1729R3 was the active paper under discussion at
          the telecon.
          The agenda and links used here reference P1729R3 since the links to
          the draft paper were ephemeral.
          The published document may differ from the reviewed draft revision.
          ]</em></li>
      <li>Elias presented the changes in the draft P1729R3:
        <ul>
          <li><tt>std::scan</tt> now returns a subrange for the unparsed input
              rather than just an iterator to the start of the range.</li>
          <li>As noted in the revision history, changes requested during the
              last SG16 review with respect to whitespace, locale, and encoding
              concerns have been made.</li>
        </ul>
      </li>
      <li>Victor asked if returning a subrange will be less efficient since it
          requires passing an iterator pair or an iterator and size pair.</li>
      <li>Elias responded that the overhead is expected to be negligible
          relative to the convenience provided by returning the sentinel.</li>
      <li>Elias commented that, per section 3.6, "Scanning an user-defined type",
          the second template parameter for <tt>std::scanner</tt> now has
          <tt>char</tt> as a default argument.</li>
      <li>Elias reviewed the changes in section 4.2, "Format strings" to define
          whitespace in terms of the Unicode <tt>Pattern_White_Space</tt>
          property.</li>
      <li>Victor asked why LEFT-TO-RIGHT MARK and RIGHT-TO-LEFT MARK are
          considered whitespace.</li>
      <li>Robin responded that these code points can be used to prevent
          directionality properties from one token from affecting how the
          characters of an adjacent token are displayed.</li>
      <li>Tom asked for confirmation that there is no desire or need for
          scanning to consider bidirectional concerns; e.g., scanning should
          always follow memory order, not logical order.</li>
      <li>Robin referenced the examples in
          <a href="https://www.unicode.org/reports/tr55/tr55-3.html#Usability-bidi">section 1.3.2, "Usability issues arising from bidirectional reordering"</a>
          of
          <a href="http://www.unicode.org/reports/tr55">UTS #55, "Unicode Source Code Handling"</a>
          that demonstrate how the Unicode Bidirectional Algorithm can produce
          unreadable text.</li>
      <li>Victor requested the addition of some bidirectional examples and asked
          Robin if he could offer some suggestions that would be relevant for
          scanning.</li>
      <li>Robin responded in chat to see the examples in
          <a href="https://www.unicode.org/reports/tr31/tr31-39.html#Bidirectional_Ordering">section 4.1.1, "Bidirectional Ordering"</a>
          of
          <a href="https://www.unicode.org/reports/tr31">UAX #31, "Unicode Identifiers and Syntax"</a>.</li>
      <li>Elias agreed that examples can be added.</li>
      <li>Tom noted that, when the input is not known to be in a UTF encoding,
          that the set of whitespace characters will need to be
          implementation-defined.</li>
      <li>Elias agreed and stated those details will be added later.</li>
      <li>Elias directed attention to section 4.3.5.1,
          "Design discussion: Thousands separator grouping checking" and noted
          that iostreams enforces grouping separators.</li>
      <li>Tom asked for confirmation that iostreams only enforces that, if
          grouping separators are present, that they are in the expected
          locations and that they aren't required to be present.</li>
      <li>Elias confirmed.</li>
      <li>Victor asserted that <tt>std::scan</tt> should do what iostreams does
          and stated that programmers that want different behavior can implement
          that themselves.</li>
      <li>Elias suggested the behavior could potentially be changed later if
          desired.</li>
      <li>Victor replied that it is generally more difficult to introduce an
          error where one was not previously reported than it is to relax an
          error that was previously reported.</li>
      <li>Elias noted that some <tt>scanf()</tt> implementations have an
          extension that allows <tt>'</tt> to be recognized as a grouping
          separator.</li>
      <li>Tom asked if that separator is handled like it is in C++ where it can
          appear anywhere any number of times.</li>
      <li>Elias responded that it is recognized as an alternate grouping
          separator, so no.</li>
      <li>Victor explained that
          <a href="https://github.com/fmtlib/fmt">{fmt}</a>
          briefly supported that feature but that it was removed.</li>
      <li>Victor opined that support for that feature probably isn't
          needed.</li>
      <li>Elias acknowledged that support for it could always be added
          later.</li>
      <li>Corentin agreed with Victor, expressed a desire to eventually replace
          locale support with something based on ICU someday, and encouraged
          avoidance of innovation with locale features.</li>
      <li>Elias stated that he would not proceed further with the alternate
          separator.</li>
      <li>Elias pointed out that section 4.5,
          "Argument passing, and return type of <tt>scan</tt>", now specifies
          that <tt>std::scan</tt> returns a subrange.</li>
      <li>Elias observed a markup error in the last paragraph of that section;
          "gt;" appears where "&amp;gt;" was intended to encode "&gt;".</li>
      <li>Elias claimed that the return of a subrange consisting of an iterator
          and sentinel pair is novel and is done because the sentinel is always
          available but converting it to an iterator would require more work to
          advance an iterator to the sentinel position.</li>
      <li>Tom encouraged Elias to contact the SG9 chair to arrange a
          discussion.</li>
      <li>Elias proclaimed that a better name is needed for the proposed
          <tt>borrowed_ssubrange_t</tt> and explained that the extra "s" stands
          for sentinel.</li>
      <li>Steve agreed and stated that, as is, that name looks like a typo.</li>
      <li>Steve recommended spelling the name out since this isn't one that
          programmers would have to write often anyway.</li>
      <li>Corentin suggested that it might be possible to change
          <tt>borrowed_subrange</tt> to support an iterator and sentinel
          subrange.</li>
      <li>Elias replied that doing so might impact ABI.</li>
      <li>Corentin recommended discussing it in SG9.</li>
      <li>Elias presented section 4.6, "Error handling", and the recently added
          <tt>value_out_of_range</tt> enumerator added to
          <tt>scan_error::code_type</tt>.</li>
      <li>Elias explained that the <tt>strtol()</tt> family of interfaces allow
          a programmer to differentiate between overflow and underflow using a
          combination of the return value and <tt>errno</tt>, but that
          <tt>std::scan</tt> as proposed would not be able to support that.</li>
      <li>Victor reported having previously needed to be able to differentiate
          between underflow and overflow.</li>
      <li>Tom stated that it sounds like there is some motivation for more
          granular errors.</li>
      <li>Corentin argued that isn't a question for SG16 to answer.</li>
      <li>Elias reported that there are a lot of potential error conditions and
          argued that adding a different error code for each is probably
          undesirable.</li>
      <li>Corentin asked if a distinct error code is needed for encoding
          errors.</li>
      <li>Elias responded that there had been discussion about that during the
          previous review and that we'll get to that section shortly.</li>
      <li>Corentin asserted that it would be useful to provide an iterator or
          index to the position within the input where an error occurred.</li>
      <li>Victor agreed.</li>
      <li>Victor suggested it would make sense to provide more granular error
          handling for builtin types.</li>
      <li>Victor requested some additional examples and noted that there are
          unique error cases for floating-point types.</li>
      <li>Elias mentioned that an example has been added to section 4.10,
          "Locales".</li>
      <li>Elias stated that section 4.11, "Encoding" was added for the R3
          revision.</li>
      <li>Elias summarized discussion from the last SG16 review; that
          ill-formed code unit sequences be handled similar to floating-point
          NaN values in that they don't match anything.</li>
      <li>Victor suggested that "invalidly encoded code points" should be
          changed to something like "ill-formed code unit sequences".</li>
      <li>Corentin asked if the intent is to supply replacement characters for
          ill-formed code unit sequences.</li>
      <li>Elias replied negatively and explained that the intent is to allow
          use of <tt>std::string_view</tt> as a result type that refers to
          matched characters in the input; that support precludes substitution
          of replacement characters.</li>
      <li>Elias stated that these sequences are instead handled like
          non-characters.</li>
      <li>Elias acknowledged that this design means that unsanitized input
          won't be validated and that ill-formed code unit sequences may
          persist in the output.</li>
      <li>Corentin noted the implication; that values returned by
          <tt>std::scan</tt> can't be trusted and lack of verification can
          result in UB and security issues.</li>
      <li>Elias agreed that there is a security aspect since the input could
          be arbitrary user provided input.</li>
      <li>Victor opined that the proposed behavior seems reasonable and
          consistent with other scan-like functions.</li>
      <li>Victor suggested updating the paper to compare the proposed behavior
          with <tt>scanf()</tt>.</li>
      <li>Steve noted that, even if the input was mutable, rewriting replacement
          characters into the buffer is not an option since the space needed for
          the encoded replacement character might require a longer buffer.</li>
      <li>Steve explained that Zach's proposed transcoding facilities could be
          used to pipe input that has not been validated for encoding concerns
          into the scanner such that replacement characters are proactively
          substituted.</li>
      <li><em>[ Editor's note: The input produced by such a pipeline would not
          provide a contiguous range of elements and would presumably not be
          usable with a <tt>std::string_view</tt> result type. ]</em></li>
      <li>Steve expressed a preference for features that compose.</li>
      <li>Victor asserted that it should be possible to use <tt>std::scan</tt>
          with binary data and that ill-formed code unit sequences should
          therefore not be unconditionally rejected.</li>
      <li>Corentin agreed that support for binary data is an important concern
          and referred to a comment
          <a href="https://lists.isocpp.org/sg16/2023/10/3974.php">Tom made in a message to the SG16 mailing list</a>
          about the potential use of a <tt>{:?}</tt> format specier for byte
          precise scanning.</li>
      <li>Corentin expressed uncertainty regarding how important it is to handle
          mixed binary and text.</li>
      <li>Corentin noted that the proposed design provides different guarantees
          for different types; result objects of <tt>int</tt> and <tt>float</tt>
          type will always hold valid values, but a string type might hold
          garbage.</li>
      <li>Corentin worried that programmers might expect a validly encoded
          string and be surprised.</li>
      <li>Victor claimed that it is not possible to determine what is and is
          not garbage since programmers do use string types like
          <tt>std:string_view</tt> with binary data.</li>
      <li>Victor asserted that we should not try to guess the programmer's
          intent.</li>
      <li>Tom agreed that we should not assume the programmer's intent and
          observed that providing a facility to allow them to express their
          intent could be ok.</li>
      <li>Elias reported that the example that Tom included in the
          <a href="https://lists.isocpp.org/sg16/2023/10/3971.php">agenda announcement</a>
          has been added as example 6 in section 4.3.8,
          "Type specifiers: CharT".</li>
      <li><em>[ Editor's note: the example involves a scan of the first code
          unit of a multiple code unit sequence followed by a scan of a string
          that then interprets the remainder of the code unit sequence as an
          ill-formed sequence. ]</em></li>
      <li>Corentin noted that scanning strings requires recognizing spaces and
          asked if there is a use case for a space separated sequence of random
          bytes.</li>
      <li>Corentin surmised that, if that use case is important, then it should
          influence the design.</li>
      <li>Victor recognized Corentin's observation regarding spaces and random
          bytes as important.</li>
      <li>Victor stated that the behavior described for the example in the paper
          matches his expectations.</li>
      <li>Elias argued that the entire input should not be sanitized due to
          processing overhead.</li>
      <li>Elias affirmed that an invalidly encoded string could be handled as
          an error.</li>
      <li>Tom asserted it would be useful to allow the programmer to express
          their intent with a type specifier.</li>
      <li>Tom noted that the ability to do so would allow for the kinds of
          encoding guarantees that programmers might expect and argued that this
          should be the default behavior.</li>
      <li>Elias agreed that would be useful.</li>
      <li>Elias stated that he will have to evaluate further how that fits into
          the design but that it sounds manageable.</li>
      <li>Tom asked if <tt>signed char</tt> and <tt>unsigned char</tt> are
          handled as character or integer types.</li>
      <li>Elias responded that they are treated as integer types.</li>
      <li>Tom noted that is consistent with <tt>std::format()</tt>.</li>
      <li>Elias added that it is also consistent with iostream.
      <li>Victor conveyed a lack of enthusiasm for an additional format
          specifier due to the increased complexity.</li>
      <li>Tom suggested relying on the type system instead; perhaps
          <tt>std::span&lt;char&gt;</tt> could be used to scan a
          "binary string".</li>
      <li>Victor agreed and suggested there could be another type to represent
          a broken code unit.</li>
      <li>Corentin nominated <tt>std::byte</tt>.</li>
      <li>Tom noted that <tt>std::byte</tt> wouldn't work for wide strings.</li>
      <li>Corentin countered that wide strings aren't used for binary data.</li>
      <li>Tom responded that a programmer might want to be able to read a lone
          surrogate.</li>
      <li>Victor reported that <tt>std::format()</tt> formats <tt>std::byte</tt>
          as an unsigned integer.</li>
      <li>Tom summarized his impression of the consensus at this point;
          the design is good, but some progress is needed regarding handling of
          text vs binary input.</li>
      <li>Corentin expressed a penchant for the design in general.</li>
      <li>Elias requested that the meeting minutes be published before October
          15th so that they would be available for reference by the R3 paper in
          time for the next mailing deadline.</li>
      <li>Tom said he would try.</li>
      <li><em>[ Editor's note: Tom provided a rough draft of the minutes prior
          to the 15th and that sufficed for Elias' purposes. ]</em></li>
    </ul>
  </li>
  <li>Tom announced that the next meeting will be held 1023-10-25 and that there
      are some LWG issues to be discussed, including ones involving everyone's
      favorite locale facet, <tt>std::codecvt</tt>.</li>
  <li>Hubert stated that he might soon have a paper that discusses use of
      <tt>$</tt> in identifiers.</li>
</ul>


<h1 id="2023_10_25">October 25th, 2023</h1>

<h2>Draft agenda:</h2>

<ul>
  <li>charN_t, char_traits, codecvt, and iostreams:
    <ul>
      <li><a href="https://wg21.link/p2873r0">P2873R0: Remove Deprecated Locale Category Facets For Unicode from C++26</a>.</li>
      <li><a href="https://wg21.link/lwg3767">LWG 3767: codecvt&lt;charN_t, char8_t, mbstate_t&gt; incorrectly added to locale</a>.</li>
      <li><a href="https://wg21.link/lwg2959">LWG 2959: char_traits&lt;char16_t&gt;::eof is a valid UTF-16 code unit</a>.</li>
        <ul>
          <li><a href="https://github.com/sg16-unicode/sg16/issues/32">SG16 #32: std::char_traits&lt;char16_t&gt;::eof() requires uint_least16_t to be larger than 16 bits</a>.</li>
        </ul>
      </li>
      <li><a href="https://github.com/sg16-unicode/sg16/issues/33">SG16 #33: A correct codecvt facet that works with basic_filebuf can't do UTF conversions</a>.</li>
    </ul>
  </li>
</ul>

<h2>Attendees:</h2>

<ul>
  <li>Alisdair Meredith</li>
  <li>Corentin Jabot</li>
  <li>Hubert Tong</li>
  <li>Jens Maurer</li>
  <li>Mark de Wever</li>
  <li>Nathan Owens</li>
  <li>Peter Brett</li>
  <li>Robin Leroy</li>
  <li>Steve Downey</li>
  <li>Tom Honermann</li>
  <li>Victor Zverovich</li>
</ul>

<h2>Meeting summary:</h2>

<ul>
  <li>PBrett announced that he will be retiring from C++ standardization efforts
      for the foreseeable future starting in November.</li>
  <li>Several people voiced disappointment and wished Peter well.</li>
  <li>charN_t, char_traits, codecvt, and iostreams:
    <ul>
      <li>Tom reported having reached out to the WG21 ABI review group to ask if
          there were any known ABI tricks that implementors might deploy if
          <a href="https://wg21.link/lwg2959">LWG 2959 (char_traits&lt;char16_t&gt;::eof is a valid UTF-16 code unit)</a>
          were to be fixed in the obvious way; by mapping the <tt>int_type</tt>
          member alias to a larger type.</li>
      <li>Tom summarized their response; no tricks were identified; suggestions
          included defining a replacement type for the
          <tt>std::char_traits&lt;char16_t, char, std::mb_state&gt;</tt>
          specialization that could be explicitly used in its place.</li>
      <li>Corentin replied that a replacement type doesn't solve the user
          problem.</li>
      <li>Corentin reported intent to submit a proposal to deprecate user
          specializations of <tt>std::char_traits</tt>.</li>
      <li>Corentin asked if Tom had asked the libc++ maintainers directly
          regarding their thoughts on the issue.</li>
      <li>Tom reported that he has not.</li>
      <li>Corentin suggested that doing so might be helpful.</li>
      <li>Tom reported having audited uses of the <tt>int_type</tt> and related
          members of <tt>std::char_traits</tt> throughout the standard and
          having found that they are only used within iostreams and, since the
          standard only requires iostreams to support <tt>char</tt> and
          <tt>wchar_t</tt>, changing <tt>int_type</tt> for the <tt>char16_t</tt>
          specialization appears to be a viable option.</li>
      <li><em>[ Editor's note: Tom's audit rediscovered information that was
          already known and had been reported in
          <a href="https://github.com/sg16-unicode/sg16/issues/32#issuecomment-433877435">a comment on SG16 issue #32</a>
          back in 2018. ]</em></li>
      <li>Hubert stated that the libc++ implementation of iostreams uses the
          <tt>eof()</tt> member of <tt>std::char_traits</tt> as a sentinel value
          to determine if a fill character has been specified via the
          <tt>std::setfill()</tt> I/O manipulator.</li>
      <li><em>[ Editor's note: The libc++ implementation of
          <tt>std::basic_ios</tt> has a private data member named
          <tt>__fill_</tt> of type <tt>int_type</tt> that is initlialized to
          <tt>eof()</tt>.
          When a fill character is needed, a comparison is performed against
          <tt>eof()</tt> to determine if a fill character has been set or
          whether the (possbily widened) default fill character should be used.
          ]</em></li>
      <li>Hubert noted this as an issue for the <tt>wchar_t</tt> iostream and
          <tt>std::char_traits</tt> specializations.</li>
      <li>Tom noted that, for <tt>wchar_t</tt> the EOF value is specified by
          <tt>WEOF</tt> and asked if it is known to have a value other than
          -1 anywhere.</li>
      <li>Hubert responded that he was not aware of other values being used,
          but that the value is problematic because programmers can use that
          value.</li>
      <li><em>[ Editor's note: Microsoft's <tt>wchar.h</tt> header defines
          <tt>WEOF</tt> as <tt>((wint_t)(0xFFFF))</tt> which is equivalent to
          <tt>-1</tt> converted to <tt>wint_t</tt> (<tt>unsigned short</tt>).
          ]</em></li>
      <li>Tom acknowledged the concern as applicable to the <tt>wchar_t</tt>
          specialization and that it can be treated as a separable issue.</li>
      <li>Corentin reported that the C++ standard appears to be missing a
          definition for <tt>WEOF</tt>.</li>
      <li>Jens responded that the C++ standard has an exposition value of
          "*see below*" that is intended to redirect to the C library.</li>
      <li>Jens noted the redirection is the same as for <tt>wint_t</tt>.</li>
      <li><em>[ Editor's note: See
          <a href="http://eel.is/c++draft/cwctype.syn#lib:WEOF">[cwctype.syn]</a>
          and
          <a href="http://eel.is/c++draft/cwchar.syn#lib:WEOF">[cwchar.syn]</a>.
          ]</em></li>
      <li>Tom observed that the clash with <tt>WEOF</tt> is only a problem when
          the <tt>WEOF</tt> value is in the range of <tt>wchar_t</tt> values;
          e.g., when <tt>WEOF</tt> is -1 and <tt>wchar_t</tt> is a signed
          type.</li>
      <li>Jens noted that the C standard requires that <tt>wint_t</tt> be able
          to hold all extended character values and that Hubert's concern is
          that C++ extends more flexibility to users in use of particular
          values.</li>
      <li>Tom indicated that he would work with Hubert to get an issue
          filed.</li>
      <li>Corentin stated that <tt>std::char_traits&lt;wchar_t&gt;</tt> also
          suffers from the lack of an available value for EOF in implementations
          like Microsoft's where both <tt>wchar_t</tt> and <tt>wint_t</tt> are
          16-bit and used with UTF-16.</li>
      <li><em>[ Editor's note: Microsoft's implementation uses an unsigned
          16-bit type for both <tt>wchar_t</tt> and <tt>wint_t</tt>, defines
          <tt>WEOF</tt> as <tt>((wint_t)(0xFFFF))</tt>, <tt>WCHAR_MIN</tt> as
          <tt>0</tt>, and <tt>WCHAR_MAX</tt> as <tt>0xFFFF</tt>.
          That leaves no values left for use as an EOF sentinel. ]</em></li>
      <li>Hubert expressed skepticism that such implementations are
          conforming.</li>
      <li>Jens recalled that changes were made to allow for use of UTF-16 with
          <tt>wchar_t</tt> at the core language level but that such allowances
          were not extended to the standard library.</li>
      <li><em>[ Editor's note: see
          <a href="https://wg21.link/p2460">P2460 (Relax requirements on <tt>wchar_t</tt> to match existing practices)</a>.i
          ]</em></li>
      <li>Jens acknowledged that the distinction doesn't matter much since
          existing implementations are not going to be changed.</li>
      <li>Tom expressed a preference to fix <tt>char_traits&lt;char16_t&gt;</tt>
          as a technically breaking change.</li>
      <li>Jens requested that implementors be directly contacted for
          feedback.</li>
      <li>Hubert also encouraged Jens' request since a change would break use of
          libc++ iostreams with <tt>char16_t</tt>.</li>
      <li>Jens acknowledged the potential break, but noted that the ability to
          use iostreams with <tt>char16_t</tt> might not be intentional.</li>
      <li>Jens presented <tt>std::complex</tt> as an example of a class template
          that has restrictions on which types are allowed as template type
          arguments.</li>
      <li>Alisdair stated that there are a number of class templates for which
          instantiations are only guaranteed to work with certain types.</li>
      <li>Tom asked for confirmation that <tt>std::regex</tt> is limited to
          instantiations with <tt>char</tt> and <tt>wchar_t</tt>.</li>
      <li>Alisdair confirmed that is his understanding.</li>
      <li>Corentin noted that fixing <tt>std::regex</tt> to properly support
          Unicode would require an ABI break.</li>
      <li>Tom turned discussion towards the issues concerning
          <tt>std::codecvt</tt>.</li>
      <li>Tom asked for confirmation of his expectation that everyone is in
          agreement that the
          <tt>std::codecvt&lt;charN_t, char8_t, std::mbstate_t&gt;</tt>
          specializations that should not have been added in the first place
          should be deprecated and removed.</li>
      <li>Victor replied with a thumbs up.</li>
      <li>Alisdair stated that the deprecated
          <tt>std::codecvt&lt;charN_t, char, std::mbstate_t&gt;</tt>
          specializations are only needed by implementors that want to support
          iostreams with the <tt>charN_t</tt> types.</li>
      <li>Tom agreed.</li>
      <li>Steve noted that those are specified with fixed UTF encodings.</li>
      <li>Jens stated that, as specified, those facets have the wrong
          semantics.</li>
      <li>Alisdair observed that the current semantics stand in the way of an
          implementor doing the right thing with iostreams of <tt>charN_t</tt>
          type.</li>
      <li>Jens agreed.</li>
      <li>Corentin claimed that there are two questions:
        <ul>
          <li>Whether we think <tt>std::codecvt</tt> is useful to users and
              whether we want to continue to support it in the standard.</li>
          <li>How iostreams perform conversions.</li>
        </ul>
      </li>
      <li>Corentin asserted that we don't have to rely on <tt>std::codecvt</tt>
          to implement conversions.</li>
      <li>Tom agreed, but noted that a new mechanism would presumably have to be
          applied only for the <tt>charN_t</tt> types so as not to interfere
          with iostreams of <tt>char</tt> and <tt>wchar_t</tt>.</li>
      <li>Steve stated that it isn't clear that the <tt>std::codecvt</tt> facets
          are doing what anyone wants.</li>
      <li>Tom observed that iostreams of <tt>wchar_t</tt> are pretty much only
          used on Windows and iostreams of <tt>char</tt> use a
          <tt>std::codecvt</tt> facet that does nothing by default.</li>
      <li>Alisdair requested that any proposed changes to the
          <tt>std::codecvt</tt> facets include discussion of how the virtual
          functions can be overridden to provide different behavior.</li>
      <li>Alisdair asked if any changes are required to P2873.</li>
      <li>Tom replied that he is leaning towards undeprecating those facets
          since the <tt>char8_t</tt> facets that were intended to replace them
          don't actually do so.</li>
      <li>Jens reiterated that the deprecated facets have the problem that they
          convert to the wrong encoding.</li>
      <li>Jens stated that, once removed, they could be reintroduced with new
          semantics.</li>
      <li>Tom replied that the facets have already been deprecated for two
          release cycles and that implementations diagnose them.</li>
      <li>Mark acknowledged the deprecation but pointed out that warnings are
          suppressed in system headers.</li>
      <li>Tom noted that warnings will have been generated for any explicit use
          of the deprecated specializations.</li>
      <li>Jens observed that the deprecation has only poisoned any existing
          <tt>charN_t</tt> iostream implementations and asserted that removing
          them is the clearest path forward.</li>
      <li>Jens claimed that removal sends a stonger message than deprecation for
          any existing uses.</li>
      <li>Corentin expressed support for removing them and then adding them
          again later if needed.</li>
      <li>Jens argued for focusing on cleanup in this release cycle rather than
          considering whether we want to add support for <tt>charN_t</tt> in
          iostreams.</li>
      <li>Tom turned discussion to the final issue; that the deprecated
          <tt>std::codecvt&lt;char16_t, char, std::mbstate_t&gt;</tt> facet
          doesn't satisfy the N:1 rule for <tt>std::basic_filebuf</tt>.</li>
      <li>Tom noted that the <tt>wchar_t</tt> specialization has this issue as
          well.</li>
      <li>Jens pointed out that it technically doesn't because the library does
          not permit UTF-16 for the wide encoding.</li>
      <li><em>[ Editor's note: see
          <a href="http://eel.is/c++draft/character.seq.general#1.2)">[character.seq.general]p(1,2)</a>.
          ]</em></li>
      <li>Jens asserted that we should not address this without a paper.</li>
      <li>Tom agreed.</li>
      <li>Hubert expressed his perception of where consensus is headed; that we
          are leaning towards a clean slate for a potential proposal to
          introduce iostreams of <tt>charN_t</tt>.</li>
      <li>Jens agreed.</li>
      <li>Tom interpreted that as an argument for Alisdair's paper going forward
          as is.</li>
      <li>Corentin stated that any paper that proposes iostreams for
          <tt>charN_t</tt> needs to explore use cases.</li>
      <li>Jens added that such a paper must also consider the current absence of
          <tt>std::codecvt&lt;char8_t, char, std::mbstate_t&gt;</tt>
          specializations.</li>
      <li>Tom agreed and argued that such specializations should not be added
          until there is a demonstrated need for them.</li>
      <li>Jens requested that Alisdair's paper clearly delineate what actions to
          take now vs what would be needed by a hypothetical proposal to
          introduce iostreams of <tt>charN_t</tt>.</li>
      <li>Alisdair stated he would like to update the rationale so as to better
          explain the situation to LEWG and then submit a revision for LWG for
          the post-Kona mailing.</li>
      <li>Steve suggested posting the revision to the SG16 mailing list for
          additional review.</li>
    </ul>
  </li>
  <li>Tom discussed scheduling for the next SG16 meeting:
    <ul>
      <li>Tom announced that the next regularly scheduled SG16 meeting would
          conflict with the WG21 meeting in Kona and that the one after that
          conflicts with Thanksgiving in the US.</li>
      <li>Tom suggested meeting on 2023-11-15 and 2023-12-06 and then pause
          until the new year.</li>
      <li>Jens objected that 2023-11-15 is too close to Kona post-meeting
          activities.</li>
      <li>Tom suggested meeting on 2023-12-06 and 2023-12-20.</li>
      <li>Victor stated he would not be available on 2023-12-20.</li>
      <li>Tom proposed that we meet 2023-12-06 and evaluate then whether to meet
          2023-12-20 or suspend until the new year.</li>
      <li><em>[ Editor's note: in later
          <a href="https://lists.isocpp.org/sg16/2023/10/3998.php">mailing list discussion</a>
          it was decided the group would meet again 2023-11-29 and 2023-12-13.
          ]</em></li>
    </ul>
  </li>
</ul>


</body>
