<!doctype html public "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">

<head>
<title>SG16: Unicode meeting summaries 2024-03-13 through 2024-04-10</title>
</head>

<style type="text/css">

table#header th,
table#header td
{
    text-align: left;
}

tt {
    font-family: monospace;
}

/* Thanks to Elias Kosunen for the following CSS suggestions! */

* {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
    line-height: 125%;
}

html, body {
    background-color: #eee;
}

h1, h2, h3, h4, h5, p, span, li, dt, dd {
    color: #333;
}

p, li {
    line-height: 140%;
}

body {
    padding: 1em;
    max-width: 1600px;
}

p, li {
    -moz-osx-font-smoothing: grayscale;
    -webkit-font-smoothing: antialiased !important;
    -moz-font-smoothing: antialiased !important;
    text-rendering: optimizelegibility !important;
    letter-spacing: .01em;
}

h1, h2, h3 {
    margin-bottom: 1em;
    letter-spacing: .03em;
}

blockquote.quote
{
    margin-left: 0em;
    border-style: solid;
    background-color: lemonchiffon;
    color: #000000;
    border: 1px solid black;
}

</style>

<body style="max-width: 8.5in">

<table id="header">
  <tr>
    <th>Document Number:</th>
    <td>DXXXXR0 <em>Draft</em></td>
  </tr>
  <tr>
    <th>Date:</th>
    <td>2024-04-26</td>
  </tr>
  <tr>
    <th>Audience:</th>
    <td>SG16</td>
  </tr>
  <tr>
    <th>Reply-to:</th>
    <td>Tom Honermann &lt;tom@honermann.net&gt;</td>
  </tr>
</table>


<h1>SG16: Unicode meeting summaries 2024-03-13 through 2024-04-10</h1>

<p>
Summaries of SG16 meetings are maintained at
<a href="https://github.com/sg16-unicode/sg16-meetings">
https://github.com/sg16-unicode/sg16-meetings</a>.  This paper contains a
snapshot of select meeting summaries from that repository.
</p>

<ul>
  <li><a href="#2024_03_13">
      March 13th, 2024</a></li>
  <li><a href="#2024_04_10">
      April 10th, 2024</a></li>
</ul>

<p>
Previously published SG16 meeting summary papers:
<ul>
  <li><a href="https://wg21.link/p1080">P1080: SG16: Unicode meeting summaries 2018/03/28 - 2018/04/25</a></li>
  <li><a href="https://wg21.link/p1137">P1137: SG16: Unicode meeting summaries 2018/05/16 - 2018/06/20</a></li>
  <li><a href="https://wg21.link/p1237">P1237: SG16: Unicode meeting summaries 2018/07/11 - 2018/10/03</a></li>
  <li><a href="https://wg21.link/p1422">P1422: SG16: Unicode meeting summaries 2018/10/17 - 2019/01/09</a></li>
  <li><a href="https://wg21.link/p1666">P1666: SG16: Unicode meeting summaries 2019/01/23 - 2019/05/22</a></li>
  <li><a href="https://wg21.link/p1896">P1896: SG16: Unicode meeting summaries 2019/06/12 - 2019/09/25</a></li>
  <li><a href="https://wg21.link/p2009">P2009: SG16: Unicode meeting summaries 2019-10-09 through 2019-12-11</a></li>
  <li><a href="https://wg21.link/p2179">P2179: SG16: Unicode meeting summaries 2020-01-08 through 2020-05-27</a></li>
  <li><a href="https://wg21.link/p2217">P2217: SG16: Unicode meeting summaries 2020-06-10 through 2020-08-26</a></li>
  <li><a href="https://wg21.link/p2253">P2253: SG16: Unicode meeting summaries 2020-09-09 through 2020-11-11</a></li>
  <li><a href="https://wg21.link/p2352">P2352: SG16: Unicode meeting summaries 2020-12-09 through 2021-03-24</a></li>
  <li><a href="https://wg21.link/p2397">P2397: SG16: Unicode meeting summaries 2021-04-14 through 2021-05-26</a></li>
  <li><a href="https://wg21.link/p2512">P2512: SG16: Unicode meeting summaries 2021-06-09 through 2021-12-15</a></li>
  <li><a href="https://wg21.link/p2605">P2605: SG16: Unicode meeting summaries 2022-01-12 through 2022-06-08</a></li>
  <li><a href="https://wg21.link/p2678">P2678: SG16: Unicode meeting summaries 2022-06-22 through 2022-09-28</a></li>
  <li><a href="https://wg21.link/p2766">P2766: SG16: Unicode meeting summaries 2022-10-12 through 2022-12-14</a></li>
  <li><a href="https://wg21.link/p2891">P2891: SG16: Unicode meeting summaries 2023-01-11 through 2023-05-10</a></li>
  <li><a href="https://wg21.link/p2995">P2995: SG16: Unicode meeting summaries 2023-05-24 through 2023-09-27</a></li>
  <li><a href="https://wg21.link/p3174">P3174: SG16: Unicode meeting summaries 2023-10-11 through 2024-02-21</a></li>
</ul>
</p>


<h1 id="2024_03_13">March 13th, 2024</h1>

<h2>Draft agenda:</h2>

<ul>
  <li><a href="https://wg21.link/p1729r4">P1729R4: Text Parsing</a>.</li>
  <li><a href="https://wg21.link/p3154r0">P3154R0: Deprecating signed character types in iostreams</a>.</li>
</ul>

<h2>Attendees:</h2>

<ul>
  <li>Alisdair Meredith</li>
  <li>Braden Ganetsky</li>
  <li>Eddie Nolan</li>
  <li>Elias Kosunen</li>
  <li>Fraser Gordon</li>
  <li>Jens Maurer</li>
  <li>Mark de Wever</li>
  <li>Nathan Owens</li>
  <li>Robin Leroy</li>
  <li>Tom Honermann</li>
  <li>Victor Zverovich</li>
</ul>

<h2>Meeting summary:</h2>

<ul>
  <li>A round of introductions was held for new attendee Braden Ganetsky.</li>
  <li><a href="https://wg21.link/p1729r4">P1729R4: Text Parsing</a>:
    <ul>
      <li>Elias explained that prior feedback has been addressed and that the
          paper is expected to be ready for a forwarding poll.</li>
      <li>Elias reviewed the revision history and the changes requested by
          SG9.</li>
      <li>Elias stated that support for stdin will be provided in a future
          paper; similar to how <tt>std::print()</tt> was proposed after
          <tt>std::format()</tt> was adopted.</li>
      <li>Elias proceeded to review each section of the paper.</li>
      <li>Eddie noted that the comment in the example in section 3.2,
          "Reading multiple values at once", appears to be missing
          <tt>values()</tt> following <tt>operator-&gt;</tt>.</li>
      <li><em>[ Editor's note: The comment appears to be intentional in only
          referring to <tt>operator-&gt;</tt>, but incorrect in stating,
          "will throw if it doesn't contain a value"; a call to
          <tt>std::expected&lt;T&gt;::operator-&gt;()</tt> exhibits UB if
          <tt>has_value()</tt> is not true. ]</em></li>
      <li>Tom asked, while looking at the example in section 3.4,
          "Reading multiple values in a loop", if all result values are
          definitely assigned.</li>
      <li>Elias explained that the scan result is returned by value and that
          there is no way to provide an object that is referenced within the
          result object.</li>
      <li>Tom asked, while looking at the example in section 3.6,
          "Scanning a user-defined type", if the use of <tt>std::expected</tt>
          is required or whether another <tt>std::expected</tt>-like type could
          be used.</li>
      <li>Elias replied that a concept-like approach is used in the reference
          implementation.</li>
      <li>Braden asked if it will be surprising to programmers that
          <tt>std::scan</tt> reports errors via <tt>std::expected</tt> where as
          <tt>std::format</tt> uses exceptions.</li>
      <li>Elias responded that a failure to parse input provided at run-time is
          expected and therefore a different category of error than what is
          expected when formatting.</li>
      <li>Victor agreed with Elias and stated that this is a reasonable
          design.</li>
      <li>Mark asked what happens if the scan format string is not valid.</li>
      <li>Elias replied that the format string is constant evaluated and, if
          not valid, renders the program ill-formed.</li>
      <li>Mark commented that both throwing an exception and returning a
          <tt>std::expected</tt> value that holds an error type in response to
          an invalid format string can suffice to produce a compile-time
          error.</li>
      <li>Elias proceeded to review section 4, "Design".</li>
      <li>Robin requested that, in section 4.2, "Format strings", in the
          discussion of whitespace, the word "currently" in
          "Those code points are currently" be struck since the Unicode
          stability policy ensures these won't change.</li>
      <li>Robin observed that the list of whitespace code points appears to be
          missing some characters; U+000B LINE TABULATION for example.</li>
      <li>Elias responded that the ASCII line includes a range of code points
          that includes that character.</li>
      <li>Tom suggested it would be more clear for the list to include all of
          the
          <a href="https://util.unicode.org/UnicodeJsps/list-unicodeset.jsp?a=%5B%3Apattern_white_space%3A%5D&g=&i="><tt>Pattern_White_Space</tt></a>
          characters individually.</li>
      <li>Elias continued review in section 4.3.2, "Fill and align", and
          explained the behavior for scanning of centered text without an
          explicit width; an unambiguous width cannot be inferred based on
          surrounding fill characters.</li>
      <li>Tom referenced the <tt>rH</tt> example that scans <tt>"*42**"</tt>
          with a <tt>"{:*^}"</tt> format specification, noted that the final
          <tt>*</tt> character is not scanned, and asked for confirmation that
          the example won't roundtrip with what <tt>std::format()</tt> produces
          with an explicit field width.</li>
      <li>Elias confirmed.</li>
      <li>Victor suggested double checking how the
          <a href="https://pypi.org/project/parse/">Python parse project</a>
          handles that situation.</li>
      <li>Elias responded that he had checked at one point, but would need to
          do so again.</li>
      <li><em>[ Editor's note: The "Format Specification" section in the
          <a href="https://pypi.org/project/parse/">Python parse project description</a>
          states:</em>
          <blockquote class="quote">
            Note that the “center” alignment does not test to make sure the
            value is centered - it just strips leading and trailing whitespace.
          </blockquote>
          <em>]</em>
      </li>
      <li>Victor pondered whether it is possible to roundtrip in general without
          field width information and suggested the possibility of not
          supporting scanning of center aligned text without an explicit field
          width.</li>
      <li>Elias agreed that such cases could be disallowed.</li>
      <li>Jens questioned whether it might be a good to scale back the options
          for scanning.</li>
      <li>Jens noted that there are already some asymmetries and provided an
          example; <tt>std::format()</tt> produces a specific whitespace
          sequence while <tt>std::scan()</tt> will consume arbitrary
          whitespace.</li>
      <li>Jens suggested that use of a regular expression to consume fill
          characters might provide a more practical approach.</li>
      <li>Elias asked if Jens' suggestion is intended just for handling of
          center alignment or for all field widths.</li>
      <li>Jens clarified that the goal would be for the <tt>r5</tt> example to
          have a format specifier that consumes an arbitrary number of fill
          characters.</li>
      <li>Jens stated that perhaps the <tt>r7</tt> example would not be covered
          by this idea since it has an explicit field width.</li>
      <li>Jens opined that the <tt>r5</tt> example and all those that follow it
          are a little concerning; particularly with regard to centering.</li>
      <li>Elias responded that section 6.2, "<tt>scanf</tt>-like
          <tt>[character set]</tt> matching" discusses potential future support
          for matching regular expressions and discarding characters.</li>
      <li>Elias stated these future directions would cover Jens' suggested
          approach, but acknowledged that a format specifier option would be
          convenient.</li>
      <li>Jens stated that full regular expression support would invite
          complication.</li>
      <li>Mark asked if dynamic field widths are supported.</li>
      <li>Elias replied that they are explicitly disallowed.</li>
      <li>Elias reported that there was a poll in LEWGI that supported
          compatibility with <tt>std::format</tt> as a guiding principle.</li>
      <li>Elias acknowledged that formatting and scanning are different.</li>
      <li>Jens agreed and stated that compatibility makes sense as long as it
          makes sense.</li>
      <li>Victor stated that symmetry with <tt>std::format()</tt> is not a goal,
          but that providing a replacement for <tt>scanf()</tt> is a goal and
          the motivation for many of these use cases.</li>
      <li>Jens replied that he is not aware of features in <tt>scanf()</tt>
          that would allow for skipping over fill characters.</li>
      <li>Victor acknowledged the lack of such general features but that the
          use cases apply when the fill character is a space character.</li>
      <li>Victor asked if iostreams supports skipping fill characters when
          scanning.</li>
      <li>General uncertainty was expressed.</li>
      <li>Jens reported that it appears that example <tt>r5</tt> cannot be
          parsed with <tt>scanf()</tt>.</li>
      <li>Tom stated that it sounds like there is some homework to be done.</li>
      <li>Jens suggested that homework be done and that review continue at a
          future telecon.</li>
      <li>Tom agreed.</li>
      <li>Eddie moved on to section 4.3.3, "Sign, '#', and '0'", and stated
          that ignoring '+' and '-' signs or leading '0' characters would not
          be desirable by default, but could be useful in conjunction with
          the sign and '0' format options.</li>
      <li>Elias responded that, in his experience, it is more important to have
          a clean design space than it is to have compatible format strings and
          that he preferred to not allow those flags in order to avoid
          confusion.</li>
      <li>Victor agreed with Elias.</li>
      <li>Elias explained that there is an additional roundtrip asymmetry when
          formatted text exceeds an explicit field width; scanning the text
          with an explicit field width won't consume all of the formatted
          text.</li>
      <li>Elias noted that section 4.3.5.2,
          "Design discussion: Separate flag for thousands separators"
          will be removed; it was unintentionally left in.</li>
    </ul>
  </li>
  <li><a href="https://wg21.link/p3154r0">P3154R0: Deprecating signed character types in iostreams</a>:
    <ul>
      <li>Elias introduced the paper by explaining that the
          <tt>signed char</tt> and <tt>unsigned char</tt> inserters and
          extractors behavior is surprising because those types are treated as
          character types but are often used as the underlying types of
          <tt>int8_t</tt> and <tt>uint8_t</tt>.</li>
      <li>Alisdair asked how <tt>std::format()</tt> handles these types.</li>
      <li>Elias responded that they are formatted as integer types.</li>
      <li>Jens suggested updating section 1, "Motivation", to add a
          <tt>std::format()</tt> example for each of the <tt>std::cout</tt>
          examples.</li>
      <li>Alisdair asked about the long term intent and whether these functions
          might be defined as deleted or specified to have different behavior
          after a deprecation period.</li>
      <li>Alisdair asserted that deprecation should be a transitional state;
          features should not stay deprecated indefinitely.</li>
      <li>Elias expressed a preference for defining them as deleted due to
          concerns about just switching to new behavior.</li>
      <li>Victor expressed strong support for deprecation and stated that these
          functions are a common source of errors.</li>
      <li>Victor noted that the existing behavior will remain available but
          will require an explicit cast to a <tt>char</tt>-based type.</li>
      <li>Jens stated that a plan to deprecate in C++26, to define these
          functions as deleted for C++29, and to define them with new behavior
          for C++40 or so could make sense.</li>
      <li>Jens expressed strong support for defining these functions as deleted
          as either a final or further intermediate step.</li>
      <li>Jens requested gathering some implementation experience by modifying
          a C++ standard library to define these functions as deleted and then
          compiling some real world projects to see if any latent bugs are
          discovered.</li>
      <li>Jens opined that deprecation is a LEWG concern and that SG16 should
          offer a recommendation on use of <tt>signed char</tt> and
          <tt>unsigned char</tt> as character types.</li>
      <li>Alisdair pondered an option to change the behavior to
          implementation-defined or unspecified.</li>
      <li><b>Poll 1: Recommend reserving <tt>signed char</tt> and
          <tt>unsigned char</tt> for use as integer types, not character
          types.</b>
        <ul>
          <li><b>Attendees: 11 (1 abstention)</b></li>
          <li>
            <table>
              <tr>
                <th style="text-align:right">SF</th>
                <th style="text-align:right">F</th>
                <th style="text-align:right">N</th>
                <th style="text-align:right">A</th>
                <th style="text-align:right">SA</th>
              </tr>
              <tr>
                <th style="text-align:right">7</th>
                <th style="text-align:right">2</th>
                <th style="text-align:right">0</th>
                <th style="text-align:right">1</th>
                <th style="text-align:right">0</th>
              </tr>
            </table>
          </li>
          <li><b>Consensus in favor.</b></li>
          <li><b>A: I would like to see the results for the experiment Jens
              suggested first.</b></li>
        </ul>
      </li>
      <li><b>Poll 2: Forward P3154R0 with the suggested modifications to the
          motivation section to LEWG for C++26.</b>
        <ul>
          <li><b>Attendees: 11 (3 abstentions)</b></li>
          <li>
            <table>
              <tr>
                <th style="text-align:right">SF</th>
                <th style="text-align:right">F</th>
                <th style="text-align:right">N</th>
                <th style="text-align:right">A</th>
                <th style="text-align:right">SA</th>
              </tr>
              <tr>
                <th style="text-align:right">4</th>
                <th style="text-align:right">2</th>
                <th style="text-align:right">1</th>
                <th style="text-align:right">1</th>
                <th style="text-align:right">0</th>
              </tr>
            </table>
          </li>
          <li><b>Consensus in favor.</b></li>
          <li><b>A: The direction is more a matter for LEWG.</b></li>
        </ul>
      </li>
      <li>Those that abstained from the second poll reported being uneasy with
          the poll because the proposed change to deprecate these features is
          not an SG16 concern.</li>
      <li>Tom explained that his intention with forwarding polls is to confirm
          that there are no outstanding SG16 concerns that are not either
          addressed or discussed in the paper; these polls are not intended to
          state a position on matters that do not fall under SG16's
          purview.</li>
    </ul>
  </li>
  <li>Tom reported intent to cancel the scheduled 2024-03-27 SG16 meeting since
      the WG21 meeting in Tokyo will have just concluded and we'll all be busy
      catching up with our regular lives.</li>
  <li>Jens expressed support for that cancellation.</li>
  <li>Tom reported that he has historically scheduled SG16 meetings for the 2nd
      and 4th Wednesday of each month, but that meetings from now through
      2024-10-24 were scheduled for every two weeks; whether inadvertently or
      intentionally with now forgotten intent remains a mystery.</li>
  <li>Tom indicated an inclination to stick with that schedule for now and
      requested that anyone that will encounter attendance difficulties because
      of it let him know.</li>
  <li>Tom announced that the next meeting is scheduled for 2024-04-10 and that
      there are a number of papers awaiting review.</li>
</ul>


<h1 id="2024_04_10">April 10th, 2024</h1>

<h2>Draft agenda:</h2>

<ul>
  <li><a href="https://wg21.link/p2758r2">P2758R2: Emitting messages at compile time</a>.</li>
</ul>

<h2>Attendees:</h2>

<ul>
  <li>Barry Revzin</li>
  <li>Corentin Jabot</li>
  <li>Fraser Gordon</li>
  <li>Jens Maurer</li>
  <li>Mark de Wever</li>
  <li>Tom Honermann</li>
  <li>Victor Zverovich</li>
</ul>

<h2>Meeting summary:</h2>

<ul>
  <li>Due to a scheduling conflict, Barry was delayed in joining the meeting
      and review of P2758R2 was thus delayed.
      The time was filled with informal chat of various items including but not
      limited to:
    <ul>
      <li>Progress on
          <a href="https://wg21.link/p2873">P2873 (Remove Deprecated Locale Category Facets For Unicode from C++26)</a>.</li>
      <li>The need, or lack thereof, for <tt>u8streampos</tt>,
          <tt>u16streampos</tt>, and <tt>u32streampos</tt>.</li>
      <li>The Unicode Text Terminal Working Group.</li>
      <li>U+FDFD (ARABIC LIGATURE BISMILLAH AR-RAHMAN AR-RAHEEM) and other
          characters with very wide display widths.</li>
      <li>The past Tokyo and future St. Louis meetings.</li>
      <li>Locales, <tt>std::format()</tt>, and <tt>char8_t</tt> support.</li>
      <li>The Unicode Message Formatting Working Group.</li>
      <li><a href="https://docs.rs/icu/latest/icu">ICU4X</a>.</li>
    </ul>
  </li>
  <li><a href="https://wg21.link/p2758r2">P2758R2: Emitting messages at compile time</a>:
    <ul>
      <li>Barry provided an introduction:
        <ul>
          <li>The goal is to allow programmers to produce more friendly
              diagnostics.</li>
          <li><tt>static_assert</tt> has limitations and clever hacks only
              go so far.</li>
          <li>Producing errors is great, but there is value in being able to
              produce informational messages and warnings that can be elevated
              to errors.</li>
          <li><tt>std::format()</tt> is not declared <tt>constexpr</tt>, but
              probably could be.</li>
          <li>The proposal is minimal and intended to provide infrastructure on
              which better interfaces can be built.</li>
        </ul>
      </li>
      <li>Victor posited that it would be useful to have a portable way to
          suppress a warning in a portable manner; a portable version of the
          <tt>#pragma</tt> directives that many implementations support
          today.</li>
      <li>Victor stated that the paper needs updates to reflect the adoption of
          <a href="https://wg21.link/p2741r3">P2741R3 (user-generated <tt>static_assert</tt> messages)</a>.</li>
      <li>Mark expressed support for the paper and commented that he recently
          asked Clang developers about such a feature.</li>
      <li>Victor noted that clang-tidy allows a comment-based annotation to
          suppress diagnostics that emanate from specified source code
          lines.</li>
      <li>Barry asked if such annotations would be expected to suppress
          diagnostics that would be produced from a specific call to one of
          these functions.</li>
      <li>Victor replied affirmatively and stated that it would be difficult
          for his organization to enable these warnings otherwise without a way
          to suppress false positives.</li>
      <li>Jens explained that clang-tidy annotations are written at the line
          where the diagnostic is issued from and that the annotation Victor is
          interested in would have to work differently.</li>
      <li>Victor agreed and stated this suppression would be more
          complicated.</li>
      <li>Tom suggested it would probably have to be an annotation that
          suppresses any indicated warnings that emanate from within the
          constant evaluation of the annotated source line.</li>
      <li>Corentin opined that this paper doesn't need to address suppression
          of a diagnostic.</li>
      <li>Corentin noted that display of a diagnostic is within the purview of
          the implementor.</li>
      <li>Corentin asserted that, as long as there is a tag available, that
          implementors can provide a means to suppress it.</li>
      <li>Tom replied that a tag is specified for
          <tt>constexpr_warning_str()</tt>, but not for the other cases.</li>
      <li>Tom stated that, from an implementation stand point, he could see
          treating errors as discretionary errors that can be demoted to
          warnings.</li>
      <li>Barry replied that production of an error is intended to halt
          constant evaluation.</li>
      <li>Barry said that there are use cases for both fatal and discretionary
          errors, but that he doesn't really agree with motivation for the
          latter.</li>
      <li>Victor expressed opposition to being able to demote an error to a
          warning.</li>
      <li>Corentin observed that the wording needs to require that the message
          is provided in the ordinary literal encoding.</li>
      <li>Corentin reported that wording examples can be found in the wording
          for <tt>static_assert</tt>.</li>
      <li><em>[ Editor's note: see
          <a href="http://eel.is/c++draft/dcl.pre#12">[dcl.pre]p12</a>.
          ]</em></li>
      <li>Jens clarified that the elements of the <tt>std::string_view</tt>
          that holds the message will be considered code units of the ordinary
          literal encoding.</li>
      <li>Barry reported having located the wording and indicated he can copy
          it.</li>
      <li>Jens asked if <tt>constexpr_error_str()</tt> is equivalent to
          <tt>static_assert(false, "message")</tt>.</li>
      <li>Barry replied that it is very similar.</li>
      <li>Corentin explained that the evaluation is performed at a different
          time and potentially for a different number of occurrences; a
          <tt>static_assert</tt> will be evaluated once at translation or
          template instantiation time where as <tt>constexpr_error_str()</tt>
          may be evaluated multiple times during constant evaluation.</li>
      <li>Corentin asked what the expectations for a call to
          <tt>constexpr_error_str()</tt> are; for example, whether a diagnostic
          with different color highlighting would be produced.</li>
      <li>Corentin asserted that it should be possible to suppress each message
          kind; they should all have a tag for this reason.</li>
      <li>Corentin asked if escape sequences may appear in the message
          strings.</li>
      <li>Barry asked what <tt>static_assert</tt> does and was informed it is
          implementation-defined.</li>
      <li><em>[ Editor's note: examples with hilariously predictable
          implementation divergence can be seen at
          <a href="https://godbolt.org/z/xasvnMPre">https://godbolt.org/z/xasvnMPre</a>.
          ]</em></li>
      <li>Victor agreed with the suggestion to add a tag to
          <tt>constexpr_print_str()</tt>.</li>
      <li>Victor asked how ill-formed tags are handled.</li>
      <li>Tom replied that tags should be restricted to the basic literal
          character set.</li>
      <li>Corentin stated that implementations should escape non-printable
          characters and ill-formed code unit sequences in the diagnostics
          they produce.</li>
      <li>Tom asked for confirmation that text in the message that looks like
          a <em>universal-character-name</em> would not be treated as such.</li>
      <li>Corentin confirmed.</li>
      <li>Jens observed that the paper proposes a library facility but that he
          is uncertain that it is.</li>
      <li>Jens stated that
          <a href="http://eel.is/c++draft/intro.compliance.general">[intro.compliance.general]</a>
          would need an update.</li>
      <li>Jens noted that section was updated to address the requirement for
          the <tt>#warning</tt> and <tt>#error</tt> directives to produce a
          diagnostic message.</li>
      <li>Jens asked why it would be necessary to state that the program is
          ill-formed rather than that the expression is not a core constant
          expression.</li>
      <li>Jens explained that ill-formed means a diagnostic must be produced,
          but an implementation can do what it wants otherwise.</li>
      <li>Jens asked if specifying these as ill-formed requires an
          implementation to refuse to translate the program and noted that this
          is currently only required for <tt>#error</tt>.</li>
      <li>Tom asked Barry if the intent is to match <tt>#error</tt>.</li>
      <li>Barry expressed uncertainty.</li>
      <li>Jens advised reading
          <a href="http://eel.is/c++draft/intro.compliance.general">[intro.compliance.general]</a>.</li>
      <li>Corentin stated that the characters permitted in tags needs to be
          clarified; quotes, semicolon, and other characters that have special
          meaning in command line shells should be prohibited.</li>
      <li>Tom pondered whether this should really be a core language
          facility.</li>
      <li>Tom suggested the tag should be required to be an unevaluated string
          to facilitate audits.</li>
      <li>Victor expressed a preference for the tag being a string literal.</li>
      <li>Corentin observed that requiring a string literal would require a
          core language feature.</li>
      <li>Barry replied that he would eventually like to expose this
          functionality with more <tt>std::format()</tt> like capabilities but
          doing so wouldn't be possible if this is specified as a language
          feature; at least not without expression aliases or some other way to
          pass a tag through a library interface.</li>
      <li>Tom stated he would like to review the proposal in SG16 again to
          review limitations on tags and wording for encoding requirements.</li>
      <li>Jens indicated that CWG will need to review the paper as well and
          stated he has a gut feeling that there is something missing.</li>
      <li>Jens noted that erroneous behavior is increasing motivation for
          producing something akin to diagnostics at run-time.</li>
      <li>Jens suggested that LEWG might not have a lot of input since the
          library interface would just forward calls to a builtin function;
          that builtin function will require input from core implementors.</li>
    </ul>
  </li>
  <li>Tom announced that the next meeting will be on 2024-04-24 and that he
      would work with authors to get papers scheduled with more advance notice
      this time.</li>
</ul>


</body>
