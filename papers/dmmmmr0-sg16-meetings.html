<!doctype html public "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">

<head>
<title>SG16: Unicode meeting summaries 2024-05-22 through 2024-06-12</title>
</head>

<style type="text/css">

table#header th,
table#header td
{
    text-align: left;
}

tt {
    font-family: monospace;
}

/* Thanks to Elias Kosunen for the following CSS suggestions! */

* {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
    line-height: 125%;
}

html, body {
    background-color: #eee;
}

h1, h2, h3, h4, h5, p, span, li, dt, dd {
    color: #333;
}

p, li {
    line-height: 140%;
}

body {
    padding: 1em;
    max-width: 1600px;
}

p, li {
    -moz-osx-font-smoothing: grayscale;
    -webkit-font-smoothing: antialiased !important;
    -moz-font-smoothing: antialiased !important;
    text-rendering: optimizelegibility !important;
    letter-spacing: .01em;
}

h1, h2, h3 {
    margin-bottom: 1em;
    letter-spacing: .03em;
}

blockquote.quote
{
    margin-left: 0em;
    border-style: solid;
    background-color: lemonchiffon;
    color: #000000;
    border: 1px solid black;
}

</style>

<body style="max-width: 8.5in">

<table id="header">
  <tr>
    <th>Document Number:</th>
    <td>DXXXXR0 <em>Draft</em></td>
  </tr>
  <tr>
    <th>Date:</th>
    <td>2025-06-10</td>
  </tr>
  <tr>
    <th>Audience:</th>
    <td>SG16</td>
  </tr>
  <tr>
    <th>Reply-to:</th>
    <td>Tom Honermann &lt;tom@honermann.net&gt;</td>
  </tr>
</table>


<h1>SG16: Unicode meeting summaries 2024-05-22 through 2024-06-12</h1>

<p>
Summaries of SG16 meetings are maintained at
<a href="https://github.com/sg16-unicode/sg16-meetings">
https://github.com/sg16-unicode/sg16-meetings</a>.  This paper contains a
snapshot of select meeting summaries from that repository.
</p>

<ul>
  <li><a href="#2024_05_22">
      May 22nd, 2024</a></li>
  <li><a href="#2024_06_12">
      June 12th, 2024</a></li>
</ul>

<p>
Previously published SG16 meeting summary papers:
<ul>
  <li><a href="https://wg21.link/p1080">P1080: SG16: Unicode meeting summaries 2018/03/28 - 2018/04/25</a></li>
  <li><a href="https://wg21.link/p1137">P1137: SG16: Unicode meeting summaries 2018/05/16 - 2018/06/20</a></li>
  <li><a href="https://wg21.link/p1237">P1237: SG16: Unicode meeting summaries 2018/07/11 - 2018/10/03</a></li>
  <li><a href="https://wg21.link/p1422">P1422: SG16: Unicode meeting summaries 2018/10/17 - 2019/01/09</a></li>
  <li><a href="https://wg21.link/p1666">P1666: SG16: Unicode meeting summaries 2019/01/23 - 2019/05/22</a></li>
  <li><a href="https://wg21.link/p1896">P1896: SG16: Unicode meeting summaries 2019/06/12 - 2019/09/25</a></li>
  <li><a href="https://wg21.link/p2009">P2009: SG16: Unicode meeting summaries 2019-10-09 through 2019-12-11</a></li>
  <li><a href="https://wg21.link/p2179">P2179: SG16: Unicode meeting summaries 2020-01-08 through 2020-05-27</a></li>
  <li><a href="https://wg21.link/p2217">P2217: SG16: Unicode meeting summaries 2020-06-10 through 2020-08-26</a></li>
  <li><a href="https://wg21.link/p2253">P2253: SG16: Unicode meeting summaries 2020-09-09 through 2020-11-11</a></li>
  <li><a href="https://wg21.link/p2352">P2352: SG16: Unicode meeting summaries 2020-12-09 through 2021-03-24</a></li>
  <li><a href="https://wg21.link/p2397">P2397: SG16: Unicode meeting summaries 2021-04-14 through 2021-05-26</a></li>
  <li><a href="https://wg21.link/p2512">P2512: SG16: Unicode meeting summaries 2021-06-09 through 2021-12-15</a></li>
  <li><a href="https://wg21.link/p2605">P2605: SG16: Unicode meeting summaries 2022-01-12 through 2022-06-08</a></li>
  <li><a href="https://wg21.link/p2678">P2678: SG16: Unicode meeting summaries 2022-06-22 through 2022-09-28</a></li>
  <li><a href="https://wg21.link/p2766">P2766: SG16: Unicode meeting summaries 2022-10-12 through 2022-12-14</a></li>
  <li><a href="https://wg21.link/p2891">P2891: SG16: Unicode meeting summaries 2023-01-11 through 2023-05-10</a></li>
  <li><a href="https://wg21.link/p2995">P2995: SG16: Unicode meeting summaries 2023-05-24 through 2023-09-27</a></li>
  <li><a href="https://wg21.link/p3174">P3174: SG16: Unicode meeting summaries 2023-10-11 through 2024-02-21</a></li>
  <li><a href="https://wg21.link/p3302">Pp3302 SG16: Unicode meeting summaries 2024-03-13 through 2024-05-08</a></li>
</ul>
</p>


<h1 id="2024_05_22">May 22nd, 2024</h1>

<h2>Draft agenda:</h2>

<ul>
  <li>Fraser to report on the May 3rd Text Terminal WG meeting.</li>
  <li>Review results of the 2024 C++ Developer Survey.</li>
  <li><a href="https://wg21.link/p2626r0">P2626R0: charN_t incremental adoption: Casting pointers of UTF character types</a>.</li>
</ul>

<h2>Attendees:</h2>

<ul>
  <li>Braden Ganetsky</li>
  <li>Corentin Jabot</li>
  <li>Fraser Gordon</li>
  <li>Mark de Wever</li>
  <li>Peter Bindels</li>
  <li>Robin Leroy</li>
  <li>Steve Downey</li>
  <li>Tom Honermann</li>
  <li>Victor Zverovich</li>
</ul>

<h2>Meeting summary:</h2>

<ul>
  <li>Fraser to report on the May 3rd Text Terminal WG meeting:
    <ul>
      <li>Fraser provided an overview:
        <ul>
          <li>This was the third meeting of the WG.</li>
          <li>Outreach to the terminal community resulted in many new
              attendees.</li>
          <li>Simon Tatham of PuTTY fame attended and demonstrated considerable
              experience in this area.</li>
          <li>Representation from WG14 would be appreciated.</li>
          <li>Representation from the Rust community would also be
              appreciated.</li>
          <li>Most of the discussion was process related.</li>
          <li>No attendees have objected to working in the open.</li>
          <li>Near term efforts will include deployment of collaboration
              tools.</li>
          <li>The next meeting will probably be in July and is expected to focus
              on establishing scope for the group and beginning technical
              discussion.</li>
          <li>The group is feeling positive about making improvements.</li>
        </ul>
      </li>
      <li>Tom suggested reaching out to the WG14 convenor regarding WG14
          participation.</li>
      <li>Robin responded that such participation might fall to him as SC22
          liaison.</li>
      <li>Tom noted that Eddie had previously reported discussion about
          <tt>wcwidth()</tt> at the TTWG meeting.</li>
      <li>Fraser explained that a replacement for <tt>wcwidth()</tt> is likely
          necessary but might run into opposition in WG14.</li>
      <li>Corentin responded that <tt>wcwidth()</tt> is part of POSIX, but not
          included in standard C.</li>
      <li>Victor asked for more details regarding participation from the
          terminal community.</li>
      <li>Fraser responded that participants on the mailing list include people
          from iTerm, MoSH, PuTTY, xterm, ncurses, and the Far Manager TUI
          application.</li>
      <li>Robin noted that the initial effort that resulted in formation of the
          TTWG group came from Microsoft and that Apple is a Unicode Consortium
          member.</li>
      <li>Tom asked if there are still people from Microsoft involved.</li>
      <li>Fraser replied that there are and that they include the original TTWG
          chair and people working on
          <a href="https://github.com/microsoft/terminal">Windows Terminal</a>.</li>
      <li>PBindels reported having attended and summarized the discussion that
          led to the determination that <tt>wcwidth()</tt> is not salvageable
          and will need to be replaced; it can't accommodate variation
          selectors.</li>
      <li>Tom explained that the Austin group that maintains the POSIX
          specification is open and welcoming and offered to help facilitate
          introduction if doing so would be helpful.</li>
      <li>Victor asked for more details regarding <tt>wcwidth()</tt> vs
          <tt>wcswidth()</tt>.</li>
      <li>PBindels responded that <tt>wcwidth()</tt> is fundamentally broken
          since it only accepts a single <tt>wchar_t</tt> code unit as input but
          that <tt>wcswidth()</tt> might be salveageable.</li>
      <li>Fraser noted that WG14 did consider standardizing the POSIX interfaces
          back in the C99 time frame.</li>
      <li>Fraser extended a thank you to anyone that is able to attend future
          TTWG meetings.</li>
    </ul>
  </li>
  <li>Review results of the 2024 C++ Developer Survey:
    <ul>
      <li>Tom briefly reviewed the Unicode related survey results and
          comments.</li>
      <li>Tom stated that he was not surprised by the results.</li>
      <li>Victor expressed surprise that only 16% of respondents reported
          Unicode related issues as a major pain point.</li>
      <li>PBindels responded that programmers that write code solely for use in
          their local region don't tend to have issues because ASCII
          suffices.</li>
      <li>Tom pondered how much pain would be reduced by adding conversion
          facilities.</li>
      <li>Victor observed that five or six of the Unicode related comments
          mentioned use of UTF-8 with <tt>char</tt> and noted that as a good
          fraction of the comments.</li>
      <li>Victor asserted that we should continue focusing on that like what we
          did for <tt>std::format()</tt>.</li>
      <li>Tom expressed strong agreement; Linux, the BSDs, and macOS comprise a
          huge chunk of the ecosystem.</li>
      <li>Corentin asserted that we can't just focus on that segment of the
          ecosystem though and noted that this isn't new information; we are
          well aware of the need to support UTF-8 with <tt>char</tt>-based
          types.</li>
      <li>Victor responded by stating that the new information is the explicit
          requests to support UTF-8 with no corresponding mention of support for
          code pages.</li>
      <li>Corentin stated that we can't extrapolate such comments to the entire
          C++ community; the number of respondents to the survey is a small
          fraction of the community and too small to draw conclusions from.</li>
      <li>Corentin added that we are in a situation of being resource
          constrained; there are things we know we want, but wanting doesn't
          make it happen; someone needs to write the corresponding papers.</li>
      <li>Tom directed discussion to other comments and noted that the mentions
          regarding <tt>char8_t</tt> also didn't surprise him.</li>
      <li>Corentin stated that we did the community a disservice by not
          providing library support for a useful type; <tt>char8_t</tt> is
          relatively useless right now.</li>
      <li>Corentin insisted the difficulty with using the type doesn't mean that
          the motivation for the type has gone away.</li>
      <li>Tom expressed being a little surprised by the explicit requests to
          extend <tt>std::from_chars()</tt> and <tt>std::to_chars()</tt> to
          support <tt>charN_t</tt> types.</li>
      <li>Corentin expressed uncertainty regarding what was actually being
          requested; there are several interpretations:
        <ul>
          <li>Programmers might just want to use these functions without having
              to transcode.</li>
          <li>Programmers might want these functions to support non-ASCII
              numbers.</li>
        </ul>
      </li>
      <li>Victor replied that <tt>std::from_chars()</tt> and
          <tt>std::to_chars()</tt> were designed to function as a low level
          feature and asserted that it wouldn't be right to add
          internationalization features to them.</li>
      <li>Victor opined that the author probably just wants support for the
          <tt>charN_t</tt> code unit types.</li>
      <li>Victor explained that, since these functions are low level, that he
          isn't really interested in seeing them expanded; not even to add
          support for <tt>std::string_view</tt>.</li>
      <li>Steve noted that <tt>std::from_chars()</tt> and
          <tt>std::to_chars()</tt> don't even support <tt>wchar_t</tt> right
          now; these functions were designed to support JSON or XML with basic
          characters.</li>
      <li>Corentin agreed with Victor up to the comment regarding
          <tt>std::string_view</tt>.</li>
      <li>Corentin noted that <tt>std::from_chars()</tt> is difficult to
          implement and suggested that we shouldn't make it harder.</li>
      <li>Steve observed that different names would be required for other
          character types since it wouldn't be possible to overload
          <tt>std::to_chars()</tt>.</li>
      <li>Victor stated that, with regard to <tt>std::string_view</tt>, the
          interface for these functions is awkward.</li>
      <li>Victor insisted that we don't want to turn these functions into
          <tt>std::format</tt>; they should remain minimal.</li>
      <li>Robin noted that some number systems are not positional and that it
          would not be advised to add support for them to these functions.</li>
    </ul>
  </li>
  <li><a href="https://wg21.link/p2626r0">P2626R0: charN_t incremental adoption: Casting pointers of UTF character types</a>:
    <ul>
      <li>Corentin lamented the absence of core language experts and stated that
          assistance is needed to make progress as we still have the same
          questions as the last time the paper was discussed.</li>
      <li>Corentin presented:
        <ul>
          <li>We introduced the <tt>charN_t</tt> code unit types, but they can't
              interoperate easily with existing functions that operate on
              <tt>char</tt> or <tt>wchar_t</tt> based storage; we need a
              mechanism that avoids problems due to type based aliasing.</li>
          <li>We would ideally allow implicit conversions but that can't work in
              C++.</li>
          <li>The currently available options for interoperation include:
            <ul>
              <li>performing inefficient copies in and out of temporary buffers;
                  this works without UB.</li>
              <li>using <tt>reinterpret_cast</tt>; this results in UB.</li>
              <li>using <tt>start_lifetime_as</tt>; this results in UB.</li>
            </ul>
          </li>
          <li>The paper proposes a magic library function to facilitate
              conversions with an appropriate aliasing barrier that prevents UB
              in very specific circumstances.</li>
          <li>The proposed semantics effectively end the lifetime of an object
              and begin the lifetime of a replacement object in place of the
              original using the same object representation.</li>
          <li>This is a very sharp tool and we need CWG to assist in specifying
              what the constraints are; those constraints will help guide what
              the interface should look like.</li>
          <li>I'm not interested in a general tool to enable selective aliasing;
              I want something that is UTF aware with variants that check for
              well-formed UTF sequences.</li>
          <li>The proposal is inspired by similar functionality available in
              Rust; Rust relies on the concept of a safe borrow to ensure the
              type system is not violated.</li>
          <li>The proposal includes two functions; one that works on bytes and
              another that works on code units.</li>
        </ul>
      </li>
      <li>Victor commented on the desire to ensure well-formed UTF sequences but
          noted that we don't actually enforce well-formed UTF elsewhere.</li>
      <li>Corentin acknowledged the lack of preconditions on UTF-8 encoded
          literals or in the standard library at present.</li>
      <li>Corentin stated that, if he could, he would require UTF-8 literals to
          be well-formed.</li>
      <li>Corentin explained that the proposed "unchecked" variant is
          intentionally named to sound scary.</li>
      <li>Robin opined that it seems a bit odd to impose such considerations for
          the proposed conversions when the subscript operator doesn't impose
          preconditions on data being well-formed.</li>
      <li>Robin explained that it seems weird since the type itself doesn't
          offer any guarantees.</li>
      <li>Corentin replied that the standard library is, unfortunately, focused
          solely on code units; <tt>std::basic_string</tt> is just a sequence of
          code units.</li>
      <li>Corentin described the use case he has in mind; passing data to a
          function that has such a precondition.</li>
      <li>Corentin noted that nothing otherwise prevents unintentionally
          passing, e.g., EBCDIC, to a function that expects UTF-8 when
          performing a conversion from <tt>char</tt> to <tt>char8_t</tt>.</li>
      <li>Robin observed that Latin-1 data will appear to be valid UTF-8 when
          the data contains only ASCII characters; it is the semantic that is
          important.</li>
      <li>Corentin agreed that it isn't possible, in general, to know if data
          was correctly constructed because mojibake doesn't necessarily produce
          ill-formed encoded text.</li>
      <li>Robin expressed some discomfort with the "unchecked" terminology since
          the check doesn't ensure that the semantic was honored.</li>
      <li>Tom observed that, with a suitable contracts facility, a function with
          a narrow contract that consumes the converted data would have a
          precondition for well-formed text.</li>
      <li>Corentin responded by stating that a checked version isn't proposed at
          this point; the intent is to provide a scary looking function that
          makes sure the programmer is aware that they don't necessarily have
          valid UTF-8 following the conversion.</li>
      <li>Tom expressed gratitude for that explanation as helpful to explain the
          motivation for the "unchecked" terminology.</li>
      <li>Corentin directed discussion back to core functionality concerns and
          noted that the proposed functions are intended to provide a low level
          interface; one for which there might be motivation to add a
          wrapper.</li>
      <li>Corentin expressed concern that an ergonomic wrapper might provide a
          false sense of security and noted that it would be very easy to
          produce UB if a called function stashes pointers.</li>
      <li>Tom asked how close <tt>std::start_lifetime_as_array()</tt> comes to
          being the core language facility needed.</li>
      <li>Corentin replied that it is very close to being what is needed, but
          that Clang doesn't implement it yet.</li>
      <li>Tom shared a Compiler Explorer link:
          <a href="https://godbolt.org/z/9Tejj9TPs">https://godbolt.org/z/9Tejj9TPs</a>.</li>
      <li>Robin commented that ICU is one of the projects that uses
          <tt>char16_t</tt>.</li>
      <li>Robin stated that the ICU maintainers have looked at <tt>char8_t</tt>
          and have added some functions that work with it.</li>
      <li>Robin noted that the ICU maintainers have asked how they can enable
          interoperability with all of the character types but that they have
          not received a helpful answer.</li>
      <li>Robin offered to get Corentin in touch with the ICU maintainers to
          discuss how this would be useful to ICU.</li>
      <li>Corentin replied that Tom has investigated what ICU does at present;
          it uses a volatile asm statement as a rudimentary alias barrier, but
          that doesn't fully work.</li>
      <li>Robin asked if the proposed feature would work for ICU.</li>
      <li>Tom replied that the intent is for it to work for ICU and stated that
          if it doesn't, then we probably wouldn't want to standardize it.</li>
      <li>Mark asked if the proposed functions provide access to just the
          element a pointer points to or if they provide access to a range of
          elements.</li>
      <li>Corentin replied that answers to such questions are dependent on what
          we can do within the core language; we need to determine if the
          interface requires an explicit range.</li>
      <li>Tom noted that it is complicated and posed a hypothetical question of
          whether replacing a portion of the elements in an array via the
          converted type would end the lifetime of the entire array.</li>
      <li>Corentin replied that the same core question applies for any
          replacement of a subobject.</li>
      <li>Corentin noted that such questions might be more relevant for the
          specification than for implementations.</li>
      <li>Mark objected to referring to the proposed operation as a cast.</li>
      <li>Corentin responded by stating that it is similar to
          <tt>reinterpret_cast</tt>.</li>
      <li>Corentin expressed that he is open to a better name, but that he wants
          a name that will scare programmers away from casually using it.</li>
      <li>Tom directed discussion back to the previously shared
          <a href="https://godbolt.org/z/9Tejj9TPs">Compiler Explorer link</a>
          and asked if <tt>g()</tt> looks representative of a common use
          case.</li>
      <li>Corentin noted that the example is unsafe if <tt>f()</tt> stashes the
          pointer passed to it.</li>
      <li>Corentin stated that he would expect libraries to provide overloads
          that use these conversions as implementation detail when it is known
          to be safe to do.</li>
      <li>Robin provided a hypothetical example of a date parsing function that
          accepts a pointer to <tt>wchar_t</tt> and uses the proposed features
          to forward it internally to a function that works with
          <tt>char16_t</tt>.</li>
      <li>Robin asked whether the use of the proposed conversion feature would
          destroy the caller's <tt>wchar_t</tt> string.</li>
      <li>Corentin responded that the caller is only affected if the callee
          doesn't undo the operation.</li>
      <li>Corentin noted that the proposed functionality would only work with
          types like <tt>char</tt> that are transparently replaceable.</li>
      <li>Tom asked if <tt>std::start_lifetime_as</tt> has been implemented for
          gcc yet.</li>
      <li>Corentin replied that he is unaware of it being implemented anywhere
          yet.</li>
      <li>Corentin noted that implementation requires more than just frontend
          work.</li>
      <li>Robin stated that, given the low level interfaces proposed, the first
          thing he would do is write an RAII wrapper to ensure conversions are
          reversed.</li>
      <li>Robin asked if the standard library should provide such a
          wrapper.</li>
      <li>Corentin replied that he and Tom have discussed that multiple
          times.</li>
      <li>Tom opined that Robin is right; that programmers will implement an
          RAII type to be sure conversions are undone.</li>
      <li>Tom suggested we do the following:
        <ul>
          <li>Ask Jens to schedule time in CWG to discuss the object model
              concerns.</li>
          <li>Once we have a better idea of the core language constraints,
              schedule time with the ICU TC to discuss how and whether the
              feature could be used with ICU.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Tom announced that the next meeting will be 2024-06-12 and that we have
      LWG issues to discuss ahead of the St. Louis meeting.</li>
  <li>Robin informed the group that be will be unable to attend the next meeting
      on June 12th.</li>
</ul>


<h1 id="2024_06_12">June 12th, 2024</h1>

<h2>Draft agenda:</h2>

<ul>
  <li><a href="https://cplusplus.github.io/LWG/issue4070">LWG issue 4070: Transcoding by std::formatter&lt;std::filesystem::path&gt;</a>.</li>
  <li><a href="https://cplusplus.github.io/LWG/issue4087">LWG issue 4087: Standard exception messages have unspecified encoding</a>.</li>
  <li><a href="https://cplusplus.github.io/LWG/issue4090">LWG issue 4090: Underspecified use of locale facets for locale-dependent std::format</a>.</li>
</ul>

<h2>Attendees:</h2>

<ul>
  <li>Braden Ganetsky</li>
  <li>Eddie Nolan</li>
  <li>Jens Maurer</li>
  <li>Mark de Wever</li>
  <li>Nathan Owen</li>
  <li>Steve Downey</li>
  <li>Tom Honermann</li>
  <li>Victor Zverovich</li>
</ul>

<h2>Meeting summary:</h2>

<ul>
  <li><a href="https://cplusplus.github.io/LWG/issue4070">LWG issue 4070: Transcoding by std::formatter&lt;std::filesystem::path&gt;</a>:
    <ul>
      <li>Steve introduced the issue.</li>
      <li>Victor, as author of the paper that introduced the wording the issue
          is concerned with, confirmed that the intent is to first perform
          substitution for ill-formed code unit sequences and then to transcode
          the result.</li>
      <li><em>[ Editor's note: The related paper is
          <a href="https://wg21.link/p2845r8)">P2845R8 (Formatting of std::filesystem::path)</a>. ]</em></li>
      <li>Victor expressed agreement with the issue author that the wording is
          lacking for non-escaped paths.</li>
      <li>Victor opined that the resolution is correct with the exception of an
          issue Tom pointed out in the second part of the proposed
          resolution.</li>
      <li><em>[ Editor's note: See
          <a href="https://lists.isocpp.org/sg16/2024/06/4332.php">Tom's 2024-06-12 email with subject "Agenda for the 2024-06-12 SG16 meeting - TODAY"</a>.</em>
          <blockquote class="quote">
            With respect to the PR, I think the proposed update to
            implementation-defined behavior is subtly incorrect;
            the implementation-defined behavior comes into play when
            the ordinary literal encoding is not UTF-8
            (an implementation may still convert to UTF-8 when the
            ordinary literal encoding is not UTF-8).
          </blockquote>
          <em>]</em>
      </li>
      <li>Tom suggested replacing the proposed
          "and not converting from <tt>wchar_t</tt> to UTF-8"
          wording with "and the literal encoding is not UTF-8".</li>
      <li>Tom noted that the <tt>wchar_t</tt> encoding is still implementation
          defined, but that is unrelated to the particular
          implementation-defined behavior that is intended to be conveyed for
          this issue.</li>
      <li>Steve summarized that, if the environment is fully Unicode, then the
          behavior is completely specified.</li>
      <li>Tom clarified that this is specific to when the ordinary literal
          encoding is UTF-8.</li>
      <li>Steve noted that this part of the wording is a title for an index
          entry that links back to
          <a href="https://eel.is/c++draft/fs.path.fmtr.funcs#:transcoding_of_a_formatted_path_when_charT_and_path::value_type_differ">[fs.path.fmtr.funcs]</a>;
          the intent is to describe the case well enough so someone looking
          through the implementation-defined behavior index can find it.</li>
      <li>Victor expressed agreement that the proposed update to the
          implementation-defined behavior index should be updated as Tom
          suggested.</li>
      <li>Victor stated that the first part of the proposed update to replace
          "escaped path" with "(possibly escaped) string" looks correct.</li>
      <li>Jens stated that, with respect to the implementation-defined behavior
          index, the entries are intended to provide a headline; the text
          shouldn't be wrong but doesn't have to be complete either.</li>
      <li>Jens noted that the current text is not accurate because the behavior
          is not implementation-defined in some cases when <tt>CharT</tt> is
          <tt>char</tt> and <tt>path::value_type</tt> is <tt>wchar_t</tt>.</li>
      <li>Jens observed that the wording refers to the literal encoding when the
          ordinary literal encoding is presumaby intended; the existing wording
          could be misread as referring to the wide literal encoding.</li>
      <li>Jens asserted that the ambiguous use of "literal encoding" is a
          separate issue.</li>
      <li>Jens expressed support for the suggestion to update the proposed
          resolution with the "and the literal encoding is not UTF-8" change and
          noted this maintains consistency with the existing wording, ambiguous
          though it might be.</li>
      <li>Tom asked if both references to "literal encoding" should be changed
          to "ordinary literal encoding".</li>
      <li>Jens replied that perhaps they should be, but that such a change is a
          separate issue.</li>
      <li>Steve reported that there are many places in the standard with this
          ambiguity and that cleaning it up should be a one-time thing where we
          go through and clarify whether we actually mean ordinary literal
          encoding or some other encoding.</li>
      <li>Steve shared a perception that we would be in favor of such a
          change.</li>
      <li>Jens stated that all we're trying to do here is correctly quote the
          normative text.</li>
      <li>Steve summarized his impression of the emerging consensus; we want to
          accept the proposed resolution for the first clause and change the
          second clause as discussed.</li>
      <li>Jens asked why the proposed resolution for the second clause doesn't
          work and directed himself to review Tom's email.</li>
      <li>Steve replied that the implementation-defined behavior is not
          contingent on the selected encoding conversion but on the criteria
          used to determine what encodings to convert between; an implementation
          can opt to convert to UTF-8 when the ordinary literal encoding is not
          UTF-8 but it's up to implementations to decide how best to serve their
          users.</li>
      <li>Jens acknowledged the distinction and asked Tom if he is ok with not
          introducing "ordinary" for the sake of consistency with the normative
          wording or whether the scope of the issue should be increased.</li>
      <li>Tom expressed being content with inserting "ordinary" as part of a
          separate cleanup or separate LWG issue as Steve suggested.</li>
      <li>Jens summarized, so the green text in the second clause should be
          "and the literal encoding is not UTF-8."</li>
      <li>Tom confirmed.</li>
    </ul>
  </li>
  <li><a href="https://cplusplus.github.io/LWG/issue4087">LWG issue 4087: Standard exception messages have unspecified encoding</a>:
    <ul>
      <li>Victor introduced the issue:
        <ul>
          <li><tt>std::exception</tt> is one of the few remaining standard
              library types that lacks a formatter for
              <tt>std::format()</tt>.</li>
          <li>The standard does not specify the encoding for the string returned
              by the <tt>what()</tt> member function but suggests that the
              string can be converted for display as a <tt>wstring</tt>.</li>
          <li>The lack of a definite encoding makes it impossible to implement a
              proper formatter.</li>
          <li>The example in the LWG issue uses a filesystem path, but the
              problem is more general.</li>
          <li><tt>filesystem_error</tt> is one of the most obvious and
              problematic cases because the initial exception object might be
              constructed with a <tt>what_arg</tt> in one encoding and a
              <tt>path</tt> object for a filename in a different encoding that
              are somehow combined and then formatted using the ordinary literal
              encoding.</li>
          <li>The proposed resolution is incomplete; just a first attempt to
              propose something to start the discussion.</li>
          <li>The desired behavior should probably be compatible with the
              ordinary literal encoding since typical usage is likely to combine
              strings in the ordinary literal encoding with the output of
              <tt>what()</tt>.</li>
          <li>An email forwarded to SG16 describes four options that nicely
              summarizes options to choose from.</li>
          <li><em>[ Editor's note: See
              <a href="https://lists.isocpp.org/sg16/2024/06/4336.php">Victor's 2024-06-12 email with subject "Fwd: [isocpp-lib] Issue 4087: Standard exception messages have unspecified encoding"</a>.
              ]</em>
          </li>
          <li>Tom separately suggested use of the locale encoding.</li>
        </ul>
      </li>
      <li>Steve stated that, barring any external constraints, he would expect
          the exception message to be in the current execution encoding.</li>
      <li>Steve noted that the execution encoding may not match the literal
          encoding; that is a common source of broken text, but that is the
          state of the world.</li>
      <li>Steve asserted that <tt>char</tt>-based text must be assumed to be in
          the execution encoding in the absence of other information.</li>
      <li>Victor stated that, at the very least, the encoding should be
          specified; it isn't currently.</li>
      <li>Jens agreed.</li>
      <li>Steve agreed and noted that doing so is especially important since
          text in the message may be user-provided for some derived
          classes.</li>
      <li>Tom asked, referring to the wording in the remarks that states,
          "The message may be a null-terminated multibyte string", whether the
          term "multibyte" implies the locale encoding.</li>
      <li>Jens replied that it doesn't.</li>
      <li>Tom noted the association of "multibyte" with functions like
          <tt>mbstowcs()</tt>.</li>
      <li>Tom lamented the vague "multibyte" specification.</li>
      <li>Steve asked if NTBS includes multibyte strings.</li>
      <li>Jens dove into the C++ standard wording and reported:
        <ul>
          <li><a href="https://eel.is/c++draft/byte.strings#1">[byte.strings]p1</a>:
          <blockquote class="quote">
            A <i>null-terminated byte string</i>, or NTBS, is a character
            sequence whose highest-addressed element with defined content has
            the value zero (the <i>terminating null character</i>);
            no other element in the sequence has the value zero.
          </blockquote>
          </li>
          <li><a href="https://eel.is/c++draft/multibyte.strings#2">[multibyte.strings]p2</a>:
          <blockquote class="quote">
            A <i>null-terminated multibyte string</i>, or NTMBS, is an NTBS that
            constitutes a sequence of valid multibyte characters, beginning and
            ending in the initial shift state.
          </blockquote>
          </li>
          <li><a href="https://eel.is/c++draft/multibyte.strings#1">[multibyte.strings]p1</a>:
          <blockquote class="quote">
            A <i>multibyte character</i> is a sequence of one or more bytes
            representing the code unit sequence for an encoded character of the
            <i>execution character set</i>.
          </blockquote>
          </li>
        </ul>
      </li>
      <li>Steve commented that this scenario presents many interesting ways to
          produce broken text when combining <tt>what()</tt> output with string
          literals and user-provided data; one can only hope that someone will
          be able to reconstruct something useful.</li>
      <li>Jens continued looking at wording for NTBS in the C standard:
        <ul>
          <li><em>[ Editor's note: the following quotes from the C standard
              correspond to
              <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2176.pdf">WG14 N2176 (Programming languages â€” C)</a>;
              the final draft before the publication of C17.
              I don't know which revision of the C standard Jens was consulting.
              ]</em></li>
          <li>7.22.8.1p2 (The <tt>mbstowcs</tt> function):
          <blockquote class="quote">
            The <tt>mbstowcs</tt> function converts a sequence of multibyte
            characters that begins in the initial shift state from the array
            pointed to by <tt>s</tt> into a sequence of corresponding wide
            characters and stores not more than <tt>n</tt> wide characters into
            the array pointed to by <tt>pwcs</tt>.
            No multibyte characters that follow a null character (which is
            converted into a null wide character) will be examined or converted.
            Each multibyte character is converted as if by a call to the
            <tt>mbtowc</tt> function, except that the conversion state of the
            <tt>mbtowc</tt> function is not affected.
          </blockquote>
          </li>
          <li>7.22.7p1 (Multibyte/wide character conversion functions):
          <blockquote class="quote">
            The behavior of the multibyte character functions is affected by the
            <tt>LC_CTYPE</tt> category of the current locale.
            For a state-dependent encoding, each function is placed into its
            initial conversion state at program startup and can be returned to
            that state by a call for which its character pointer argument,
            <tt>s</tt>, is a null pointer.
            Subsequent calls with <tt>s</tt> as other than a null pointer cause
            the internal conversion state of the function to be altered as
            necessary.
            A call with <tt>s</tt> as a null pointer causes these functions to
            return a nonzero value if encodings have state dependency, and zero
            otherwise.
            Changing the <tt>LC_CTYPE</tt> category causes the conversion state
            of these functions to be indeterminate.
          </blockquote>
          </li>
        </ul>
      </li>
      <li>Jens summarized; <tt>mbstowcs()</tt> converts an NTMBS to a wide
          string using a means of conversion that is dependent on
          <tt>LC_CTYPE</tt>.</li>
      <li>Jens concluded; the set of valid multibyte character sequences and
          their meanings are therefore dependent on the <tt>LC_CTYPE</tt> locale
          category that is presumably obtained from the global locale or a
          thread local locale.</li>
      <li>Steve noted that, in our current terminology, the encoding associated
          with that locale is referred to as the execution encoding.</li>
      <li>Jens lamented the absence of an explicit locale in the exception
          library and noted that the C++ standard library tends to make use of
          the locale explicit in its interface; for example, iostreams allows a
          locale to be imbued so that use of global locale state can be
          avoided.</li>
      <li>Steve observed that use of an explicit locale would avoid the builtin
          race condition that exists while the exception is in flight.</li>
      <li>Tom commented that providing a locale in a call to <tt>what()</tt>
          wouldn't work since the message that is returned is constructed much
          earlier.</li>
      <li>Jens agreed and stated it would have to be provided when the exception
          is generated.</li>
      <li>Tom repeated Steve's observation that the locale could change in
          between construction of the exception object and the call to
          <tt>what()</tt>.</li>
      <li>Jens repled that the behavior would at least be well-defined; if the
          message returned by <tt>what()</tt> is gibberish because the locale
          changed, then it is the programmer's fault.</li>
      <li>Jens commented that this discussion is hypothetical anyway since there
          is no way to specify a locale when the exception object is
          created.</li>
      <li>Jens asked if <tt>std::filesystem</tt> has locale dependencies.</li>
      <li>Tom replid that it does.</li>
      <li>Victor explained that <tt>std::filesystem::path</tt> uses the
          "operating system dependent current encoding" for paths in ordinary
          character strings.</li>
      <li>Tom stated that some of the <tt>std::filesystem::path</tt>
          constructors allow a locale object to be provided.</li>
      <li><em>[ Editor's note: See
          <a href="https://eel.is/c++draft/fs.path.construct">[fs.path.construct]</a>.
          ]</em></li>
      <li>Jens reviewed the example in the LWG issue and observed that querying
          a file size doesn't seem like a situation in which a locale makes much
          sense; there is nowhere to pass a locale in and a programmer would not
          expect to have to pass one in to such a function.</li>
      <li>Steve replied that the example illustrates the general problem.</li>
      <li>Tom stated that the only way mojibake is avoided is if the global
          locale remains consistent from the time the exception object is
          created to when it is received.</li>
      <li>Victor asked if we concluded that NTBS always implies the global
          locale.</li>
      <li>Jens replied that NTMBS implies the global locale.</li>
      <li>Steve observed that the message could have been created with a string
          literal.</li>
      <li>Victor noted that the normative wording requires an NTBS.</li>
      <li>Tom clarified that the remarks state NTMBS but that the text states
          NTBS; it isn't consistent.</li>
      <li>Jens reviewed the wording again:
        <ul>
          <li><a href="https://eel.is/c++draft/support.exception#exception-5">[exception]p5</a>:
          <blockquote class="quote">
            <em>Returns</em>: An implementation-defined NTBS.
          </blockquote>
          </li>
          <li><a href="https://eel.is/c++draft/support.exception#exception-6">[exception]p6</a>:
          <blockquote class="quote">
            <em>Remarks</em>: The message may be a
            <a href="https://eel.is/c++draft/multibyte.strings#def:ntmbs">null-terminated multibyte string</a>,
            suitable for conversion and display as a <tt>wstring</tt>
            (<a href="https://eel.is/c++draft/string.classes">[string.classes]</a>,
            <a href="https://eel.is/c++draft/locale.codecvt)">[locale.codecvt]</a>).
            The return value remains valid until the exception object from which
            it is obtained is destroyed or a non-const member function of the
            exception object is called.
          </blockquote>
          </li>
        </ul>
      </li>
      <li>Jens summarized; return of an NTBS is required, but an NTMBS is an
          NTBS per
          <a href="https://eel.is/c++draft/multibyte.strings#2">[multibyte.strings]p2</a>
          so the remarks explicitly note the permission an implementation has to
          return an NTMBS as opposed to just an NTBS.</li>
      <li>Jens suggested a way forward; for the case of an NTMBS, where wording
          is already present that states the message is suitable for conversion
          and display as a wide string, we can clarify that it was suitable for
          such conversion at the time of construction.</li>
      <li>Jens explained that this reflects the requirement that
          <tt>LC_CTYPE</tt> be consulted at construction time, not when
          <tt>what()</tt> is called; this is what is currently missing from the
          remarks.</li>
      <li>Jens noted that the cross-reference to
          <a href="https://eel.is/c++draft/locale.codecvt">[locale.codecvt]</a>
          is already present, so we know the encoding requirements.</li>
      <li>Jens explained that we don't yet have a solution for the return
          wording where the minimum requirement is just for an NTBS and
          suggested it might be best to just not state anything about it.</li>
      <li>Tom stated that solving the problem presented for
          <tt>std::format()</tt> requires addressing two concerns:
        <ol>
          <li>How the file path is encoded in the message.</li>
          <li>What encoding is used to interpret the message.</li>
        </ol>
      </li>
      <li>Tom suggested that, for the second issue, we can specify an
          "as-if using mbtowc()" or similar approach; and, if the global locale
          has changed or if the message was not encoded as an NTMBS, then you
          get what you get; sometimes you get mojibake.</li>
      <li>Victor asked for clarification regarding which global locale and
          explained that there is more than one; the C++ standard library
          maintains one that is separate from the C locale.</li>
      <li>Steve mentioned that the various parts of each locale can also be
          changed independently.</li>
      <li>Jens provided additional detail; There is a locale maintained by the C
          standard library that can be changed by calling <tt>setlocale()</tt>
          and a separate C++ locale that can be changed by calling
          <tt>std::setlocale()</tt>.</li>
      <li>Tom noted that <tt>std::setlocale()</tt> also calls
          <tt>setlocale()</tt> to change the C locale in some cases.</li>
      <li>Jens replied that it isn't required to do so and that both can be
          expected to match at the start of the program.</li>
      <li>Jens asked which locale should be queried for this scenario and
          suggested it is presumably the C++ locale.</li>
      <li>Tom disagreed because the reference for the related conversion
          functions refers to the C conversion functions that use the C
          locale.</li>
      <li>Jens asked where that reference is.</li>
      <li>Tom became confused, stated he might have misunderstood earlier, and
          asked if there wasn't a reference to the <tt>mbtowc()</tt> family of
          functions.</li>
      <li>Jens responded that the actual cross referense is to the
          <tt>std::codecvt</tt> facet; the C++ class intended for use to convert
          from one character encoding to another.</li>
      <li>Tom suggested investigating what implementations actually do; to try
          setting the C and C++ locales differently and then see which encoding
          is used.</li>
      <li>Jens asked for clarification; which encoding is used for what?</li>
      <li>Tom replied which encoding is used to produce the exception object;
          the encoding used when, for example, converting <tt>char</tt>-based
          file paths on Windows for inclusion in the exception message.</li>
      <li>Jens stated that the issue refers to the OS dependent current encoding
          for path names which would be something like Windows-1251 for this
          example.</li>
      <li>Victor opined that path considerations are a red herring because paths
          have their own unrelated encoding.</li>
      <li>Victor asserted that what is lacking is specification for what the
          target encoding is for the exception message; what a path should be
          converted to; not the conversions that <tt>std::path</tt>
          implements.</li>
      <li>Steve attempted to approach the issue from a programmer's perspective;
          and asked what encoding should be targeted when producing a message
          for a new exception class.</li>
      <li>Steve suggested the right encoding is the current exception encoding
          as defined by the locale as the right target encoding.</li>
      <li>Eddie asked for clarification of which locale.</li>
      <li>Jens answered with the global C++ locale and explained that there is
          no reference to the C locale in the cross reference; the redirection
          to <tt>std::codecvt</tt> implies the global C++ locale.</li>
      <li>Victor asked for clarification regarding what was meant in earlier
          comments regarding the locale used at exception object construction
          time as opposed to when <tt>what()</tt> is called.</li>
      <li>Steve responded that the locale can be changed asynchronously; it can
          change in between the point where the exception object is constructed
          and <tt>what()</tt> is called; such a change is problematic.</li>
      <li>Jens asked how the global C++ locale is queried and changed.</li>
      <li>Further discussion identified the default <tt>std::locale</tt>
          constructor
          (<a href="https://eel.is/c++draft/locale.cons">[locale.cons]</a>)
          and <tt>std::global()</tt>
          (<a href="https://eel.is/c++draft/locale.statics)">[locale.statics]</a>).</li>
      <li>Jens summarized how these work; the default <tt>std::locale</tt>
          constructor produces a copy of the current C++ locale; calls to
          <tt>std::global()</tt> change the C++ locale and, if a named locale is
          specified, the C locale is changed as well, otherwise any effect on
          the C locale is implementation-defined.</li>
      <li>Jens pondered the consequences of these behaviors; race conditions
          aren't relevant here; the standard library is required to handle
          unsynchronized calls to <tt>std::global()</tt> and construction of new
          <tt>std::locale</tt> objects.</li>
      <li>Victor observed that an exception class constructor could have
          multiple parameters and asked what happens if the locale changes in
          between processing them.</li>
      <li>Jens replied that the program is broken.</li>
      <li>Victor asked for clarification.</li>
      <li>Jens replied that nothing prevents the locale being changed and that
          the best atomicity guarangee available is the default
          <tt>std::locale</tt> constructor; if you call it multiple times in
          close proximity and get different results, well, tough luck.</li>
      <li>Tom explained that consistency requires procuring a
          <tt>std::locale</tt> copy and reusing it until the message is
          complete.</li>
      <li>Victor suggested that should be specified somehow; that messages are
          formed in one locale, not multiple.</li>
      <li>Steve equated the suggestion to instructing programmers not to do
          broken things.</li>
      <li>Victor stated that this still leads to an exception class that
          potentially needs to be sensitive to multiple locales.</li>
      <li>Jens explained that the exception class constructor will need to use
          the locale that is current at the time of its invocation; if the
          constructor needs to, for example, combine some text with a message
          produced by a <tt>std::system_error</tt> exception, there isn't
          anything we can do since the encoding used to create it can't be
          queried.</li>
      <li>Jens quipped that changing the global locale is a bad idea and we
          should convey that to the extent that we can.</li>
      <li>Steve reiterated that the best we can do is state that <tt>what()</tt>
          returns an NTBS in the locale encoding that was in effect when the
          exception object was constructed.</li>
      <li>Jens expressed uncertainty about the requirements for an NTBS; it is
          fairly clear that an implementation that returns an NTMBS should
          return it encoded in the current locale at the time of construction;
          but an NTBS doesn't necessarily have sufficient capabilities to
          represent, for example, the characters of both an explanatory string
          and a path.</li>
      <li>Jens suggested that the best we might be able to do is to state that
          an implementation-defined NTBS is returned and then provide a
          recommended practice that describes the NTMBS case with its locale
          dependency and leave the rest to QoI.</li>
      <li>Jens noted that, on a small system where there is no practical choice
          of encoding, an NTBS likely suffices.</li>
      <li>Steve agreed, noted that an NTMBS might still be a single byte
          encoding, and suggested clarifying in the remarks that if the message
          returned by <tt>what()</tt> doesn't reflect the locale encoding at
          the time that the exception object was created, then your contract has
          been broken.</li>
      <li>Jens asked if we are in agreement to refine the NTMBS wording since we
          can associate an encoding in that case, but to leave out any
          guarantees since they don't really exist.</li>
      <li>Steve replied that the only guarantee provided is that the message
          string will be null terminated.</li>
      <li>Jens described that guarantee as not particularly useful, but adding
          clear recommended practice could be helpful on the QoI side; users can
          always ask implementors for improvements.</li>
      <li>Steve volunteered to draft wording for a new proposed resolution.</li>
      <li>Victor lamented that direction since it doesn't address the core issue
          that we don't know what encoding to use with <tt>what()</tt>; this
          just retains the current broken state.</li>
      <li>Steve agreed, but indicated this as the state of the world; the
          remarks provide QoI guidance.</li>
      <li>Steve noted that user data that isn't properly encoded could end up in
          the message; there isn't a guarantee that a non-lossy properly encoded
          message can be produced.</li>
      <li>Tom stated that <tt>std::format()</tt> can be specified to interpret
          the <tt>what()</tt> message as an NTMBS in the current locale with
          debug-print-like escaping for ill-formed code unit sequences.</li>
      <li>Steve agreed; this is foreign data and it should therefore be treated
          with suspicion; treat it as an NTMBS in the current locale encoding,
          and perform a best-effort formatting.</li>
      <li>Eddie asked if we can't require an NTMBS.</li>
      <li>Jens asked if we know what standard library implementations actually
          do.</li>
      <li>Jens noted that, if the postconditions of <tt>what()</tt> are
          strengthened, than we likewise have to strengthen the preconditions
          of, e.g., the <tt>std::logic_error</tt> constructor.
          However, <tt>what()</tt> is also currently required to return the
          exact bytes that were provided to the constructor, so no transcoding
          is permitted; should we invalidate existing code that depends on
          getting exact bytes back?</li>
      <li>Eddie replied that we probably shouldn't.</li>
      <li>Tom expressed agreement with not invalidating existing source
          code.</li>
      <li>Steve noted that, if the locale encoding and the ordinary literal
          encoding aren't compatible, deep problems emerge producing any output
          whatsoever; hello world starts to fail.</li>
      <li>Jens acknowledged, but noted that violating the preconditions of a
          library function is library UB and that isn't a good place to be.</li>
      <li>Steve agreed regarding the exception construction and <tt>what()</tt>
          behavior, but noted there is more flexibility within
          <tt>std::format()</tt>.</li>
      <li>Jens agreed; the formatter can do what it likes with the
          <tt>what()</tt> output.</li>
      <li>Jens suggested that the recommended practice updates could direct
          implementors to construct a valid NTMBS for the messages they create
          on their own, but we probably can't do more than that.</li>
      <li>Jens lamented being unable to rely on UTF-8 everywhere.</li>
      <li>Victor expressed concern that the example might have been
          mischaracterized because it involves paths; if the encoding of the
          path is known, then perfect output can be produced with arbitrary
          binary data formatted with an escape mechanism.</li>
      <li>Jens asked if it would be desirable to expose the
          <tt>std::filesystem::path</tt> object in the exception class so that
          the formatter could use it directly.</li>
      <li>Victor stated that the path is already exposed in the message and can
          therefore be properly encoded within it.</li>
      <li>Jens agreed that <tt>what()</tt> should not return text with parts in
          different encodings; as QoI inline with the recommended practice we're
          trying to formulate, a consistently encoded message should be
          produced.</li>
      <li>Steve noted that the "in the native format" wording used by
          <tt>std::filesystem::path</tt> is vague and a source of confusion, but
          can be remediated by an implementor; unlike the exception classes that
          require <tt>what()</tt> to return the exact same string provided to
          the class constructor.</li>
      <li>Jens agreed that implementors can be gently pushed in the right
          direction and opined that a reasonable fix doesn't seem to exist for
          all of the exception classes.</li>
      <li>Tom agreed and asked if it would be a reasonable request to
          implementors to change existing code to embed paths in exception
          messages using the debug-print escape mechanism that
          <tt>std::format()</tt> uses for paths.</li>
      <li>Jens opined that it is; an NTMBS with differently encoded parts is
          untenable.</li>
      <li>Victor asked Mark to comment on making such a change.</li>
      <li>Mark expressed uncertainty since it has implications for existing
          users, but agreed that it would be good to investigate further.</li>
      <li>Mark noted that libc++ is pretty much UTF-8 only with some
          accommodations for Windows.</li>
      <li>Jens remarked that <tt>std::filesystem_error</tt> has constructors
          with three parameter types; a "what_arg" <tt>std::string</tt>,
          <tt>std::filesystem::path</tt>, and <tt>std::error_code</tt>; thus
          three potentially relevant encodings; something user-defined and
          unknown, the path encoding, and the encoding the implementation uses
          for <tt>std::system_error</tt>; thus the problem is a bit larger and
          there are requirements on the user to provide the "what_arg" in the
          right encoding.</li>
      <li>Jens noted that we can probably impose additional requirements on
          <tt>std::filesystem_error</tt> specifically since there is good reason
          to do so.</li>
      <li>Steve indicated he would draft some proposed updates for the
          remarks.</li>
      <li>Jens stated that there also needs to be a change made to the
          guarantees provided by <tt>std::filesystem_error::what()</tt> as it
          states that an NTBS is returned; that can be strengthened and a
          precondition added to the "what_arg" argument of the
          constructors.</li>
      <li><em>[ Editor's note: see
          <a href="https://eel.is/c++draft/fs.filesystem.error.members#7">[fs.filesystem.error.members]p7</a>.
          ]</em></li>
      <li>Jens suggested that implementors might be open to being convinced to
          support such a change specifically for
          <tt>std::filesystem_error</tt>.</li>
    </ul>
  </li>
  <li><a href="https://cplusplus.github.io/LWG/issue4090">LWG issue 4090: Underspecified use of locale facets for locale-dependent std::format</a>:
    <ul>
      <li>Jens provided an introduction.
        <ul>
          <li><tt>std::format()</tt> can be passed a <tt>std::locale</tt>
              parameter and standard formatters support a <tt>L</tt> specifier
              to opt in to locale dependent formatting.</li>
          <li><a href="https://eel.is/c++draft/format.string.std#17">[format.string.std]p17</a>
              states:
          <blockquote class="quote">
            For integral types, the locale-specific form causes the context's
            locale to be used to insert the appropriate digit group separator
            characters.
          </blockquote>
          </li>
          <li>There is likely a similar statement elsewhere for floating-point
              types.</li>
          <li><em>[ Editor's note: a similar statement for floating-point types
              and <tt>bool</tt> is also present in
              <a href="https://eel.is/c++draft/format.string.std#17">[format.string.std]p17</a>.
              ]</em></li>
          <li>The wording doesn't state how the locale facilities are to be used
              to insert the digit group separator characters.</li>
          <li>For iostreams, when and how the locale facilities are used is
              proscribed.</li>
          <li>Programmers may imbue a locale with custom facets, so it is
              observable which locale facilities are used.</li>
          <li>The current wording doesn't indicate how a programmer can provide
              custom locale behavior; whether they should provide a custom
              <tt>std::num_put</tt> facet, a <tt>std::numpunct</tt> facet, or
              whether the <tt>std::numpunct_byname</tt> facets are
              relevant.</li>
          <li><tt>std::numpunct</tt> only supports characters that are encoded
              as a single code unit.</li>
          <li>Use of <tt>std::num_put</tt> provides a practical benefit since it
              isn't limited to single code unit output.</li>
        </ul>
      </li>
      <li>Steve observed that use of a half-width comma could be desired.</li>
      <li>Tom suggested investigating what implementations are currently
          doing.</li>
      <li>Steve enumerated the options; either specify precisely how this works
          or leave it up to programmers to negotiate with their
          implementors.</li>
      <li>Jens added another option; or tell programmers not to customize under
          threat of undefined behavior.</li>
      <li>Tom asked if Mark knew how libc++ implemented localization
          support.</li>
      <li>Mark replied that he didn't know off-hand, but that it is different
          from iostreams.</li>
      <li>Jens noted that iostreams uses <tt>std::num_put</tt>, but was unsure
          if it works on character ranges or requires iostreams.</li>
      <li>Tom reported that the Microsoft implementation does have uses of
          <tt>std::numpunct</tt> in an internal function named
          <tt>write_integral()</tt>, but has no uses of
          <tt>std::num_put</tt>.</li>
      <li>Jens observed that <tt>std::num_put</tt> has a <tt>std::ios_base</tt>
          reference parameter which would make use in a formatter awkward.</li>
      <li>Jens added that <tt>std::num_put</tt> accepts an output iterator type
          as a template type parameter which defaults to
          <tt>std::ostreambuf_iterator</tt> and noted that a type appropriate
          for a formatter could presumably be provided, but that would require
          specifying that type.</li>
      <li>Jens concluded that <tt>std::num_put</tt> might be too tied to
          iostreams to use with <tt>std::format()</tt>.</li>
      <li>Tom asked if <tt>std::format()</tt> has been shipped with
          libstdc++.</li>
      <li>Mark replied that an incomplete implementation was provided with
          gcc 13 and that gcc 14 will have more improvements.</li>
      <li>Tom reported that the libstdc++ implementation has many uses of
          <tt>std::numpunct</tt> and no uses of <tt>std::num_put</tt>.</li>
      <li>Jens confirmed and proclaimed <tt>std::numpunct</tt> the apparent
          winner.</li>
      <li>Steve opined that the wording should be updated to specify use of
          <tt>std::numpunct</tt> with the noted limitation that digit separator
          characters will be limited to those that are encoded as a single code
          unit.</li>
      <li>Jens proclaimed that it is not new news that the locale interface is
          broken and if something better comes along, we might have to extend
          <tt>std::format()</tt> to provide a way to use it.</li>
      <li>Mark opined that the proposed resolution should also address
          floating-point and boolean values.</li>
      <li>Tom asked Jens if he would offer a proposed resolution for the
          issue.</li>
      <li>Jens replied that he did not intend to.</li>
      <li>Tom asked Jens what he would like done with the issue.</li>
      <li>Jens requested that LWG be informed that SG16 determined that, after
          implementation review, the wording should be updated to specify use
          of <tt>std::numpunct</tt> for locale dependent formatting of integer,
          floating-point, and boolean values.</li>
      <li>Jens noted that a prose description can be provided and that someone
          so motivated could then morph the prose into proper wording for a
          proposed resolution.</li>
    </ul>
  </li>
</ul>


</body>
