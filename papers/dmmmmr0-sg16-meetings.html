<!doctype html public "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">

<head>
<title>SG16: Unicode meeting summaries 2022-10-12 through 2022-10-19</title>
</head>

<style type="text/css">

table#header th,
table#header td
{
    text-align: left;
}

tt {
    font-family: monospace;
}

/* Thanks to Elias Kosunen for the following CSS suggestions! */

* {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
    line-height: 125%;
}

html, body {
    background-color: #eee;
}

h1, h2, h3, h4, h5, p, span, li, dt, dd {
    color: #333;
}

p, li {
    line-height: 140%;
}

body {
    padding: 1em;
    max-width: 1600px;
}

p, li {
    -moz-osx-font-smoothing: grayscale;
    -webkit-font-smoothing: antialiased !important;
    -moz-font-smoothing: antialiased !important;
    text-rendering: optimizelegibility !important;
    letter-spacing: .01em;
}

h1, h2, h3 {
    margin-bottom: 1em;
    letter-spacing: .03em;
}

blockquote.quote
{
    margin-left: 0em;
    border-style: solid;
    background-color: lemonchiffon;
    color: #000000;
    border: 1px solid black;
}

</style>

<body style="max-width: 8.5in">

<table id="header">
  <tr>
    <th>Document Number:</th>
    <td>DXXXXR0 <em>Draft</em></td>
  </tr>
  <tr>
    <th>Date:</th>
    <td>2022-10-23</td>
  </tr>
  <tr>
    <th>Audience:</th>
    <td>SG16</td>
  </tr>
  <tr>
    <th>Reply-to:</th>
    <td>Tom Honermann &lt;tom@honermann.net&gt;</td>
  </tr>
</table>


<h1>SG16: Unicode meeting summaries 2022-10-12 through 2022-10-19</h1>

<p>
Summaries of SG16 meetings are maintained at
<a href="https://github.com/sg16-unicode/sg16-meetings">
https://github.com/sg16-unicode/sg16-meetings</a>.  This paper contains a
snapshot of select meeting summaries from that repository.
</p>

<ul>
  <li><a href="#2022_10_12">
      October 12th, 2022</a></li>
  <li><a href="#2022_10_19">
      October 19th, 2022</a></li>
</ul>

<p>
Previously published SG16 meeting summary papers:
<ul>
  <li><a href="https://wg21.link/p1080">P1080: SG16: Unicode meeting summaries 2018/03/28 - 2018/04/25</a></li>
  <li><a href="https://wg21.link/p1137">P1137: SG16: Unicode meeting summaries 2018/05/16 - 2018/06/20</a></li>
  <li><a href="https://wg21.link/p1237">P1237: SG16: Unicode meeting summaries 2018/07/11 - 2018/10/03</a></li>
  <li><a href="https://wg21.link/p1422">P1422: SG16: Unicode meeting summaries 2018/10/17 - 2019/01/09</a></li>
  <li><a href="https://wg21.link/p1666">P1666: SG16: Unicode meeting summaries 2019/01/23 - 2019/05/22</a></li>
  <li><a href="https://wg21.link/p1896">P1896: SG16: Unicode meeting summaries 2019/06/12 - 2019/09/25</a></li>
  <li><a href="https://wg21.link/p2009">P2009: SG16: Unicode meeting summaries 2019-10-09 through 2019-12-11</a></li>
  <li><a href="https://wg21.link/p2179">P2179: SG16: Unicode meeting summaries 2020-01-08 through 2020-05-27</a></li>
  <li><a href="https://wg21.link/p2217">P2217: SG16: Unicode meeting summaries 2020-06-10 through 2020-08-26</a></li>
  <li><a href="https://wg21.link/p2253">P2253: SG16: Unicode meeting summaries 2020-09-09 through 2020-11-11</a></li>
  <li><a href="https://wg21.link/p2352">P2352: SG16: Unicode meeting summaries 2020-12-09 through 2021-03-24</a></li>
  <li><a href="https://wg21.link/p2397">P2397: SG16: Unicode meeting summaries 2021-04-14 through 2021-05-26</a></li>
  <li><a href="https://wg21.link/p2512">P2512: SG16: Unicode meeting summaries 2021-06-09 through 2021-12-15</a></li>
  <li><a href="https://wg21.link/p2605">P2605: SG16: Unicode meeting summaries 2022-01-12 through 2022-06-08</a></li>
  <li><a href="https://wg21.link/p2678">P2678: SG16: Unicode meeting summaries 2022-06-22 through 2022-09-28</a></li>
</ul>
</p>


<h1 id="2022_10_12">October 12th, 2022</h1>

<h2>Draft agenda:</h2>

<ul>
  <li>Michael Kuperstein: Internationalization From the Perspective of Defect Analysis</li>
  <li>NB comment processing.</li>
</ul>

<h2>Attendees:</h2>

<ul>
  <li>Charles Barto</li>
  <li>Corentin Jabot</li>
  <li>Hubert Tong</li>
  <li>Jens Maurer</li>
  <li>Mark de Wever</li>
  <li>Mark Zeren</li>
  <li>Michael Kuperstein</li>
  <li>Nevin Liber</li>
  <li>Peter Brett</li>
  <li>Steve Downey</li>
  <li>Tom Honermann</li>
  <li>Tomasz Kamiński</li>
  <li>Victor Zverovich</li>
</ul>

<h2>Meeting summary:</h2>

<ul>
  <li>Michael Kuperstein: Internationalization From the Perspective of Defect Analysis
    <ul>
      <li><em>[ Editor's note: Michael's slides are available at
          <a href="https://github.com/sg16-unicode/sg16-meetings/blob/master/presentations/2022-10-12-i18n-presentation.pptx">https://github.com/sg16-unicode/sg16-meetings/blob/master/presentations/2022-10-12-i18n-presentation.pptx</a>.
          ]</em>
      </li>
      <li>Michael provided a brief introduction:
        <ul>
          <li>He has been working for Intel since 1996.</li>
          <li>He has been working in Intel's localization group since 2001.</li>
        </ul>
      </li>
      <li>Slide 1: Internationalization From the Perspective of Defect Analysis</li>
      <li>Slide 2: Venn Diagram</li>
      <li>Slide 3: Defects in Localized Software
        <ul>
          <li>The defect breakdown presented is from an analysis performed in
              2011.</li>
          <li>Internationalization and localization defects are usually found
              by the localization team.</li>
          <li>Localization defects can often be fixed by the localization team;
              as a result, localization teams tend to maintain their own defect
              database.</li>
          <li>Localization defects that require a fix by a development team tend
              to first be reported in a defect database maintained by the
              localization team and then migrated to another team's defect
              database.</li>
        </ul>
      </li>
      <li>Slide 4: World-Readiness Defect Types
        <ul>
          <li>Most localization defects are due to UI, Layout, or formatting
              issues.</li>
          <li>The next largest category of defects are due to translation
              issues.</li>
          <li>Defects due to non-translated and embedded strings make up the
              next largest two categories.</li>
          <li>Defects due to encoding issues make up the smallest defect
              category, but are very important.</li>
          <li>For software developers, internationalization and localization
              support is a small part of their total effort, but an important
              part.</li>
        </ul>
      </li>
      <li>Slide 5: Code Scans: I18N Issues by Volume
        <ul>
          <li>The top two categories of issues found by code scans are
              hard-coded strings and hard-coded formatting.</li>
        </ul>
      </li>
      <li>Slide 6: I18N Issues by Volume – Honorable Mentions
        <ul>
          <li>A consistent internal locale insensitive representation of dates
              is necessary to prevent failures.</li>
          <li>Steve confirmed that the general shape of relative error counts
              presented matches his experience.</li>
          <li>Steve reported that products he has worked on avoid localized
              formatting of dates so as to avoid confusion; likewise, "." is
              consistently used for decimal point.</li>
        </ul>
      </li>
      <li>Slide 7: More than 150 string formatting functions in C/C++ on Windows
        <ul>
          <li>Charlie noted that most of those 150 functions wrap a common
              underlying formatting function.</li>
          <li>Corentin suggested bumping the number to 151 now that
              <tt>std::format()</tt> has been standardized.</li>
        </ul>
      </li>
      <li>Slide 8: Defaults: Fall into the pit of success
        <ul>
          <li>Use of UTF-16 made it easier to produce the right results on
              Windows.</li>
          <li>A string class that basically does the right thing makes it easier
              to get the right result.</li>
          <li>The goal is to guide developers towards doing the right
              thing.</li>
          <li>Many programmers like string interpolation.</li>
          <li>ICU discussion:
            <ul>
              <li>Charlie reported that the ICU included in Windows doesn't
                  expose the C++ interface.</li>
              <li>Michael noted that, in .NET languages, programmers can choose
                  either ICU or the native Windows NLS subsystem for
                  localization, but programmers generally use the default.</li>
              <li>Charlie asked if ICU is mostly present for transcoding
                  purposes.</li>
              <li>Michael replied that he doesn't believe that to be the case
                  since .NET interfaces can defer to ICU for more localization
                  purposes.</li>
              <li>Michael expressed a belief that ICU is more deeply integrated
                  on Apple systems.</li>
              <li>PBrett asked what defect category would best be associated
                  with cases where programmers incorrectly attempt to produce
                  translated strings via concatenation.</li>
              <li>Michael expressed uncertainty, suggested "other", and noted
                  that such issues are very common but not called out
                  specifically in the slides.</li>
              <li>Michael acknowledged that, for some applications, issues due
                  to concatenation are one of the most common problems, but
                  that doesn't happen to be the case for Intel.</li>
              <li>Michael reiterated that making sure programmers fall into the
                  pit of success is important.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Slide 9: Quick Intro to BCP 47 Language Tags and Fallback
        <ul>
          <li>Spoken language is not relevant for text presentation; written
              language, or script, is.</li>
          <li>Chinese has two forms of written language; simplified and
              traditional.</li>
          <li>It is important to specify fallback locales; otherwise, a request
              for zh-SG when it is not available may result in a default
              language like English rather than zh-CN.</li>
          <li>Specifying a hierarchy of fallbacks such as zh-Hans and zh-Hant
              is recommended.</li>
          <li>Since C++ locales don't appear to provide locale fallbacks, it
              may be necessary to supply support for all of them; perhaps by
              providing the same locale data for, e.g., zh-CN and zh-SG.</li>
          <li>Steve noted that English is a better fall back than blank strings
              or the "tofu" character.</li>
        </ul>
      </li>
      <li>Slide 10: User Language Selection Choices
        <ul>
          <li>The .NET languages wrap locale info in a <tt>CultureInfo</tt>
              type.</li>
          <li>They also allow various components of a locale to be selected from
              different locales.</li>
          <li>Programmers can create their own custom cultural definitions.</li>
          <li>Thread specific locale selection is infrequently used; it is more
              common to supply a locale object locally when constructing a
              string for presentation.</li>
          <li>Browsers have multiple language settings; one for the browser UI
              itself and another for the requested page language.</li>
        </ul>
      </li>
      <li>Slide 11: Date formatting
        <ul>
          <li>Use ISO 8601 for date formatting and store times relative to UTC
              internally.</li>
          <li>Convert dates to the appropriate locale for presentation.</li>
          <li>Likewise, use one encoding internally and convert for presentation
              and at program boundaries.</li>
          <li>Hubert asked if Michael had any opinions on the use of ISO week
              days and numbers.</li>
          <li>Michael responded that he has no opinion on that.</li>
        </ul>
      </li>
      <li>Slide 12: The Famous Turkish “İ” Problem
        <ul>
          <li>Locale sensitive uppercasing may translate "i" to "İ"
              (dot retained on uppercase I).</li>
          <li>Locale sensitive lowercasing may translate "I" to "ı"
              (dot omitted on lowercase i).</li>
          <li>This is why it is important to test with Turkish locales!</li>
          <li>Various languages offer locale invariant or case insensitive case
              folding operations.</li>
          <li>ICU collation solves many of these problems when used
              correctly.</li>
          <li>Some form of collation should be used for file name matching.</li>
          <li>Hubert asked if it would generally be expected for a file with an
              uppercase dotted I like "FILE.GİF" to match a request for files
              named with a ".gif" extension.</li>
          <li>Michael responded affirmatively; that would generally be
              desired.</li>
          <li>Tom observed that such use cases may be more aligned with a form
              of transliteration.</li>
          <li>Corentin responded that Unicode case folding as defined in
              <a href="https://unicode.org/reports/tr35">UAX #35</a>
              handles that case, but that standard C++ doesn't provide an
              interface.</li>
        </ul>
      </li>
      <li>Slide 13: Formats (numbers, dates, etc.) are not as straightforward as they appear
        <ul>
          <li>ICU's message formatting abilities handle all of these.</li>
          <li>Corentin noted that currency symbols should not be locale
              dependent and that C++ got this wrong.</li>
        </ul>
      </li>
      <li>Slide 14: Many other things can go wrong when dealing with international users
        <ul>
          <li>Handling plural forms is important; the .NET languages do not
              handle plural forms or gendering.</li>
        </ul>
      </li>
      <li>Slide 15: JavaScript i18n Objects and Namespaces
        <ul>
          <li>JavaScript only provides a small number of builtins; i18n is a
              separate package.</li>
          <li>Current browser versions provide the JavaScript i18n namespace;
              polyfill is required for older browser versions.</li>
          <li>Since the language doesn't provide it as a builtin, there are
              thousands of i18n packages available.</li>
        </ul>
      </li>
      <li>Slide 16: .NET Culture Aware Classes and Namespaces
        <ul>
          <li>The .NET languages provide a relatively complete solution that
              is improving each year.</li>
          <li>The .NET fundamentals documentation is extensive.</li>
          <li>Resource files are easy for .NET languages and can be provided
              in a number of formats.</li>
          <li>The .NET languages support gettext-like methods for retrieving
              translated strings.</li>
        </ul>
      </li>
      <li>Slide 17: Resource File Formats
        <ul>
          <li>Some resource file formats are differentiated by encoding.</li>
        </ul>
      </li>
      <li>Slide 18: Read All Lines From a File
        <ul>
          <li>Some languages provide more ergonomic interfaces.</li>
        </ul>
      </li>
      <li>Slide 19: Byte Order Mark (BOM) and Endian descriptions
        <ul>
          <li>On Windows, the default encoding used to be a locale dependent
              "ANSI" encoding, but modern editors are more likely to default
              to UTF-8.</li>
          <li>C and C++ don't provide interfaces for file encoding detection
              and it isn't easy to implement well.</li>
        </ul>
      </li>
      <li>Slide 20: Character Count vs Byte Count
        <ul>
          <li>Character counts tend to be close to code unit count for many
              languages for text encoded in UTF-16.</li>
          <li>It is not easy to obtain a count of characters.</li>
          <li>Corentin asked when it is useful to count characters.</li>
          <li>Michael responded that a number of cases exist and provided an
              example of a buffer for which the user is told how many more
              characters they can expect to type; Twitter is an example for
              which both characters and bytes are counted.</li>
        </ul>
      </li>
      <li>Slide 21: Character Encodings (Incomplete List)
        <ul>
          <li>In C and C++, <tt>char</tt> doesn't have a strongly associated
              encoding.</li>
          <li>PBrett asked how often the lack of a strongly associated encoding
              leads to defects.</li>
          <li>Michael responded that it is not as much of a problem as it used
              to be, but that there are still many locale dependent "ANSI"
              encoded files to be found.</li>
        </ul>
      </li>
      <li>Slide 22: RTL Text Detection</li>
      <li>Tom asked the group what stood out to them from the presentation.
        <ul>
          <li>PBrett noted that C++ doesn't make it easy to write programs that
              are locale insensitive internally but locale sensitive at program
              boundaries.</li>
          <li>Michael noted that <tt>gettext()</tt> provides an example of how
              plural forms can be handled.</li>
          <li>Jens observed that, with <tt>std::format()</tt>, we're still far
              away from providing proper localization support; it doesn't yet
              lead to the pit of success.</li>
          <li>Tom noted that the possibility of extending <tt>std::format()</tt>
              creates opportunity.</li>
          <li>Michael noted that formatting is often used for internal uses
              that don't require localization or translation.</li>
          <li>Steve stated that the experiences reported closely match his
              experience at Bloomberg.</li>
        </ul>
      </li>
  <li>NB comment processing.
    <ul>
      <li>NB comment processing was postponed due to lack of time.</li>
    </ul>
  </li>
  <li>Tom reported that he would not be available for the previously scheduled
      2022-10-26 meeting and suggested rescheduling meetings for 2022-10-19 and
      2022-11-02 with the intent to focus on addressing NB comments in advance
      of the Kona meeting; there were no objections.</li>
</ul>


<h1 id="2022_10_19">October 19th, 2022</h1>

<h2>Draft agenda:</h2>

<ul>
  <li> NB comment processing.</li>
</ul>

<h2>Attendees:</h2>

<ul>
  <li>Corentin Jabot</li>
  <li>Hubert Tong</li>
  <li>Jens Maurer</li>
  <li>Mark Zeren</li>
  <li>Peter Bindels</li>
  <li>Steve Downey</li>
  <li>Tom Honermann</li>
  <li>Victor Zverovich</li>
</ul>

<h2>Meeting summary:</h2>

<ul>
  <li>US-02:
      <a href="http://eel.is/c++draft/defns.multibyte">[defns.multibyte]</a>:
    <ul>
      <li>Steve presented the concern:
        <ul>
          <li>The definition of multibyte character refers to the locale
              dependent execution character set.</li>
          <li>Changing this might be difficult, but removing the reference to
              "execution character set" might help.</li>
        </ul>
      </li>
      <li>Hubert stated that the use of "multibyte character" in the library
          wording is consistent with the definition.</li>
      <li>Tom asked if Hubert is suggesting that this is not a defect.</li>
      <li>Hubert responded affirmatively.</li>
      <li>Steve stated that he would agree if the definition was in the library
          section.</li>
      <li>Jens explained that there used to be a terms and definitions section
          in the library wording but that ISO required it to be merged with the
          section in the core wording back in the C++17 time frame.</li>
      <li>Hubert noted that the only use of "multibyte character" is in the
          library wording.</li>
      <li>Corentin responded that there are indirect uses of it via
          "multibyte string" and "NTMBS" in the definition of the <tt>main</tt>
          function in
          <a href="http://eel.is/c++draft/basic.start.main">[basic.start.main]</a>.</li>
      <li>Corentin noted that all uses of it are intended to refer to the
          locale encoding.</li>
      <li>Tom asked if it would make sense to strike the term so that it is
          inherited from the C standard.</li>
      <li>Jens expressed a preference not to do so.</li>
      <li>Steve stated that doing so might have unintended consequences.</li>
      <li>Tom summarized the sentiment expressed so far; we're leaning towards
          this not being a defect but that there are opportunities for
          improvement via editorial changes.</li>
      <li>Tom suggested that any such editorial changes be left up to the
          CWG.</li>
      <li>Jens replied that the CWG is likely to decline to make any changes
          without a proposed change.</li>
      <li>Corentin asked if an editorial pull request could be submitted.</li>
      <li>Jens replied affirmatively.</li>
      <li>Hubert stated that the concern that Corentin raised regarding use of
          "multibyte character" with <tt>main</tt> is an issue.</li>
      <li>Jens asserted that would be a different core issue.</li>
      <li><b>Poll 1: SG16 suggests to consider US-02 as "not a defect", but to
          improve the presentation by editorially moving the definition of
          "multibyte character" to
          <a href="http://eel.is/c++draft/multibyte.strings">[multibyte.strings]</a>.</b>
        <ul>
          <li><b>Attendees: 8</b></li>
          <li><b>No objection to unanimous consent.</b></li>
        </ul>
      </li>
      <li><em>[ Editor's note: Corentin submitted a pull request that
          implements the polled direction at
          <a href="https://github.com/cplusplus/draft/pull/5910">https://github.com/cplusplus/draft/pull/5910</a>.
          ]</em></li>
    </ul>
  </li>
  <li>US-38:
      <a href="https://eel.is/c++draft/format.string.escaped">[format.string.escaped]</a>:
    <ul>
      <li>Hubert presented the concern:
        <ul>
          <li>The feature description claims to provide a larger scope than it
              serves; the design doesn't suffice to address all logging
              scenarios.</li>
          <li>It is not clear that the escaped string is required to be usable
              as a string literal.</li>
        </ul>
      </li>
      <li>Victor opined that the proposed change to replace "logging" with
          "technical logging" makes sense.</li>
      <li>Victor expressed a preference against the second bullet regarding
          visually distinguishing equivalent text that is differently
          encoded.</li>
      <li>Victor stated that the primary motivation for the feature was to
          produce a character sequence that would not interfere with the
          formatting of ranges.</li>
      <li>Victor noted that the feature has existing experience with both
          Python and Rust and that the chosen design is modeled after
          Rust.</li>
      <li>Victor asserted that the proposed change to allow for future addition
          of alternative escaping methods is unnecessary since other extension
          methods are already available.</li>
      <li>Jens stated that the concern seems mostly related to the first
          sentence of
          <a href="https://eel.is/c++draft/format.string.escaped">[format.string.escaped]</a>:
        <blockquote class="quote">
        A character or string can be formatted as <i>escaped</i> to make it more
        suitable for debugging or for logging.
        </blockquote>
      </li>
      <li>Jens continued; and the request is to make it clear that the escaped
          result shall be valid for interpretation as a string literal and that
          "logging" be replaced with "technical logging".</li>
      <li>Hubert agreed, but noted there is still a question of whether visually
          distinct output is desired.</li>
      <li>Hubert reiterated; the first priority is that the escaped result is a
          valid string literal, and a secondary priority is that text that might
          not be visually distinct be made so.</li>
      <li>Jens stated that the minimal change would be to change that first
          sentence.</li>
      <li>Jens noted that no actual defect has been identified.</li>
      <li>Hubert stated that SG16 may not be the best place to fully resolve the
          comment; the question of extension remains and is more of a LEWG
          consideration.</li>
      <li>Jens suggested that, for LWG's benefit, SG16 should propose a change
          to that first sentence.</li>
      <li>Corentin stated that NB comment FR-05 similarly states that the intent
          of the feature is not clear.</li>
      <li>Corentin asserted there are further questions regarding the escaping
          of grapheme clusters and that it is not clear what is intended to be
          escaped and for what purpose.</li>
      <li>Corentin expressed concern that the currently specified behavior of
          escaping all combining characters disadvantages some languages more
          than others and provided Korean as an example.</li>
      <li>Victor acknowledged that US-38 and FR-05 both state that the intent
          is not clear, but noted that their proposed resolutions are not in
          agreement.</li>
      <li>Victor agreed with Corentin that users of scripts that require more
          use of combining characters should not be penalized.</li>
      <li>Victor stated that the Python form of the feature does not escape
          combining characters and that can result in interference with range
          separators.</li>
      <li>Victor noted that the original proposal only escaped lone combining
          characers and acknowledged that the switch to the Rust approach might
          have gone too far.</li>
      <li>Hubert disagreed with the notion that a failure to escape does not
          harm the technical debugging use case.</li>
      <li>Mark reported experience with use cases where text content is only
          available via an image; perhaps a screen shot captured with a
          phone.</li>
      <li>Mark stated that he has only experienced a need for escaped
          characters in cases where the text was not correctly encoded.</li>
      <li>Mark noted it is a valid question as to whether the standard library
          should default to producing visually indistinct text.</li>
      <li>Tom stated that a goal of maximizing visual distinction would require
          escaping all characters not in the basic character set.</li>
      <li>Corentin replied that it would be terrible to escape all non-ASCII
          characters but that doing so would not be worse than escaping all
          combining characters.</li>
      <li>Corentin expressed a preference towards either maximizing escaping or
          minimizing it.</li>
      <li>Hubert stated that the scripts like Korean provide strong motivation
          for a minimally escaped form.</li>
      <li>Hubert noted that there are still valid reasons for wanting a
          visually distinct form via an easy opt-in.</li>
      <li>Victor reiterated that the primary goal of the escaped form was to
          avoid interference with the formatted range output.</li>
      <li>Victor suggested that desires for other use cases be pursued via new
          papers rather than NB comments.</li>
      <li>Victor asserted that it is useful to have ill-formed code units
          escaped.</li>
      <li>Mark expressed a preference towards not escaping combining characters
          due to the readability harm it would impose on scripts like
          Korean.</li>
      <li>Corentin asserted that all use cases can't be satisfied with this
          single facility but that extensions can satisfy more post-C++23.</li>
      <li>Corentin expressed a preference towards a default that maintains
          readability for more languages and that more extensive escaping can be
          pursued separately.</li>
      <li>Hubert opined that a sequence of combining characters that immediately
          follow an escaped character is sufficient evidence of an error to
          justify escaping them.</li>
      <li>Corentin repeated that it is useful to escape non-printable
          characters.</li>
      <li>Corentin stated that the grapheme breaking algorithm is potentially
          expensive, but then backtracked with an observation that it is
          sufficient to check for the <tt>Grapheme_Extend=Yes</tt> character
          property to identify combining characters that may need to be
          escaped.</li>
      <li><b>*Poll 2.1: [US-38] SG16 agrees that the formatted code units in
          the escaped string are intended to be usable as a string literal that
          reproduces the input.</b>
        <ul>
          <li><b>Attendees: 8</b></li>
          <li><b>No objection to unanimous consent.</b></li>
        </ul>
      </li>
      <li><b>Poll 2.2: [US-38] SG16 agrees that the escaped string is intended
          to be readable for its textual content in any Unicode script.</b>
        <ul>
          <li><b>Attendees: 8</b></li>
          <li><b>No objection to unanimous consent.</b></li>
        </ul>
      </li>
      <li><b>Poll 2.3: [US-38] SG16 agrees that separators and non-printable
          characters
          (<a href="https://eel.is/c++draft/format.string.escaped">[format.string.escaped]p(2.2.1.2)</a>)
          shall be escaped in the escaped string.</b>
        <ul>
          <li><b>Attendees: 8</b></li>
          <li><b>No objection to unanimous consent.</b></li>
        </ul>
      </li>
      <li><b>Poll 2.4: [US-38] SG16 agrees that combining code points shall
          not be escaped unless there is no leading code point or the previous
          character was escaped.</b>
        <ul>
          <li><b>Attendees: 8</b></li>
          <li><b>No objection to unanimous consent.</b></li>
        </ul>
      </li>
      <li>Tom stated that he would provide examples for each of the polls when
          reporting the SG16 consensus once the NB comment github repository
          is populated.</li>
      <li>Tom suggested that anyone that works on proposed wording include
          examples.</li>
    </ul>
  </li>
  <li>US-64:
      <a href="https://eel.is/c++draft/uaxid.pattern">[uaxid.pattern]</a>:
    <ul>
      <li>Tom noted that FR-09, if adopted, will make this NB comment moot.</li>
      <li>Corentin explained the motivation for the FR-09 comment; that the
          annex is light on information, that many of the requirements don't
          apply to C++, and that the ones that do could be noted in
          <a href="http://eel.is/c++draft/lex.name">[lex.name]</a>.</li>
      <li>Steve responded that an explicit record of a negative answer to a
          question is useful.</li>
      <li>Steve explained that it would be difficult to identify Unicode
          requirement conformance information if it was spread throughout the
          standard wording.</li>
      <li>Tom observed that differing opinions are clearly present with regard
          to the utility of the annex and stated that, due to time constraints,
          discussion will be limited to US-64 for now; discussion of FR-09 will
          be scheduled for a future meeting.</li>
      <li>Steve expressed an expectation of agreement that UAX #31 is intended
          to apply to general purpose programming languages.</li>
      <li>Hubert expressed a desire for more details and noted that conformance
          is not currently claimed.</li>
      <li>Tom provided a link to Unicode document
          <a href="https://www.unicode.org/L2/L2022/22179-uax31-36-draft-6-post-pri450.pdf">L2/22-179</a>;
          it contains highlighted markup of the changes that were accepted for
          Unicode 15.</li>
      <li>Tom noted the changes added to the beginning of chapter 4,
          "Pattern Syntax":
          <blockquote class="quote">
          Most programming languages have a concept of whitespace as part of
          their lexical structure, as well as some set of characters that are
          disallowed in identifiers but have syntactic use, such as arithmetic
          operators. Beyond general programming languages, there are also ...
          </blockquote>
          and the changes to the "Modifications" section at the end of the
          document:
          <blockquote class="quote">
          <ul>
            <li>Section 4, Pattern Syntax
              <ul>
                <li>Clarified that this section is applicable to programming
                    languages.</li>
              </ul>
            </li>
          </ul>
          </blockquote>
      </li>
      <li>Jens observed that the NB comment is missing a reference to the
          updated Unicode document that clarifies applicability to general
          purpose programming languages.</li>
      <li>Jens suggested that the annex could state that
          <a href="http://eel.is/c++draft/lex.name">[lex.name]</a>
          defines a profile.</li>
      <li>Hubert expressed a preference to continue claiming non-conformance
          pending a clear specification of a conforming profile.</li>
      <li>Steve expressed contentedness with a change to just claim
          non-conformance.</li>
      <li>Jens observed that consensus appeared to be aligning with the
          proposed change from the NB comment as opposed to the one proposed in
          <a href="https://wg21.link/p2653r0">P2653R0 (Update Annex E based on Unicode 15.0 UAX 31)</a>.</li>
      <li>Steve asked if such a change could be applied editorially.</li>
      <li>Tom opined that it could be.</li>
      <li>Jens expressed a desire for CWG to review first and stated that, if a
          paper revision can be made available quickly, that he would schedule
          it for CWG review later in the week.</li>
      <li>Steve agreed to prepare a revision.</li>
      <li><b>Poll 3: [US-64] SG16 agrees with resolving the issue in the
          direction presented in the comment.</b>
        <ul>
          <li><b>Attendees: 8</b></li>
          <li><b>No objection to unanimous consent.</b></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Tom discussed plans for the next SG16 meeting:
    <ul>
      <li>Review of the GB and FR draft NB comments identified 7 comments for
          SG16 to review</li>
      <li>It is not yet known if additional NB comments from other NBs will
          require review.</li>
      <li>The next meeting is scheduled for 2022-11-02.</li>
      <li>Once an agenda is sent, please discuss in email in advance of the
          meeting in order to reduce review time during the meeting.</li>
    </ul>
  </li>
</ul>


</body>
