<!doctype html public "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">

<head>
<title>SG16: Unicode meeting summaries 2022-10-12 through 2022-10-12</title>
</head>

<style type="text/css">

table#header th,
table#header td
{
    text-align: left;
}

tt {
    font-family: monospace;
}

/* Thanks to Elias Kosunen for the following CSS suggestions! */

* {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
    line-height: 125%;
}

html, body {
    background-color: #eee;
}

h1, h2, h3, h4, h5, p, span, li, dt, dd {
    color: #333;
}

p, li {
    line-height: 140%;
}

body {
    padding: 1em;
    max-width: 1600px;
}

p, li {
    -moz-osx-font-smoothing: grayscale;
    -webkit-font-smoothing: antialiased !important;
    -moz-font-smoothing: antialiased !important;
    text-rendering: optimizelegibility !important;
    letter-spacing: .01em;
}

h1, h2, h3 {
    margin-bottom: 1em;
    letter-spacing: .03em;
}

blockquote.quote
{
    margin-left: 0em;
    border-style: solid;
    background-color: lemonchiffon;
    color: #000000;
    border: 1px solid black;
}

</style>

<body style="max-width: 8.5in">

<table id="header">
  <tr>
    <th>Document Number:</th>
    <td>DXXXXR0 <em>Draft</em></td>
  </tr>
  <tr>
    <th>Date:</th>
    <td>2022-10-23</td>
  </tr>
  <tr>
    <th>Audience:</th>
    <td>SG16</td>
  </tr>
  <tr>
    <th>Reply-to:</th>
    <td>Tom Honermann &lt;tom@honermann.net&gt;</td>
  </tr>
</table>


<h1>SG16: Unicode meeting summaries 2022-10-12 through 2022-10-12</h1>

<p>
Summaries of SG16 meetings are maintained at
<a href="https://github.com/sg16-unicode/sg16-meetings">
https://github.com/sg16-unicode/sg16-meetings</a>.  This paper contains a
snapshot of select meeting summaries from that repository.
</p>

<ul>
  <li><a href="#2022_10_12">
      October 12th, 2022</a></li>
</ul>

<p>
Previously published SG16 meeting summary papers:
<ul>
  <li><a href="https://wg21.link/p1080">P1080: SG16: Unicode meeting summaries 2018/03/28 - 2018/04/25</a></li>
  <li><a href="https://wg21.link/p1137">P1137: SG16: Unicode meeting summaries 2018/05/16 - 2018/06/20</a></li>
  <li><a href="https://wg21.link/p1237">P1237: SG16: Unicode meeting summaries 2018/07/11 - 2018/10/03</a></li>
  <li><a href="https://wg21.link/p1422">P1422: SG16: Unicode meeting summaries 2018/10/17 - 2019/01/09</a></li>
  <li><a href="https://wg21.link/p1666">P1666: SG16: Unicode meeting summaries 2019/01/23 - 2019/05/22</a></li>
  <li><a href="https://wg21.link/p1896">P1896: SG16: Unicode meeting summaries 2019/06/12 - 2019/09/25</a></li>
  <li><a href="https://wg21.link/p2009">P2009: SG16: Unicode meeting summaries 2019-10-09 through 2019-12-11</a></li>
  <li><a href="https://wg21.link/p2179">P2179: SG16: Unicode meeting summaries 2020-01-08 through 2020-05-27</a></li>
  <li><a href="https://wg21.link/p2217">P2217: SG16: Unicode meeting summaries 2020-06-10 through 2020-08-26</a></li>
  <li><a href="https://wg21.link/p2253">P2253: SG16: Unicode meeting summaries 2020-09-09 through 2020-11-11</a></li>
  <li><a href="https://wg21.link/p2352">P2352: SG16: Unicode meeting summaries 2020-12-09 through 2021-03-24</a></li>
  <li><a href="https://wg21.link/p2397">P2397: SG16: Unicode meeting summaries 2021-04-14 through 2021-05-26</a></li>
  <li><a href="https://wg21.link/p2512">P2512: SG16: Unicode meeting summaries 2021-06-09 through 2021-12-15</a></li>
  <li><a href="https://wg21.link/p2605">P2605: SG16: Unicode meeting summaries 2022-01-12 through 2022-06-08</a></li>
  <li><a href="https://wg21.link/p2678">P2678: SG16: Unicode meeting summaries 2022-06-22 through 2022-09-28</a></li>
</ul>
</p>


<h1 id="2022_10_12">October 12th, 2022</h1>

<h2>Draft agenda:</h2>

<ul>
  <li>Michael Kuperstein: Internationalization From the Perspective of Defect Analysis</li>
  <li>NB comment processing.</li>
</ul>

<h2>Attendees:</h2>

<ul>
  <li>Charles Barto</li>
  <li>Corentin Jabot</li>
  <li>Hubert Tong</li>
  <li>Jens Maurer</li>
  <li>Mark de Wever</li>
  <li>Mark Zeren</li>
  <li>Michael Kuperstein</li>
  <li>Nevin Liber</li>
  <li>Peter Brett</li>
  <li>Steve Downey</li>
  <li>Tom Honermann</li>
  <li>Tomasz Kamiński</li>
  <li>Victor Zverovich</li>
</ul>

<h2>Meeting summary:</h2>

<ul>
  <li>Michael Kuperstein: Internationalization From the Perspective of Defect Analysis
    <ul>
      <li><em>[ Editor's note: Michael's slides are available at
          <a href="https://github.com/sg16-unicode/sg16-meetings/blob/master/presentations/2022-10-12-i18n-presentation.pptx">https://github.com/sg16-unicode/sg16-meetings/blob/master/presentations/2022-10-12-i18n-presentation.pptx</a>.
          ]</em>
      </li>
      <li>Michael provided a brief introduction:
        <ul>
          <li>He has been working for Intel since 1996.</li>
          <li>He has been working in Intel's localization group since 2001.</li>
        </ul>
      </li>
      <li>Slide 1: Internationalization From the Perspective of Defect Analysis</li>
      <li>Slide 2: Venn Diagram</li>
      <li>Slide 3: Defects in Localized Software
        <ul>
          <li>The defect breakdown presented is from an analysis performed in
              2011.</li>
          <li>Internationalization and localization defects are usually found
              by the localization team.</li>
          <li>Localization defects can often be fixed by the localization team;
              as a result, localization teams tend to maintain their own defect
              database.</li>
          <li>Localization defects that require a fix by a development team tend
              to first be reported in a defect database maintained by the
              localization team and then migrated to another team's defect
              database.</li>
        </ul>
      </li>
      <li>Slide 4: World-Readiness Defect Types
        <ul>
          <li>Most localization defects are due to UI, Layout, or formatting
              issues.</li>
          <li>The next largest category of defects are due to translation
              issues.</li>
          <li>Defects due to non-translated and embedded strings make up the
              next largest two categories.</li>
          <li>Defects due to encoding issues make up the smallest defect
              category, but are very important.</li>
          <li>For software developers, internationalization and localization
              support is a small part of their total effort, but an important
              part.</li>
        </ul>
      </li>
      <li>Slide 5: Code Scans: I18N Issues by Volume
        <ul>
          <li>The top two categories of issues found by code scans are
              hard-coded strings and hard-coded formatting.</li>
        </ul>
      </li>
      <li>Slide 6: I18N Issues by Volume – Honorable Mentions
        <ul>
          <li>A consistent internal locale insensitive representation of dates
              is necessary to prevent failures.</li>
          <li>Steve confirmed that the general shape of relative error counts
              presented matches his experience.</li>
          <li>Steve reported that products he has worked on avoid localized
              formatting of dates so as to avoid confusion; likewise, "." is
              consistently used for decimal point.</li>
        </ul>
      </li>
      <li>Slide 7: More than 150 string formatting functions in C/C++ on Windows
        <ul>
          <li>Charlie noted that most of those 150 functions wrap a common
              underlying formatting function.</li>
          <li>Corentin suggested bumping the number to 151 now that
              <tt>std::format()</tt> has been standardized.</li>
        </ul>
      </li>
      <li>Slide 8: Defaults: Fall into the pit of success
        <ul>
          <li>Use of UTF-16 made it easier to produce the right results on
              Windows.</li>
          <li>A string class that basically does the right thing makes it easier
              to get the right result.</li>
          <li>The goal is to guide developers towards doing the right
              thing.</li>
          <li>Many programmers like string interpolation.</li>
          <li>ICU discussion:
            <ul>
              <li>Charlie reported that the ICU included in Windows doesn't
                  expose the C++ interface.</li>
              <li>Michael noted that, in .NET languages, programmers can choose
                  either ICU or the native Windows NLS subsystem for
                  localization, but programmers generally use the default.</li>
              <li>Charlie asked if ICU is mostly present for transcoding
                  purposes.</li>
              <li>Michael replied that he doesn't believe that to be the case
                  since .NET interfaces can defer to ICU for more localization
                  purposes.</li>
              <li>Michael expressed a belief that ICU is more deeply integrated
                  on Apple systems.</li>
              <li>PBrett asked what defect category would best be associated
                  with cases where programmers incorrectly attempt to produce
                  translated strings via concatenation.</li>
              <li>Michael expressed uncertainty, suggested "other", and noted
                  that such issues are very common but not called out
                  specifically in the slides.</li>
              <li>Michael acknowledged that, for some applications, issues due
                  to concatenation are one of the most common problems, but
                  that doesn't happen to be the case for Intel.</li>
              <li>Michael reiterated that making sure programmers fall into the
                  pit of success is important.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Slide 9: Quick Intro to BCP 47 Language Tags and Fallback
        <ul>
          <li>Spoken language is not relevant for text presentation; written
              language, or script, is.</li>
          <li>Chinese has two forms of written language; simplified and
              traditional.</li>
          <li>It is important to specify fallback locales; otherwise, a request
              for zh-SG when it is not available may result in a default
              language like English rather than zh-CN.</li>
          <li>Specifying a hierarchy of fallbacks such as zh-Hans and zh-Hant
              is recommended.</li>
          <li>Since C++ locales don't appear to provide locale fallbacks, it
              may be necessary to supply support for all of them; perhaps by
              providing the same locale data for, e.g., zh-CN and zh-SG.</li>
          <li>Steve noted that English is a better fall back than blank strings
              or the "tofu" character.</li>
        </ul>
      </li>
      <li>Slide 10: User Language Selection Choices
        <ul>
          <li>The .NET languages wrap locale info in a <tt>CultureInfo</tt>
              type.</li>
          <li>They also allow various components of a locale to be selected from
              different locales.</li>
          <li>Programmers can create their own custom cultural definitions.</li>
          <li>Thread specific locale selection is infrequently used; it is more
              common to supply a locale object locally when constructing a
              string for presentation.</li>
          <li>Browsers have multiple language settings; one for the browser UI
              itself and another for the requested page language.</li>
        </ul>
      </li>
      <li>Slide 11: Date formatting
        <ul>
          <li>Use ISO 8601 for date formatting and store times relative to UTC
              internally.</li>
          <li>Convert dates to the appropriate locale for presentation.</li>
          <li>Likewise, use one encoding internally and convert for presentation
              and at program boundaries.</li>
          <li>Hubert asked if Michael had any opinions on the use of ISO week
              days and numbers.</li>
          <li>Michael responded that he has no opinion on that.</li>
        </ul>
      </li>
      <li>Slide 12: The Famous Turkish “İ” Problem
        <ul>
          <li>Locale sensitive uppercasing may translate "i" to "İ"
              (dot retained on uppercase I).</li>
          <li>Locale sensitive lowercasing may translate "I" to "ı"
              (dot omitted on lowercase i).</li>
          <li>This is why it is important to test with Turkish locales!</li>
          <li>Various languages offer locale invariant or case insensitive case
              folding operations.</li>
          <li>ICU collation solves many of these problems when used
              correctly.</li>
          <li>Some form of collation should be used for file name matching.</li>
          <li>Hubert asked if it would generally be expected for a file with an
              uppercase dotted I like "FILE.GİF" to match a request for files
              named with a ".gif" extension.</li>
          <li>Michael responded affirmatively; that would generally be
              desired.</li>
          <li>Tom observed that such use cases may be more aligned with a form
              of transliteration.</li>
          <li>Corentin responded that Unicode case folding as defined in
              <a href="https://unicode.org/reports/tr35">UAX #35</a>
              handles that case, but that standard C++ doesn't provide an
              interface.</li>
        </ul>
      </li>
      <li>Slide 13: Formats (numbers, dates, etc.) are not as straightforward as they appear
        <ul>
          <li>ICU's message formatting abilities handle all of these.</li>
          <li>Corentin noted that currency symbols should not be locale
              dependent and that C++ got this wrong.</li>
        </ul>
      </li>
      <li>Slide 14: Many other things can go wrong when dealing with international users
        <ul>
          <li>Handling plural forms is important; the .NET languages do not
              handle plural forms or gendering.</li>
        </ul>
      </li>
      <li>Slide 15: JavaScript i18n Objects and Namespaces
        <ul>
          <li>JavaScript only provides a small number of builtins; i18n is a
              separate package.</li>
          <li>Current browser versions provide the JavaScript i18n namespace;
              polyfill is required for older browser versions.</li>
          <li>Since the language doesn't provide it as a builtin, there are
              thousands of i18n packages available.</li>
        </ul>
      </li>
      <li>Slide 16: .NET Culture Aware Classes and Namespaces
        <ul>
          <li>The .NET languages provide a relatively complete solution that
              is improving each year.</li>
          <li>The .NET fundamentals documentation is extensive.</li>
          <li>Resource files are easy for .NET languages and can be provided
              in a number of formats.</li>
          <li>The .NET languages support gettext-like methods for retrieving
              translated strings.</li>
        </ul>
      </li>
      <li>Slide 17: Resource File Formats
        <ul>
          <li>Some resource file formats are differentiated by encoding.</li>
        </ul>
      </li>
      <li>Slide 18: Read All Lines From a File
        <ul>
          <li>Some languages provide more ergonomic interfaces.</li>
        </ul>
      </li>
      <li>Slide 19: Byte Order Mark (BOM) and Endian descriptions
        <ul>
          <li>On Windows, the default encoding used to be a locale dependent
              "ANSI" encoding, but modern editors are more likely to default
              to UTF-8.</li>
          <li>C and C++ don't provide interfaces for file encoding detection
              and it isn't easy to implement well.</li>
        </ul>
      </li>
      <li>Slide 20: Character Count vs Byte Count
        <ul>
          <li>Character counts tend to be close to code unit count for many
              languages for text encoded in UTF-16.</li>
          <li>It is not easy to obtain a count of characters.</li>
          <li>Corentin asked when it is useful to count characters.</li>
          <li>Michael responded that a number of cases exist and provided an
              example of a buffer for which the user is told how many more
              characters they can expect to type; Twitter is an example for
              which both characters and bytes are counted.</li>
        </ul>
      </li>
      <li>Slide 21: Character Encodings (Incomplete List)
        <ul>
          <li>In C and C++, <tt>char</tt> doesn't have a strongly associated
              encoding.</li>
          <li>PBrett asked how often the lack of a strongly associated encoding
              leads to defects.</li>
          <li>Michael responded that it is not as much of a problem as it used
              to be, but that there are still many locale dependent "ANSI"
              encoded files to be found.</li>
        </ul>
      </li>
      <li>Slide 22: RTL Text Detection</li>
      <li>Tom asked the group what stood out to them from the presentation.
        <ul>
          <li>PBrett noted that C++ doesn't make it easy to write programs that
              are locale insensitive internally but locale sensitive at program
              boundaries.</li>
          <li>Michael noted that <tt>gettext()</tt> provides an example of how
              plural forms can be handled.</li>
          <li>Jens observed that, with <tt>std::format()</tt>, we're still far
              away from providing proper localization support; it doesn't yet
              lead to the pit of success.</li>
          <li>Tom noted that the possibility of extending <tt>std::format()</tt>
              creates opportunity.</li>
          <li>Michael noted that formatting is often used for internal uses
              that don't require localization or translation.</li>
          <li>Steve stated that the experiences reported closely match his
              experience at Bloomberg.</li>
        </ul>
      </li>
  <li>NB comment processing.
    <ul>
      <li>NB comment processing was postponed due to lack of time.</li>
    </ul>
  </li>
  <li>Tom reported that he would not be available for the previously scheduled
      2022-10-26 meeting and suggested rescheduling meetings for 2022-10-19 and
      2022-11-02 with the intent to focus on addressing NB comments in advance
      of the Kona meeting; there were no objections.</li>
</ul>


</body>
