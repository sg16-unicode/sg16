<!doctype html public "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">

<head>
<title>SG16: Unicode meeting summaries 2023-10-11 through 2023-11-29</title>
</head>

<style type="text/css">

table#header th,
table#header td
{
    text-align: left;
}

tt {
    font-family: monospace;
}

/* Thanks to Elias Kosunen for the following CSS suggestions! */

* {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
    line-height: 125%;
}

html, body {
    background-color: #eee;
}

h1, h2, h3, h4, h5, p, span, li, dt, dd {
    color: #333;
}

p, li {
    line-height: 140%;
}

body {
    padding: 1em;
    max-width: 1600px;
}

p, li {
    -moz-osx-font-smoothing: grayscale;
    -webkit-font-smoothing: antialiased !important;
    -moz-font-smoothing: antialiased !important;
    text-rendering: optimizelegibility !important;
    letter-spacing: .01em;
}

h1, h2, h3 {
    margin-bottom: 1em;
    letter-spacing: .03em;
}

blockquote.quote
{
    margin-left: 0em;
    border-style: solid;
    background-color: lemonchiffon;
    color: #000000;
    border: 1px solid black;
}

</style>

<body style="max-width: 8.5in">

<table id="header">
  <tr>
    <th>Document Number:</th>
    <td>DXXXXR0 <em>Draft</em></td>
  </tr>
  <tr>
    <th>Date:</th>
    <td>2024-01-01</td>
  </tr>
  <tr>
    <th>Audience:</th>
    <td>SG16</td>
  </tr>
  <tr>
    <th>Reply-to:</th>
    <td>Tom Honermann &lt;tom@honermann.net&gt;</td>
  </tr>
</table>


<h1>SG16: Unicode meeting summaries 2023-10-11 through 2023-11-29</h1>

<p>
Summaries of SG16 meetings are maintained at
<a href="https://github.com/sg16-unicode/sg16-meetings">
https://github.com/sg16-unicode/sg16-meetings</a>.  This paper contains a
snapshot of select meeting summaries from that repository.
</p>

<ul>
  <li><a href="#2023_10_11">
      October 11th, 2023</a></li>
  <li><a href="#2023_10_25">
      October 25th, 2023</a></li>
  <li><a href="#2023_11_29">
      November 29th, 2023</a></li>
</ul>

<p>
Previously published SG16 meeting summary papers:
<ul>
  <li><a href="https://wg21.link/p1080">P1080: SG16: Unicode meeting summaries 2018/03/28 - 2018/04/25</a></li>
  <li><a href="https://wg21.link/p1137">P1137: SG16: Unicode meeting summaries 2018/05/16 - 2018/06/20</a></li>
  <li><a href="https://wg21.link/p1237">P1237: SG16: Unicode meeting summaries 2018/07/11 - 2018/10/03</a></li>
  <li><a href="https://wg21.link/p1422">P1422: SG16: Unicode meeting summaries 2018/10/17 - 2019/01/09</a></li>
  <li><a href="https://wg21.link/p1666">P1666: SG16: Unicode meeting summaries 2019/01/23 - 2019/05/22</a></li>
  <li><a href="https://wg21.link/p1896">P1896: SG16: Unicode meeting summaries 2019/06/12 - 2019/09/25</a></li>
  <li><a href="https://wg21.link/p2009">P2009: SG16: Unicode meeting summaries 2019-10-09 through 2019-12-11</a></li>
  <li><a href="https://wg21.link/p2179">P2179: SG16: Unicode meeting summaries 2020-01-08 through 2020-05-27</a></li>
  <li><a href="https://wg21.link/p2217">P2217: SG16: Unicode meeting summaries 2020-06-10 through 2020-08-26</a></li>
  <li><a href="https://wg21.link/p2253">P2253: SG16: Unicode meeting summaries 2020-09-09 through 2020-11-11</a></li>
  <li><a href="https://wg21.link/p2352">P2352: SG16: Unicode meeting summaries 2020-12-09 through 2021-03-24</a></li>
  <li><a href="https://wg21.link/p2397">P2397: SG16: Unicode meeting summaries 2021-04-14 through 2021-05-26</a></li>
  <li><a href="https://wg21.link/p2512">P2512: SG16: Unicode meeting summaries 2021-06-09 through 2021-12-15</a></li>
  <li><a href="https://wg21.link/p2605">P2605: SG16: Unicode meeting summaries 2022-01-12 through 2022-06-08</a></li>
  <li><a href="https://wg21.link/p2678">P2678: SG16: Unicode meeting summaries 2022-06-22 through 2022-09-28</a></li>
  <li><a href="https://wg21.link/p2766">P2766: SG16: Unicode meeting summaries 2022-10-12 through 2022-12-14</a></li>
  <li><a href="https://wg21.link/p2891">P2891: SG16: Unicode meeting summaries 2023-01-11 through 2023-05-10</a></li>
  <li><a href="https://wg21.link/p2995">P2995: SG16: Unicode meeting summaries 2023-05-24 through 2023-09-27</a></li>
</ul>
</p>


<h1 id="2023_10_11">October 11th, 2023</h1>

<h2>Draft agenda:</h2>

<ul>
  <li><a href="https://wg21.link/p1729r3">P1729R3: Text Parsing</a>:
    <ul>
      <li>Continue review.</li>
    </ul>
  </li>
</ul>

<h2>Attendees:</h2>

<ul>
  <li>Corentin Jabot</li>
  <li>Elias Kosunen</li>
  <li>Hubert Tong</li>
  <li>Nathan Owen</li>
  <li>Robin Leroy</li>
  <li>Steve Downey</li>
  <li>Tom Honermann</li>
  <li>Victor Zverovich</li>
</ul>

<h2>Meeting summary:</h2>

<ul>
  <li><a href="https://wg21.link/p1729r3">P1729R3: Text Parsing</a>:
    <ul>
      <li><em>[ Editor's note: D1729R3 was the active paper under discussion at
          the telecon.
          The agenda and links used here reference P1729R3 since the links to
          the draft paper were ephemeral.
          The published document may differ from the reviewed draft revision.
          ]</em></li>
      <li>Elias presented the changes in the draft P1729R3:
        <ul>
          <li><tt>std::scan</tt> now returns a subrange for the unparsed input
              rather than just an iterator to the start of the range.</li>
          <li>As noted in the revision history, changes requested during the
              last SG16 review with respect to whitespace, locale, and encoding
              concerns have been made.</li>
        </ul>
      </li>
      <li>Victor asked if returning a subrange will be less efficient since it
          requires passing an iterator pair or an iterator and size pair.</li>
      <li>Elias responded that the overhead is expected to be negligible
          relative to the convenience provided by returning the sentinel.</li>
      <li>Elias commented that, per section 3.6, "Scanning an user-defined type",
          the second template parameter for <tt>std::scanner</tt> now has
          <tt>char</tt> as a default argument.</li>
      <li>Elias reviewed the changes in section 4.2, "Format strings" to define
          whitespace in terms of the Unicode <tt>Pattern_White_Space</tt>
          property.</li>
      <li>Victor asked why LEFT-TO-RIGHT MARK and RIGHT-TO-LEFT MARK are
          considered whitespace.</li>
      <li>Robin responded that these code points can be used to prevent
          directionality properties from one token from affecting how the
          characters of an adjacent token are displayed.</li>
      <li>Tom asked for confirmation that there is no desire or need for
          scanning to consider bidirectional concerns; e.g., scanning should
          always follow memory order, not logical order.</li>
      <li>Robin referenced the examples in
          <a href="https://www.unicode.org/reports/tr55/tr55-3.html#Usability-bidi">section 1.3.2, "Usability issues arising from bidirectional reordering"</a>
          of
          <a href="http://www.unicode.org/reports/tr55">UTS #55, "Unicode Source Code Handling"</a>
          that demonstrate how the Unicode Bidirectional Algorithm can produce
          unreadable text.</li>
      <li>Victor requested the addition of some bidirectional examples and asked
          Robin if he could offer some suggestions that would be relevant for
          scanning.</li>
      <li>Robin responded in chat to see the examples in
          <a href="https://www.unicode.org/reports/tr31/tr31-39.html#Bidirectional_Ordering">section 4.1.1, "Bidirectional Ordering"</a>
          of
          <a href="https://www.unicode.org/reports/tr31">UAX #31, "Unicode Identifiers and Syntax"</a>.</li>
      <li>Elias agreed that examples can be added.</li>
      <li>Tom noted that, when the input is not known to be in a UTF encoding,
          that the set of whitespace characters will need to be
          implementation-defined.</li>
      <li>Elias agreed and stated those details will be added later.</li>
      <li>Elias directed attention to section 4.3.5.1,
          "Design discussion: Thousands separator grouping checking" and noted
          that iostreams enforces grouping separators.</li>
      <li>Tom asked for confirmation that iostreams only enforces that, if
          grouping separators are present, that they are in the expected
          locations and that they aren't required to be present.</li>
      <li>Elias confirmed.</li>
      <li>Victor asserted that <tt>std::scan</tt> should do what iostreams does
          and stated that programmers that want different behavior can implement
          that themselves.</li>
      <li>Elias suggested the behavior could potentially be changed later if
          desired.</li>
      <li>Victor replied that it is generally more difficult to introduce an
          error where one was not previously reported than it is to relax an
          error that was previously reported.</li>
      <li>Elias noted that some <tt>scanf()</tt> implementations have an
          extension that allows <tt>'</tt> to be recognized as a grouping
          separator.</li>
      <li>Tom asked if that separator is handled like it is in C++ where it can
          appear anywhere any number of times.</li>
      <li>Elias responded that it is recognized as an alternate grouping
          separator, so no.</li>
      <li>Victor explained that
          <a href="https://github.com/fmtlib/fmt">{fmt}</a>
          briefly supported that feature but that it was removed.</li>
      <li>Victor opined that support for that feature probably isn't
          needed.</li>
      <li>Elias acknowledged that support for it could always be added
          later.</li>
      <li>Corentin agreed with Victor, expressed a desire to eventually replace
          locale support with something based on ICU someday, and encouraged
          avoidance of innovation with locale features.</li>
      <li>Elias stated that he would not proceed further with the alternate
          separator.</li>
      <li>Elias pointed out that section 4.5,
          "Argument passing, and return type of <tt>scan</tt>", now specifies
          that <tt>std::scan</tt> returns a subrange.</li>
      <li>Elias observed a markup error in the last paragraph of that section;
          "gt;" appears where "&amp;gt;" was intended to encode "&gt;".</li>
      <li>Elias claimed that the return of a subrange consisting of an iterator
          and sentinel pair is novel and is done because the sentinel is always
          available but converting it to an iterator would require more work to
          advance an iterator to the sentinel position.</li>
      <li>Tom encouraged Elias to contact the SG9 chair to arrange a
          discussion.</li>
      <li>Elias proclaimed that a better name is needed for the proposed
          <tt>borrowed_ssubrange_t</tt> and explained that the extra "s" stands
          for sentinel.</li>
      <li>Steve agreed and stated that, as is, that name looks like a typo.</li>
      <li>Steve recommended spelling the name out since this isn't one that
          programmers would have to write often anyway.</li>
      <li>Corentin suggested that it might be possible to change
          <tt>borrowed_subrange</tt> to support an iterator and sentinel
          subrange.</li>
      <li>Elias replied that doing so might impact ABI.</li>
      <li>Corentin recommended discussing it in SG9.</li>
      <li>Elias presented section 4.6, "Error handling", and the recently added
          <tt>value_out_of_range</tt> enumerator added to
          <tt>scan_error::code_type</tt>.</li>
      <li>Elias explained that the <tt>strtol()</tt> family of interfaces allow
          a programmer to differentiate between overflow and underflow using a
          combination of the return value and <tt>errno</tt>, but that
          <tt>std::scan</tt> as proposed would not be able to support that.</li>
      <li>Victor reported having previously needed to be able to differentiate
          between underflow and overflow.</li>
      <li>Tom stated that it sounds like there is some motivation for more
          granular errors.</li>
      <li>Corentin argued that isn't a question for SG16 to answer.</li>
      <li>Elias reported that there are a lot of potential error conditions and
          argued that adding a different error code for each is probably
          undesirable.</li>
      <li>Corentin asked if a distinct error code is needed for encoding
          errors.</li>
      <li>Elias responded that there had been discussion about that during the
          previous review and that we'll get to that section shortly.</li>
      <li>Corentin asserted that it would be useful to provide an iterator or
          index to the position within the input where an error occurred.</li>
      <li>Victor agreed.</li>
      <li>Victor suggested it would make sense to provide more granular error
          handling for builtin types.</li>
      <li>Victor requested some additional examples and noted that there are
          unique error cases for floating-point types.</li>
      <li>Elias mentioned that an example has been added to section 4.10,
          "Locales".</li>
      <li>Elias stated that section 4.11, "Encoding" was added for the R3
          revision.</li>
      <li>Elias summarized discussion from the last SG16 review; that
          ill-formed code unit sequences be handled similar to floating-point
          NaN values in that they don't match anything.</li>
      <li>Victor suggested that "invalidly encoded code points" should be
          changed to something like "ill-formed code unit sequences".</li>
      <li>Corentin asked if the intent is to supply replacement characters for
          ill-formed code unit sequences.</li>
      <li>Elias replied negatively and explained that the intent is to allow
          use of <tt>std::string_view</tt> as a result type that refers to
          matched characters in the input; that support precludes substitution
          of replacement characters.</li>
      <li>Elias stated that these sequences are instead handled like
          non-characters.</li>
      <li>Elias acknowledged that this design means that unsanitized input
          won't be validated and that ill-formed code unit sequences may
          persist in the output.</li>
      <li>Corentin noted the implication; that values returned by
          <tt>std::scan</tt> can't be trusted and lack of verification can
          result in UB and security issues.</li>
      <li>Elias agreed that there is a security aspect since the input could
          be arbitrary user provided input.</li>
      <li>Victor opined that the proposed behavior seems reasonable and
          consistent with other scan-like functions.</li>
      <li>Victor suggested updating the paper to compare the proposed behavior
          with <tt>scanf()</tt>.</li>
      <li>Steve noted that, even if the input was mutable, rewriting replacement
          characters into the buffer is not an option since the space needed for
          the encoded replacement character might require a longer buffer.</li>
      <li>Steve explained that Zach's proposed transcoding facilities could be
          used to pipe input that has not been validated for encoding concerns
          into the scanner such that replacement characters are proactively
          substituted.</li>
      <li><em>[ Editor's note: The input produced by such a pipeline would not
          provide a contiguous range of elements and would presumably not be
          usable with a <tt>std::string_view</tt> result type. ]</em></li>
      <li>Steve expressed a preference for features that compose.</li>
      <li>Victor asserted that it should be possible to use <tt>std::scan</tt>
          with binary data and that ill-formed code unit sequences should
          therefore not be unconditionally rejected.</li>
      <li>Corentin agreed that support for binary data is an important concern
          and referred to a comment
          <a href="https://lists.isocpp.org/sg16/2023/10/3974.php">Tom made in a message to the SG16 mailing list</a>
          about the potential use of a <tt>{:?}</tt> format specier for byte
          precise scanning.</li>
      <li>Corentin expressed uncertainty regarding how important it is to handle
          mixed binary and text.</li>
      <li>Corentin noted that the proposed design provides different guarantees
          for different types; result objects of <tt>int</tt> and <tt>float</tt>
          type will always hold valid values, but a string type might hold
          garbage.</li>
      <li>Corentin worried that programmers might expect a validly encoded
          string and be surprised.</li>
      <li>Victor claimed that it is not possible to determine what is and is
          not garbage since programmers do use string types like
          <tt>std:string_view</tt> with binary data.</li>
      <li>Victor asserted that we should not try to guess the programmer's
          intent.</li>
      <li>Tom agreed that we should not assume the programmer's intent and
          observed that providing a facility to allow them to express their
          intent could be ok.</li>
      <li>Elias reported that the example that Tom included in the
          <a href="https://lists.isocpp.org/sg16/2023/10/3971.php">agenda announcement</a>
          has been added as example 6 in section 4.3.8,
          "Type specifiers: CharT".</li>
      <li><em>[ Editor's note: the example involves a scan of the first code
          unit of a multiple code unit sequence followed by a scan of a string
          that then interprets the remainder of the code unit sequence as an
          ill-formed sequence. ]</em></li>
      <li>Corentin noted that scanning strings requires recognizing spaces and
          asked if there is a use case for a space separated sequence of random
          bytes.</li>
      <li>Corentin surmised that, if that use case is important, then it should
          influence the design.</li>
      <li>Victor recognized Corentin's observation regarding spaces and random
          bytes as important.</li>
      <li>Victor stated that the behavior described for the example in the paper
          matches his expectations.</li>
      <li>Elias argued that the entire input should not be sanitized due to
          processing overhead.</li>
      <li>Elias affirmed that an invalidly encoded string could be handled as
          an error.</li>
      <li>Tom asserted it would be useful to allow the programmer to express
          their intent with a type specifier.</li>
      <li>Tom noted that the ability to do so would allow for the kinds of
          encoding guarantees that programmers might expect and argued that this
          should be the default behavior.</li>
      <li>Elias agreed that would be useful.</li>
      <li>Elias stated that he will have to evaluate further how that fits into
          the design but that it sounds manageable.</li>
      <li>Tom asked if <tt>signed char</tt> and <tt>unsigned char</tt> are
          handled as character or integer types.</li>
      <li>Elias responded that they are treated as integer types.</li>
      <li>Tom noted that is consistent with <tt>std::format()</tt>.</li>
      <li>Elias added that it is also consistent with iostream.
      <li>Victor conveyed a lack of enthusiasm for an additional format
          specifier due to the increased complexity.</li>
      <li>Tom suggested relying on the type system instead; perhaps
          <tt>std::span&lt;char&gt;</tt> could be used to scan a
          "binary string".</li>
      <li>Victor agreed and suggested there could be another type to represent
          a broken code unit.</li>
      <li>Corentin nominated <tt>std::byte</tt>.</li>
      <li>Tom noted that <tt>std::byte</tt> wouldn't work for wide strings.</li>
      <li>Corentin countered that wide strings aren't used for binary data.</li>
      <li>Tom responded that a programmer might want to be able to read a lone
          surrogate.</li>
      <li>Victor reported that <tt>std::format()</tt> formats <tt>std::byte</tt>
          as an unsigned integer.</li>
      <li>Tom summarized his impression of the consensus at this point;
          the design is good, but some progress is needed regarding handling of
          text vs binary input.</li>
      <li>Corentin expressed a penchant for the design in general.</li>
      <li>Elias requested that the meeting minutes be published before October
          15th so that they would be available for reference by the R3 paper in
          time for the next mailing deadline.</li>
      <li>Tom said he would try.</li>
      <li><em>[ Editor's note: Tom provided a rough draft of the minutes prior
          to the 15th and that sufficed for Elias' purposes. ]</em></li>
    </ul>
  </li>
  <li>Tom announced that the next meeting will be held 1023-10-25 and that there
      are some LWG issues to be discussed, including ones involving everyone's
      favorite locale facet, <tt>std::codecvt</tt>.</li>
  <li>Hubert stated that he might soon have a paper that discusses use of
      <tt>$</tt> in identifiers.</li>
</ul>


<h1 id="2023_10_25">October 25th, 2023</h1>

<h2>Draft agenda:</h2>

<ul>
  <li>charN_t, char_traits, codecvt, and iostreams:
    <ul>
      <li><a href="https://wg21.link/p2873r0">P2873R0: Remove Deprecated Locale Category Facets For Unicode from C++26</a>.</li>
      <li><a href="https://wg21.link/lwg3767">LWG 3767: codecvt&lt;charN_t, char8_t, mbstate_t&gt; incorrectly added to locale</a>.</li>
      <li><a href="https://wg21.link/lwg2959">LWG 2959: char_traits&lt;char16_t&gt;::eof is a valid UTF-16 code unit</a>.</li>
        <ul>
          <li><a href="https://github.com/sg16-unicode/sg16/issues/32">SG16 #32: std::char_traits&lt;char16_t&gt;::eof() requires uint_least16_t to be larger than 16 bits</a>.</li>
        </ul>
      </li>
      <li><a href="https://github.com/sg16-unicode/sg16/issues/33">SG16 #33: A correct codecvt facet that works with basic_filebuf can't do UTF conversions</a>.</li>
    </ul>
  </li>
</ul>

<h2>Attendees:</h2>

<ul>
  <li>Alisdair Meredith</li>
  <li>Corentin Jabot</li>
  <li>Hubert Tong</li>
  <li>Jens Maurer</li>
  <li>Mark de Wever</li>
  <li>Nathan Owens</li>
  <li>Peter Brett</li>
  <li>Robin Leroy</li>
  <li>Steve Downey</li>
  <li>Tom Honermann</li>
  <li>Victor Zverovich</li>
</ul>

<h2>Meeting summary:</h2>

<ul>
  <li>PBrett announced that he will be retiring from C++ standardization efforts
      for the foreseeable future starting in November.</li>
  <li>Several people voiced disappointment and wished Peter well.</li>
  <li>charN_t, char_traits, codecvt, and iostreams:
    <ul>
      <li>Tom reported having reached out to the WG21 ABI review group to ask if
          there were any known ABI tricks that implementors might deploy if
          <a href="https://wg21.link/lwg2959">LWG 2959 (char_traits&lt;char16_t&gt;::eof is a valid UTF-16 code unit)</a>
          were to be fixed in the obvious way; by mapping the <tt>int_type</tt>
          member alias to a larger type.</li>
      <li>Tom summarized their response; no tricks were identified; suggestions
          included defining a replacement type for the
          <tt>std::char_traits&lt;char16_t, char, std::mb_state&gt;</tt>
          specialization that could be explicitly used in its place.</li>
      <li>Corentin replied that a replacement type doesn't solve the user
          problem.</li>
      <li>Corentin reported intent to submit a proposal to deprecate user
          specializations of <tt>std::char_traits</tt>.</li>
      <li>Corentin asked if Tom had asked the libc++ maintainers directly
          regarding their thoughts on the issue.</li>
      <li>Tom reported that he has not.</li>
      <li>Corentin suggested that doing so might be helpful.</li>
      <li>Tom reported having audited uses of the <tt>int_type</tt> and related
          members of <tt>std::char_traits</tt> throughout the standard and
          having found that they are only used within iostreams and, since the
          standard only requires iostreams to support <tt>char</tt> and
          <tt>wchar_t</tt>, changing <tt>int_type</tt> for the <tt>char16_t</tt>
          specialization appears to be a viable option.</li>
      <li><em>[ Editor's note: Tom's audit rediscovered information that was
          already known and had been reported in
          <a href="https://github.com/sg16-unicode/sg16/issues/32#issuecomment-433877435">a comment on SG16 issue #32</a>
          back in 2018. ]</em></li>
      <li>Hubert stated that the libc++ implementation of iostreams uses the
          <tt>eof()</tt> member of <tt>std::char_traits</tt> as a sentinel value
          to determine if a fill character has been specified via the
          <tt>std::setfill()</tt> I/O manipulator.</li>
      <li><em>[ Editor's note: The libc++ implementation of
          <tt>std::basic_ios</tt> has a private data member named
          <tt>__fill_</tt> of type <tt>int_type</tt> that is initlialized to
          <tt>eof()</tt>.
          When a fill character is needed, a comparison is performed against
          <tt>eof()</tt> to determine if a fill character has been set or
          whether the (possbily widened) default fill character should be used.
          ]</em></li>
      <li>Hubert noted this as an issue for the <tt>wchar_t</tt> iostream and
          <tt>std::char_traits</tt> specializations.</li>
      <li>Tom noted that, for <tt>wchar_t</tt> the EOF value is specified by
          <tt>WEOF</tt> and asked if it is known to have a value other than
          -1 anywhere.</li>
      <li>Hubert responded that he was not aware of other values being used,
          but that the value is problematic because programmers can use that
          value.</li>
      <li><em>[ Editor's note: Microsoft's <tt>wchar.h</tt> header defines
          <tt>WEOF</tt> as <tt>((wint_t)(0xFFFF))</tt> which is equivalent to
          <tt>-1</tt> converted to <tt>wint_t</tt> (<tt>unsigned short</tt>).
          ]</em></li>
      <li>Tom acknowledged the concern as applicable to the <tt>wchar_t</tt>
          specialization and that it can be treated as a separable issue.</li>
      <li>Corentin reported that the C++ standard appears to be missing a
          definition for <tt>WEOF</tt>.</li>
      <li>Jens responded that the C++ standard has an exposition value of
          "*see below*" that is intended to redirect to the C library.</li>
      <li>Jens noted the redirection is the same as for <tt>wint_t</tt>.</li>
      <li><em>[ Editor's note: See
          <a href="http://eel.is/c++draft/cwctype.syn#lib:WEOF">[cwctype.syn]</a>
          and
          <a href="http://eel.is/c++draft/cwchar.syn#lib:WEOF">[cwchar.syn]</a>.
          ]</em></li>
      <li>Tom observed that the clash with <tt>WEOF</tt> is only a problem when
          the <tt>WEOF</tt> value is in the range of <tt>wchar_t</tt> values;
          e.g., when <tt>WEOF</tt> is -1 and <tt>wchar_t</tt> is a signed
          type.</li>
      <li>Jens noted that the C standard requires that <tt>wint_t</tt> be able
          to hold all extended character values and that Hubert's concern is
          that C++ extends more flexibility to users in use of particular
          values.</li>
      <li>Tom indicated that he would work with Hubert to get an issue
          filed.</li>
      <li>Corentin stated that <tt>std::char_traits&lt;wchar_t&gt;</tt> also
          suffers from the lack of an available value for EOF in implementations
          like Microsoft's where both <tt>wchar_t</tt> and <tt>wint_t</tt> are
          16-bit and used with UTF-16.</li>
      <li><em>[ Editor's note: Microsoft's implementation uses an unsigned
          16-bit type for both <tt>wchar_t</tt> and <tt>wint_t</tt>, defines
          <tt>WEOF</tt> as <tt>((wint_t)(0xFFFF))</tt>, <tt>WCHAR_MIN</tt> as
          <tt>0</tt>, and <tt>WCHAR_MAX</tt> as <tt>0xFFFF</tt>.
          That leaves no values left for use as an EOF sentinel. ]</em></li>
      <li>Hubert expressed skepticism that such implementations are
          conforming.</li>
      <li>Jens recalled that changes were made to allow for use of UTF-16 with
          <tt>wchar_t</tt> at the core language level but that such allowances
          were not extended to the standard library.</li>
      <li><em>[ Editor's note: see
          <a href="https://wg21.link/p2460">P2460 (Relax requirements on <tt>wchar_t</tt> to match existing practices)</a>.i
          ]</em></li>
      <li>Jens acknowledged that the distinction doesn't matter much since
          existing implementations are not going to be changed.</li>
      <li>Tom expressed a preference to fix <tt>char_traits&lt;char16_t&gt;</tt>
          as a technically breaking change.</li>
      <li>Jens requested that implementors be directly contacted for
          feedback.</li>
      <li>Hubert also encouraged Jens' request since a change would break use of
          libc++ iostreams with <tt>char16_t</tt>.</li>
      <li>Jens acknowledged the potential break, but noted that the ability to
          use iostreams with <tt>char16_t</tt> might not be intentional.</li>
      <li>Jens presented <tt>std::complex</tt> as an example of a class template
          that has restrictions on which types are allowed as template type
          arguments.</li>
      <li>Alisdair stated that there are a number of class templates for which
          instantiations are only guaranteed to work with certain types.</li>
      <li>Tom asked for confirmation that <tt>std::regex</tt> is limited to
          instantiations with <tt>char</tt> and <tt>wchar_t</tt>.</li>
      <li>Alisdair confirmed that is his understanding.</li>
      <li>Corentin noted that fixing <tt>std::regex</tt> to properly support
          Unicode would require an ABI break.</li>
      <li>Tom turned discussion towards the issues concerning
          <tt>std::codecvt</tt>.</li>
      <li>Tom asked for confirmation of his expectation that everyone is in
          agreement that the
          <tt>std::codecvt&lt;charN_t, char8_t, std::mbstate_t&gt;</tt>
          specializations that should not have been added in the first place
          should be deprecated and removed.</li>
      <li>Victor replied with a thumbs up.</li>
      <li>Alisdair stated that the deprecated
          <tt>std::codecvt&lt;charN_t, char, std::mbstate_t&gt;</tt>
          specializations are only needed by implementors that want to support
          iostreams with the <tt>charN_t</tt> types.</li>
      <li>Tom agreed.</li>
      <li>Steve noted that those are specified with fixed UTF encodings.</li>
      <li>Jens stated that, as specified, those facets have the wrong
          semantics.</li>
      <li>Alisdair observed that the current semantics stand in the way of an
          implementor doing the right thing with iostreams of <tt>charN_t</tt>
          type.</li>
      <li>Jens agreed.</li>
      <li>Corentin claimed that there are two questions:
        <ul>
          <li>Whether we think <tt>std::codecvt</tt> is useful to users and
              whether we want to continue to support it in the standard.</li>
          <li>How iostreams perform conversions.</li>
        </ul>
      </li>
      <li>Corentin asserted that we don't have to rely on <tt>std::codecvt</tt>
          to implement conversions.</li>
      <li>Tom agreed, but noted that a new mechanism would presumably have to be
          applied only for the <tt>charN_t</tt> types so as not to interfere
          with iostreams of <tt>char</tt> and <tt>wchar_t</tt>.</li>
      <li>Steve stated that it isn't clear that the <tt>std::codecvt</tt> facets
          are doing what anyone wants.</li>
      <li>Tom observed that iostreams of <tt>wchar_t</tt> are pretty much only
          used on Windows and iostreams of <tt>char</tt> use a
          <tt>std::codecvt</tt> facet that does nothing by default.</li>
      <li>Alisdair requested that any proposed changes to the
          <tt>std::codecvt</tt> facets include discussion of how the virtual
          functions can be overridden to provide different behavior.</li>
      <li>Alisdair asked if any changes are required to P2873.</li>
      <li>Tom replied that he is leaning towards undeprecating those facets
          since the <tt>char8_t</tt> facets that were intended to replace them
          don't actually do so.</li>
      <li>Jens reiterated that the deprecated facets have the problem that they
          convert to the wrong encoding.</li>
      <li>Jens stated that, once removed, they could be reintroduced with new
          semantics.</li>
      <li>Tom replied that the facets have already been deprecated for two
          release cycles and that implementations diagnose them.</li>
      <li>Mark acknowledged the deprecation but pointed out that warnings are
          suppressed in system headers.</li>
      <li>Tom noted that warnings will have been generated for any explicit use
          of the deprecated specializations.</li>
      <li>Jens observed that the deprecation has only poisoned any existing
          <tt>charN_t</tt> iostream implementations and asserted that removing
          them is the clearest path forward.</li>
      <li>Jens claimed that removal sends a stonger message than deprecation for
          any existing uses.</li>
      <li>Corentin expressed support for removing them and then adding them
          again later if needed.</li>
      <li>Jens argued for focusing on cleanup in this release cycle rather than
          considering whether we want to add support for <tt>charN_t</tt> in
          iostreams.</li>
      <li>Tom turned discussion to the final issue; that the deprecated
          <tt>std::codecvt&lt;char16_t, char, std::mbstate_t&gt;</tt> facet
          doesn't satisfy the N:1 rule for <tt>std::basic_filebuf</tt>.</li>
      <li>Tom noted that the <tt>wchar_t</tt> specialization has this issue as
          well.</li>
      <li>Jens pointed out that it technically doesn't because the library does
          not permit UTF-16 for the wide encoding.</li>
      <li><em>[ Editor's note: see
          <a href="http://eel.is/c++draft/character.seq.general#1.2)">[character.seq.general]p(1,2)</a>.
          ]</em></li>
      <li>Jens asserted that we should not address this without a paper.</li>
      <li>Tom agreed.</li>
      <li>Hubert expressed his perception of where consensus is headed; that we
          are leaning towards a clean slate for a potential proposal to
          introduce iostreams of <tt>charN_t</tt>.</li>
      <li>Jens agreed.</li>
      <li>Tom interpreted that as an argument for Alisdair's paper going forward
          as is.</li>
      <li>Corentin stated that any paper that proposes iostreams for
          <tt>charN_t</tt> needs to explore use cases.</li>
      <li>Jens added that such a paper must also consider the current absence of
          <tt>std::codecvt&lt;char8_t, char, std::mbstate_t&gt;</tt>
          specializations.</li>
      <li>Tom agreed and argued that such specializations should not be added
          until there is a demonstrated need for them.</li>
      <li>Jens requested that Alisdair's paper clearly delineate what actions to
          take now vs what would be needed by a hypothetical proposal to
          introduce iostreams of <tt>charN_t</tt>.</li>
      <li>Alisdair stated he would like to update the rationale so as to better
          explain the situation to LEWG and then submit a revision for LWG for
          the post-Kona mailing.</li>
      <li>Steve suggested posting the revision to the SG16 mailing list for
          additional review.</li>
    </ul>
  </li>
  <li>Tom discussed scheduling for the next SG16 meeting:
    <ul>
      <li>Tom announced that the next regularly scheduled SG16 meeting would
          conflict with the WG21 meeting in Kona and that the one after that
          conflicts with Thanksgiving in the US.</li>
      <li>Tom suggested meeting on 2023-11-15 and 2023-12-06 and then pause
          until the new year.</li>
      <li>Jens objected that 2023-11-15 is too close to Kona post-meeting
          activities.</li>
      <li>Tom suggested meeting on 2023-12-06 and 2023-12-20.</li>
      <li>Victor stated he would not be available on 2023-12-20.</li>
      <li>Tom proposed that we meet 2023-12-06 and evaluate then whether to meet
          2023-12-20 or suspend until the new year.</li>
      <li><em>[ Editor's note: in later
          <a href="https://lists.isocpp.org/sg16/2023/10/3998.php">mailing list discussion</a>
          it was decided the group would meet again 2023-11-29 and 2023-12-13.
          ]</em></li>
    </ul>
  </li>
</ul>


<h1 id="2023_11_29">November 29th, 2023</h1>

<h2>Draft agenda:</h2>

<ul>
  <li><a href="https://wg21.link/p2980r0">P2980R0: A motivation, scope, and plan for a physical quantities and units library</a>:
    <ul>
      <li>Support for a <tt>fixed_string</tt> type as referenced in the
          <a href="https://wg21.link/p2980r0#external-dependencies">"External dependencies" section</a>.</li>
      <li>Support for <tt>std::format</tt> and display of symbol names.</li>
      <li>Support for <tt>wchar_t</tt>, <tt>char8_t</tt>, <tt>char16_t</tt>,
          and <tt>char32_t</tt>.</li>
    </ul>
  </li>
</ul>

<h2>Attendees:</h2>

<ul>
  <li>Eddie Nolan</li>
  <li>Fraser Gordon</li>
  <li>Lauri Vasama</li>
  <li>Mateusz Pusz</li>
  <li>Steve Downey</li>
  <li>Tom Honermann</li>
  <li>Victor Zverovich</li>
</ul>

<h2>Meeting summary:</h2>

<ul>
  <li>A round of introductions was held for new attendee Lauri Vasama.</li>
  <li><a href="https://wg21.link/p2980r0">P2980R0: A motivation, scope, and plan for a physical quantities and units library</a>:
    <ul>
      <li>Mateusz explained that the contents of this paper, as well as the
          contents of
          <a href="https://wg21.link/p2981">P2981 (Improving our safety with a physical quantities and units library)</a>
          and
          <a href="https://wg21.link/p2982">P2982 (<tt>std::quantity</tt> as a numeric type)</a>
          are being merged into a new paper following feedback during the Kona
          2023 meeting.</li>
      <li>Mateusz proceded with presenting a draft version of the new paper.</li>
    </ul>
  </li>
  <li><a href="https://wg21.link/p3045r0">P3045R0: Quantities and units library</a>:
    <ul>
      <li><em>[ Editor's note: D3045R0 was the active paper under discussion at
          the telecon.
          The agenda and links used here reference P3045R0 since the links to
          the draft paper were ephemeral.
          The published document may differ from the reviewed draft revision.
          ]</em></li>
      <li>Mateusz introduced the paper:
        <ul>
          <li>Formatting support is needed to present dimensions and units.</li>
          <li>Unicode doesn't provide subscript and superscript characters for
              all Latin characters, so formatting necessarily differs from
              conventional notation in some cases.</li>
          <li>The design currently specifies symbol names in terms of
              <tt>char</tt> and assumes a Unicode encoding.</li>
          <li>A <tt>fixed_string</tt> type is required to enable a unit symbol
              to be passed as a template argument for the <tt>named_unit</tt>
              class template.</li>
          <li>The library only requires a <tt>fixed_string</tt> type with read
              capabilities; mutation is not needed.</li>
          <li>There are many implementations of a <tt>fixed_string</tt> type
              and re-inventing yet another one for this library is not
              desirable.</li>
          <li>There are many design options for a <tt>fixed_string</tt> type
              including whether mutate and resize operations are supported or
              whether the type can be implemented with <tt>std::string</tt> and
              a fixed allocator.</li>
          <li><tt>std::string_view</tt> does not support mutation.</li>
          <li>The conventional notation for SI units depends on characters that
              are not represented in ASCII or in the basic character set.</li>
          <li>Some users will require ASCII-only output and there is no standard
              specification for ASCII-only symbol names.</li>
          <li>Supporting both Unicode and non-Unicode formatting requires
              alternative symbols.</li>
          <li>The <tt>basic_symbol_text</tt> class template allows for both a
              Unicode and ASCII-only representation to be provided.</li>
        </ul>
      </li>
      <li>Tom mentioned that formatted output should be designed for
          roundtripping so that the output produced is amenable to
          scanning.</li>
      <li>Tom noted that a proposal for text parsing is making its way through
          the committee.</li>
      <li><em>[ Editor's note: See
          <a href="https://wg21.link/p1729">P1729 (Text Parsing)</a>.
          ]</em></li>
      <li>Mateusz agreed that roundtripping is important to support
          serialization to a text file and back.</li>
      <li>Tom suggested that, in lieu of a <tt>fixed_string</tt> type, string
          operations could be provided by layering <tt>std::string_view</tt> on
          top of a template parameter that provides contiguous storage.</li>
      <li>Mateusz agreed that <tt>std::array</tt> could be used.</li>
      <li>Tom acknowledged that <tt>std::array</tt> is a structural type and
          thus usable as a non-type template parameter.</li>
      <li>Eddie asked if <tt>operator+</tt> and other operators could be
          provided on top of <tt>std::array</tt>.</li>
      <li>Mateusz replied that he believed so.</li>
      <li>Lauri expressed concern that deduction guides might be problematic
          due to null terminators.</li>
      <li>Tom noted that the proposal assumes that a string literal is always
          passed as the template argument for symbol names.</li>
      <li>Lauri stated that the array approach won't work if there is special
          handling of string literals.</li>
      <li>Eddie suggested that a simple wrapper type with a <tt>std::array</tt>
          member and a suitable deduction guide could work.</li>
      <li>Tom suggested use of a UDL since they can only be used with a string
          literal.</li>
      <li>Mateusz replied that consideration should be given to this
          functionality being user facing.</li>
      <li>Steve stated that use of <tt>std::array</tt> instead of a more
          specific type could lead to ambiguities later.</li>
      <li>Lauri noted that a UDL would require another structural type.</li>
      <li>Tom agreed and acknowledged that use of a UDL would affect the
          interface and the user experience.</li>
      <li>Mateusz asserted that the parameter type should have associated text
          semantics and not just provide storage.</li>
      <li>Tom asked how important it is that the programmer be able to control
          whether symbols are formatted with Unicode or ASCII-only
          characters.</li>
      <li>Mateusz replied that there are some users that require ASCII-only
          output and that an inability to opt-out of a full Unicode mode would
          be a no-go.</li>
      <li>Mateusz stated that there isn't a similar concern for iostreams since
          a manipulator could be provided to control the mode.</li>
      <li>Tom stated this can remain an open question for now.</li>
      <li>Fraser suggested that the formatter could allow the programmer to
          specify an alternate unit symbol in the format specification
          itself.</li>
      <li>Victor noted that <tt>std::print</tt> works with iostreams, so
          iostream support could be provided indirectly.</li>
      <li>Victor asked if there are interactions with locale.</li>
      <li>Mateusz replied that the ability to provide locale support is limited
          by the standard not providing access to the Unicode CLDR database or
          similarly suitable locale support.</li>
      <li>Victor recommended reserving an 'L' option specifier in the format
          specification that would render the code ill-formed for now so as to
          allow extension later without an ABI break.</li>
      <li>Eddie noted that the standard already permits an implementation to
          choose between a Unicode and ASCII symbol for iostream formatting of
          <tt>std::chrono::duration</tt>.</li>
      <li><em>[ Editor's note: see
          <a href="http://eel.is/c++draft/time.duration.io#1.5">[time.duration.io]p(1,5)</a>:
          <blockquote class="quote">
            Otherwise, if <tt>Period::type</tt> is <tt>micro</tt>, it is
            implementation-defined whether <i>units-suffix</t> is
            "Î¼s" ("\u00b5\u0073") or "us".
          ]</em></li>
      <li>Eddie opined that <tt>char8_t</tt> should probably be used for storage
          of the Unicode symbol name.</li>
      <li>Eddie asserted that the paper should substitute "basic character set"
          for "ASCII" throughout.</li>
      <li>Eddie noted that U+212B (ANGSTROM SIGN) has a tendency to get
          normalized to U+00C5 (LATIN CAPITAL LETTER A WITH RING ABOVE) or
          U+0041 (LATIN CAPITAL LETTER A) followed by
          U+030A (COMBINING RING ABOVE).</li>
      <li>Mateusz responded that, with regard to use of <tt>char8_t</tt>, that
          it was suggested to him to just use <tt>char</tt>.</li>
      <li>Tom replied that opinions differ on that.</li>
      <li>Steve asserted that the proposal should explicitly specify the code
          points to be used and should not rely on glyphs.</li>
      <li>Tom noted that the language specification has been updated to be
          explicit about code points, but that fewer such updates have been done
          for the library specification.</li>
      <li>Eddie asserted that normalization should be specified as well.</li>
      <li>Tom agreed and stated a preference for NFC.</li>
      <li>Eddie disagreed with the use of NFC since, per earlier discussion,
          U+212B (ANGSTROM SIGN) won't be preserved.</li>
      <li>Mateusz directed discussion to section 13.1.4.1
          (<tt>unit_symbol_formatting</tt>) where various enumerations are
          defined to support encapsolating formatting in the
          <tt>unit_symbol_formatting</tt> class.</li>
      <li>Victor commented that the enumeration types in that section should
          have specified underlying types unless they are intended to be
          transient.</li>
      <li>Mateusz replied that the enumerations are only used at compile-time,
          but agreed that adding a fixed underlying type might still make
          sense.</li>
      <li>Mateusz explained that <tt>space_before_unit_symbol</tt> is provided
          as a customization point to control whether a space is inserted
          between a value and its unit symbol by default.</li>
      <li>Mateusz directed discussion to section 13.2.3.1
          (<tt>std::format</tt> Grammar) and noted that the proposed grammar is
          similar to that for <tt>std::chrono</tt> with the addition of options
          for text encoding, and controls for inserting a solidus or separator
          character.</li>
      <li>Victor observed that the <tt>units-unit-modifier</tt> seems odd since,
          as specified, it requires that if any of <tt>units-text-encoding</tt>,
          <tt>units-unit-symbol-denominator</tt>, and
          <tt>units-unit-symbol-separator</tt> is present, then they all must
          be.</li>
      <li>Victor asked whether each of those terms should appear separately in
          square brackets.</li>
      <li>Mateusz replied that the intent is that each term can optionally be
          present in an unordered sequence.</li>
      <li>Tom replied that specifying an order would avoid having to consider
          each term being present multiple times.</li>
    </ul>
  </li>
  <li>Tom raised discussion of upcoming meeting plans:
    <ul>
      <li>Tom stated that the next meeting is scheduled for December 13th and
          that he would like to return to some LWG issues.</li>
      <li><em>[ Editor's note: The December 13th meeting was canceled due to
          lack of sufficient progress on the LWG issues to warrant additional
          discussion. ]</em></li>
      <li>Tom asked Mateusz if we can resume discussion of this paper on
          January 10th.</li>
      <li>Mateusz replied that he is not available that week.</li>
      <li>Tom asked if January 24th would work.</li>
      <li>Mateusz replied affirmatively.</li>
      <li>Mateusz requested a list of items to address or consider before the
          January 24th meeting so that he can work on them to try and get some
          implementation experience in the meantime.</li>
    </ul>
  </li>
</ul>


</body>
